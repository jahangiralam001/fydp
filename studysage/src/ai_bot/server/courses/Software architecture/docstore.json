[[["692f0dd0-551e-4b43-9f1e-b356d74d00fc",{"pageContent":"REPORT\nSoftware \nArchitecture \nPatterns\nMark Richards\nMark Richards\nSoftware Architecture\nPatterns\nUnderstanding Common Architecture\nPatterns and When to Use \nThem\n978-1-491-92424-2\n[LSI]\nSoftware Architecture Patterns\nby Mark Richards\nCopyright © 2015 O’Reilly Media, Inc. All rights reserved.\nPrinted in the United States of America.\nPublished by O’Reilly Media, Inc., 1005 Gravenstein Highway North, Sebastopol, CA\n95472.\nO’Reilly books may be purchased for educational, business, or sales promotional use.\nOnline editions are also available for most titles (http://oreilly.com/safari). For more\ninformation,  contact  our  corporate/institutional  sales  department:  800-998-9938  or\ncorporate@oreilly.com.\nEditor: Heather Scherer\nProduction Editor: Colleen Lobner\nCopyeditor: Amanda Kersey\nInterior Designer: David Futato\nCover Designer: Ellie Volckhausen\nIllustrator: Rebecca Demarest\nFebruary 2015: First Edition\nRevision History for the First Edition\n2015-02-24:    First Release\n2015-03-30:    Second Release","metadata":{"id":0}}],["e3df8653-746b-4b68-87e3-22d1fab79324",{"pageContent":"Cover Designer: Ellie Volckhausen\nIllustrator: Rebecca Demarest\nFebruary 2015: First Edition\nRevision History for the First Edition\n2015-02-24:    First Release\n2015-03-30:    Second Release\n2017-06-22:    Third Release\n \nThe O’Reilly logo is a registered trademark of O’Reilly Media, Inc. \nSoftware Architec‐\nture  Patterns,  the  cover  image,  and  related  trade  dress  are  trademarks  of  O’Reilly\nMedia, Inc.\nWhile  the  publisher  and  the  author  have  used  good  faith  efforts  to  ensure  that  the\ninformation and instructions contained in this work are accurate, the publisher and\nthe author disclaim all responsibility for errors or omissions, including without limi‐\ntation responsibility for damages resulting from the use of or reliance on this work.\nUse of the information and instructions contained in this work is at your own risk. If\nany  code  samples  or  other  technology  this  work  contains  or  describes  is  subject  to","metadata":{"id":1}}],["a33920a7-f2c5-43e8-805f-8c1fd185f6e5",{"pageContent":"Use of the information and instructions contained in this work is at your own risk. If\nany  code  samples  or  other  technology  this  work  contains  or  describes  is  subject  to\nopen source licenses or the intellectual property rights of others, it is your responsi‐\nbility to ensure that your use thereof complies with such licenses and/or rights.\nTable of Contents\nIntroduction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    v\n1.\nLayered Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   1\nPattern Description                                                                              1\nKey Concepts                                                                                         3\nPattern Example                                                                                    5\nConsiderations                                                                                      7","metadata":{"id":2}}],["e61ee38b-6d05-49d7-b23b-9fb20bffab70",{"pageContent":"Considerations                                                                                      7\nPattern Analysis                                                                                    8\n2.\nEvent-Driven Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    11\nMediator Topology                                                                             11\nBroker Topology                                                                                 14\nConsiderations                                                                                    17\nPattern Analysis                                                                                  18\n3.\nMicrokernel Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .    21\nPattern Description                                                                            21\nPattern Examples                                                                                23","metadata":{"id":3}}],["2c3aa873-9d11-4b5a-977a-8645a3389bdb",{"pageContent":"Pattern Description                                                                            21\nPattern Examples                                                                                23\nConsiderations                                                                                    24\nPattern Analysis                                                                                  25\n4.\nMicroservices Architecture Pattern. . . . . . . . . . . . . . . . . . . . . . . . . . . .   27\nPattern Description                                                                            27\nPattern Topologies                                                                              29\nAvoid Dependencies and Orchestration                                         32\nConsiderations                                                                                    33\nPattern Analysis                                                                                  34\niii","metadata":{"id":4}}],["9f062083-51af-49d0-87c6-5b53ce15abb1",{"pageContent":"Pattern Analysis                                                                                  34\niii\n5.Space-Based Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  37\nPattern Description                                                                            38\nPattern Dynamics                                                                               39\nConsiderations                                                                                    42\nPattern Analysis                                                                                  43\nA.   Pattern Analysis Summary. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .   45\niv | Table of Contents\nIntroduction\nIt’s  all  too  common  for  developers  to  start  coding  an  application\nwithout  a  formal  architecture  in  place.  Without  a  clear  and  well-\ndefined  architecture,  most  developers  and  architects  will  resort  to","metadata":{"id":5}}],["bbbe386b-d153-446d-8f33-8af65b2460eb",{"pageContent":"without  a  formal  architecture  in  place.  Without  a  clear  and  well-\ndefined  architecture,  most  developers  and  architects  will  resort  to\nthe  de  facto  standard  traditional  layered  architecture  pattern  (also\ncalled  the  n-tier  architecture),  creating  implicit  layers  by  separating\nsource-code   modules   into   packages.   Unfortunately,   what   often\nresults from this practice is a collection of unorganized source-code\nmodules  that  lack  clear  roles,  responsibilities,  and  relationships  to\none  another.  This  is  commonly  referred  to  as  the  big  ball  of  mud\narchitecture anti-pattern. \nApplications lacking a formal architecture are generally tightly cou‐\npled, brittle, difficult to change, and without a clear vision or direc‐\ntion.  As  a  result,  it  is  very  difficult  to  determine  the  architectural\ncharacteristics  of  the  application  without  fully  understanding  the\ninner-workings  of  every  component  and  module  in  the  system.","metadata":{"id":6}}],["64e2e615-c220-4379-9f51-4a2e20c9af46",{"pageContent":"characteristics  of  the  application  without  fully  understanding  the\ninner-workings  of  every  component  and  module  in  the  system.\nBasic  questions  about  deployment  and  maintenance  are  hard  to\nanswer:  Does  the  architecture  scale?  What  are  the  performance\ncharacteristics  of  the  application?  How  easily  does  the  application\nrespond  to  change?  What  are  the  deployment  characteristics  of  the\napplication? How responsive is the architecture? \nArchitecture   patterns   help   define   the   basic   characteristics   and\nbehavior of an application. For example, some architecture patterns\nnaturally   lend   themselves   toward   highly   scalable   applications,\nwhereas   other   architecture   patterns   naturally   lend   themselves\ntoward  applications  that  are  highly  agile.  Knowing  the  characteris‐\ntics, strengths, and weaknesses of each architecture pattern is neces‐\nv\nsary  in  order  to  choose  the  one  that  meets  your  specific  business","metadata":{"id":7}}],["4d915f5d-ae74-4722-affe-e041be69bfc9",{"pageContent":"tics, strengths, and weaknesses of each architecture pattern is neces‐\nv\nsary  in  order  to  choose  the  one  that  meets  your  specific  business\nneeds and goals. \nAs an architect, you must always justify your architecture decisions,\nparticularly when it comes to choosing a particular architecture pat‐\ntern or approach. The goal of this report is to give you enough infor‐\nmation to make and justify that decision.\nvi | Introduction\nCHAPTER 1\nLayered Architecture\nThe  most  common  architecture  pattern  is  the  layered  architecture\npattern,  otherwise  known  as  the  n-tier  architecture  pattern.  This\npattern  is  the  de  facto  standard  for  most  Java  EE  applications  and\ntherefore  is  widely  known  by  most  architects,  designers,  and  devel‐\nopers.  The  layered  architecture  pattern  closely  matches  the  tradi‐\ntional  IT  communication  and  organizational  structures  found  in\nmost companies, making it a natural choice for most business appli‐\ncation development efforts.","metadata":{"id":8}}],["6f26b873-d7c9-433a-8e7d-80801f5b29a6",{"pageContent":"tional  IT  communication  and  organizational  structures  found  in\nmost companies, making it a natural choice for most business appli‐\ncation development efforts. \nPattern Description\nComponents  within  the  layered  architecture  pattern  are  organized\ninto  horizontal  layers,  each  layer  performing  a  specific  role  within\nthe application (e.g., presentation logic or business logic). Although\nthe  layered  architecture  pattern  does  not  specify  the  number  and\ntypes of layers that must exist in the pattern, most layered architec‐\ntures  consist  of  four  standard  layers:  presentation,  business,  persis‐\ntence,  and  database  (Figure  1-1).  In  some  cases,  the  business  layer\nand persistence layer are combined into a single business layer, par‐\nticularly  when  the  persistence  logic  (e.g.,  SQL  or  HSQL)  is  embed‐\nded    within    the    business    layer    components.    Thus,    smaller\napplications  may  have  only  three  layers,  whereas  larger  and  more","metadata":{"id":9}}],["34565ea1-d795-4db9-bc9a-8011572d7d75",{"pageContent":"ded    within    the    business    layer    components.    Thus,    smaller\napplications  may  have  only  three  layers,  whereas  larger  and  more\ncomplex business applications may contain five or more layers. \nEach layer of the layered architecture pattern has a specific role and\nresponsibility  within  the  application.  For  example,  a  presentation\nlayer  would  be  responsible  for  handling  all  user  interface  and\n1\nbrowser  communication  logic,  whereas  a  business  layer  would  be\nresponsible  for  executing  specific  business  rules  associated  with  the\nrequest.  Each  layer  in  the  architecture  forms  an  abstraction  around\nthe  work  that  needs  to  be  done  to  satisfy  a  particular  business\nrequest.  For  example,  the  presentation  layer  doesn’t  need  to  know\nor  worry  about  how  to  get  customer  data;  it  only  needs  to  display\nthat  information  on  a  screen  in  particular  format.  Similarly,  the","metadata":{"id":10}}],["2869793c-578d-470f-a328-a7139575cd0f",{"pageContent":"or  worry  about  how  to  get  customer  data;  it  only  needs  to  display\nthat  information  on  a  screen  in  particular  format.  Similarly,  the\nbusiness  layer  doesn’t  need  to  be  concerned  about  how  to  format\ncustomer  data  for  display  on  a  screen  or  even  where  the  customer\ndata  is  coming  from;  it  only  needs  to  get  the  data  from  the  persis‐\ntence  layer,  perform  business  logic  against  the  data  (e.g.,  calculate\nvalues  or  aggregate  data),  and  pass  that  information  up  to  the  pre‐\nsentation layer.  \nFigure 1-1. Layered architecture pattern\nOne  of  the  powerful  features  of  the  layered  architecture  pattern  is\nthe  separation  of  concerns  among  components.  Components  within\na  specific  layer  deal  only  with  logic  that  pertains  to  that  layer.  For\nexample,  components  in  the  presentation  layer  deal  only  with  pre‐\nsentation  logic,  whereas  components  residing  in  the  business  layer","metadata":{"id":11}}],["c12d1b14-f92b-441d-9fa0-0cf7e7ea275b",{"pageContent":"example,  components  in  the  presentation  layer  deal  only  with  pre‐\nsentation  logic,  whereas  components  residing  in  the  business  layer\ndeal  only  with  business  logic.  This  type  of  component  classification\nmakes  it  easy  to  build  effective  roles  and  responsibility  models  into\nyour  architecture,  and  also  makes  it  easy  to  develop,  test,  govern,\nand  maintain  applications  using  this  architecture  pattern  due  to\nwell-defined component interfaces and limited component scope.\n2 | Chapter 1: Layered Architecture\nKey Concepts\nNotice  in  Figure  1-2  that  each  of  the  layers  in  the  architecture  is\nmarked as being closed. This is a very important concept in the lay‐\nered  architecture  pattern.  A  closed  layer  means  that  as  a  request\nmoves from layer to layer, it must go through the layer right below it\nto get to the next layer below that one. For example, a request origi‐","metadata":{"id":12}}],["237ce3c1-efef-4ecd-9229-3a3f2021d3af",{"pageContent":"moves from layer to layer, it must go through the layer right below it\nto get to the next layer below that one. For example, a request origi‐\nnating  from  the  presentation  layer  must  first  go  through  the  busi‐\nness layer and then to the persistence layer before finally hitting the\ndatabase layer. \nFigure 1-2. Closed layers and request access\nSo  why  not  allow  the  presentation  layer  direct  access  to  either  the\npersistence  layer  or  database  layer?  After  all,  direct  database  access\nfrom  the  presentation  layer  is  much  faster  than  going  through  a\nbunch  of  unnecessary  layers  just  to  retrieve  or  save  database  infor‐\nmation.  The  answer  to  this  question  lies  in  a  key  concept  known\nas layers of isolation. \nThe  layers  of  isolation  concept  means  that  changes  made  in  one\nlayer of the architecture generally don’t impact or affect components\nin other layers: the change is isolated to the components within that","metadata":{"id":13}}],["5b336d5e-04f5-4536-b908-fcde23c498ad",{"pageContent":"layer of the architecture generally don’t impact or affect components\nin other layers: the change is isolated to the components within that\nlayer,  and  possibly  another  associated  layer  (such  as  a  persistence\nlayer  containing  SQL).  If  you  allow  the  presentation  layer  direct\naccess to the persistence layer, then changes made to SQL within the\nKey Concepts | 3\npersistence layer would impact both the business layer and the pre‐\nsentation layer, thereby producing a very tightly coupled application\nwith  lots  of  interdependencies  between  components.  This  type  of\narchitecture then becomes very hard and expensive to change.  \nThe  layers  of  isolation  concept  also  means  that  each  layer  is  inde‐\npendent of the other layers, thereby having little or no knowledge of\nthe inner workings of other layers in the architecture. To understand\nthe power and importance of this concept, consider a large refactor‐\ning  effort  to  convert  the  presentation  framework  from  JSP  (Java","metadata":{"id":14}}],["98f13a76-f3b6-4e8d-be43-b9b32579bea8",{"pageContent":"the power and importance of this concept, consider a large refactor‐\ning  effort  to  convert  the  presentation  framework  from  JSP  (Java\nServer Pages) to JSF (Java Server Faces). Assuming that the contracts\n(e.g.,  model)  used  between  the  presentation  layer  and  the  business\nlayer remain the same, the business layer is not affected by the refac‐\ntoring  and  remains  completely  independent  of  the  type  of  user-\ninterface framework used by the presentation layer.  \nWhile  closed  layers  facilitate  layers  of  isolation  and  therefore  help\nisolate change within the architecture, there are times when it makes\nsense  for  certain  layers  to  be  open.  For  example,  suppose  you  want\nto  add  a  shared-services  layer  to  an  architecture  containing  com‐\nmon  service  components  accessed  by  components  within  the  busi‐\nness layer (e.g., data and string utility classes or auditing and logging","metadata":{"id":15}}],["6ae7b77d-df91-4f32-a0c2-9d05dbbe325a",{"pageContent":"mon  service  components  accessed  by  components  within  the  busi‐\nness layer (e.g., data and string utility classes or auditing and logging\nclasses).  Creating  a  services  layer  is  usually  a  good  idea  in  this  case\nbecause architecturally it restricts access to the shared services to the\nbusiness  layer  (and  not  the  presentation  layer).  Without  a  separate\nlayer,  there  is  nothing  architecturally  that  restricts  the  presentation\nlayer  from  accessing  these  common  services,  making  it  difficult  to\ngovern this access restriction.  \nIn this example, the new services layer would likely reside below the\nbusiness  layer  to  indicate  that  components  in  this  services  layer  are\nnot  accessible  from  the  presentation  layer.  However,  this  presents  a\nproblem in that the business layer is now required to go through the\nservices layer to get to the persistence layer, which makes no sense at","metadata":{"id":16}}],["fc564047-7f65-4f11-9366-775870a5c430",{"pageContent":"problem in that the business layer is now required to go through the\nservices layer to get to the persistence layer, which makes no sense at\nall.  This  is  an  age-old  problem  with  the  layered  architecture,  and  is\nsolved by creating open layers within the architecture.  \nAs illustrated in Figure 1-3, the services layer in this case is marked\nas open,  meaning requests are allowed to bypass this open layer and\ngo directly to the layer below it. In the following example, since the\nservices layer is open, the business layer is now allowed to bypass it\nand go directly to the persistence layer, which makes perfect sense.  \n4 | Chapter 1: Layered Architecture\nFigure 1-3. Open layers and request flow\nLeveraging  the  concept  of  open  and  closed  layers  helps  define  the\nrelationship  between  architecture  layers  and  request  flows  and  also\nprovides designers and developers with the necessary information to\nunderstand the various layer access restrictions within the architec‐","metadata":{"id":17}}],["6b147493-fac1-42dc-a616-81b45393afbb",{"pageContent":"provides designers and developers with the necessary information to\nunderstand the various layer access restrictions within the architec‐\nture. Failure to document or properly communicate which layers in\nthe  architecture  are  open  and  closed  (and  why)  usually  results  in\ntightly coupled and brittle architectures that are very difficult to test,\nmaintain, and deploy.\nPattern Example\nTo  illustrate  how  the  layered  architecture  works,  consider  a  request\nfrom a business user to retrieve customer information for a particu‐\nlar  individual  as  illustrated  in  Figure  1-4.  The  black  arrows  show\nthe  request  flowing  down  to  the  database  to  retrieve  the  customer\ndata,  and  the  red  arrows  show  the  response  flowing  back  up  to  the\nscreen  to  display  the  data.  In  this  example,  the  customer  informa‐\ntion consists of both customer data and order data (orders placed by\nthe customer).  \nPattern Example | 5","metadata":{"id":18}}],["0ea086eb-e7d4-4982-853f-ec97ef18515e",{"pageContent":"screen  to  display  the  data.  In  this  example,  the  customer  informa‐\ntion consists of both customer data and order data (orders placed by\nthe customer).  \nPattern Example | 5\nThe customer screen is responsible for accepting the request and dis‐\nplaying  the  customer  information.  It  does  not  know  where  the  data\nis, how it is retrieved, or how many database tables must be queries\nto  get  the  data.  Once  the  customer  screen  receives  a  request  to  get\ncustomer  information  for  a  particular  individual,  it  then  forwards\nthat  request  onto  the  customer  delegate  module.  This  module  is\nresponsible  for  knowing  which  modules  in  the  business  layer  can\nprocess  that  request  and  also  how  to  get  to  that  module  and  what\ndata it needs (the contract). The customer object in the business layer\nis  responsible  for  aggregating  all  of  the  information  needed  by  the\nbusiness  request  (in  this  case  to  get  customer  information).  This","metadata":{"id":19}}],["ede8af41-3586-4f67-a4c3-a7dcae128778",{"pageContent":"is  responsible  for  aggregating  all  of  the  information  needed  by  the\nbusiness  request  (in  this  case  to  get  customer  information).  This\nmodule calls out to the customer dao (data access object) module in\nthe  persistence  layer  to  get  customer  data,  and  also  the  order  dao\nmodule  to  get  order  information.  These  modules  in  turn  execute\nSQL  statements  to  retrieve  the  corresponding  data  and  pass  it  back\nup  to  the  customer  object  in  the  business  layer.  Once  the  customer\nobject receives the data, it aggregates the data and passes that infor‐\nmation  back  up  to  the  customer  delegate,  which  then  passes  that\ndata to the customer screen to be presented to the user.      \nFigure 1-4. Layered architecture example\nFrom  a  technology  perspective,  there  are  literally  dozens  of  ways\nthese  modules  can  be  implemented.  For  example,  in  the  Java  plat‐\nform,  the  customer  screen  can  be  a  (JSF)  Java  Server  Faces  screen","metadata":{"id":20}}],["29f5c2b1-440a-41ce-871f-828a49b3df09",{"pageContent":"these  modules  can  be  implemented.  For  example,  in  the  Java  plat‐\nform,  the  customer  screen  can  be  a  (JSF)  Java  Server  Faces  screen\n6 | Chapter 1: Layered Architecture\ncoupled  with  the  customer  delegate  as  the  managed  bean  compo‐\nnent. The customer object in the business layer can be a local Spring\nbean  or  a  remote  EJB3  bean.  The  data  access  objects  illustrated  in\nthe  previous  example  can  be  implemented  as  simple  POJO’s  (Plain\nOld  Java  Objects),  MyBatis  XML  Mapper  files,  or  even  objects\nencapsulating  raw  JDBC  calls  or  Hibernate  queries.  From  a  Micro‐\nsoft platform perspective, the customer screen can be an ASP (active\nserver pages) module using the .NET framework to access C# mod‐\nules  in  the  business  layer,  with  the  customer  and  order  data  access\nmodules implemented as ADO (ActiveX Data Objects). \nConsiderations\nThe  layered  architecture  pattern  is  a  solid  general-purpose  pattern,","metadata":{"id":21}}],["7a533b8d-194d-4eda-a1b9-5f9e68090daf",{"pageContent":"modules implemented as ADO (ActiveX Data Objects). \nConsiderations\nThe  layered  architecture  pattern  is  a  solid  general-purpose  pattern,\nmaking  it  a  good  starting  point  for  most  applications,  particularly\nwhen  you  are  not  sure  what  architecture  pattern  is  best  suited  for\nyour  application.  However,  there  are  a  couple  of  things  to  consider\nfrom an architecture standpoint when choosing this pattern.\nThe first thing to watch out for is what is known as the architecture\nsinkhole anti-pattern. This anti-pattern describes the situation where\nrequests  flow  through  multiple  layers  of  the  architecture  as  simple\npass-through  processing  with  little  or  no  logic  performed  within\neach layer. For example, assume the presentation layer responds to a\nrequest  from  the  user  to  retrieve  customer  data.  The  presentation\nlayer  passes  the  request  to  the  business  layer,  which  simply  passes","metadata":{"id":22}}],["43038b36-0a5d-4741-9426-62c5fe5bfb4b",{"pageContent":"request  from  the  user  to  retrieve  customer  data.  The  presentation\nlayer  passes  the  request  to  the  business  layer,  which  simply  passes\nthe request to the persistence layer, which then makes a simple SQL\ncall  to  the  database  layer  to  retrieve  the  customer  data.  The  data  is\nthen  passed  all  the  way  back  up  the  stack  with  no  additional  pro‐\ncessing or logic to aggregate, calculate, or transform the data. \nEvery  layered  architecture  will  have  at  least  some  scenarios  that  fall\ninto  the  architecture  sinkhole  anti-pattern.  The  key,  however,  is  to\nanalyze  the  percentage  of  requests  that  fall  into  this  category.  The\n80-20 rule is usually a good practice to follow to determine whether\nor not you are experiencing the architecture sinkhole anti-pattern. It\nis  typical  to  have  around  20  percent  of  the  requests  as  simple  pass-\nthrough  processing  and  80  percent  of  the  requests  having  some","metadata":{"id":23}}],["4074be2a-d23c-4438-8168-a00fb599089e",{"pageContent":"is  typical  to  have  around  20  percent  of  the  requests  as  simple  pass-\nthrough  processing  and  80  percent  of  the  requests  having  some\nbusiness logic associated with the request. However, if you find that\nthis ratio is reversed and a majority of your requests are simple pass-\nthrough processing, you might want to consider making some of the\nConsiderations | 7\narchitecture  layers  open,  keeping  in  mind  that  it  will  be  more  diffi‐\ncult to control change due to the lack of layer isolation. \nAnother consideration with the layered architecture pattern is that it\ntends to lend itself toward monolithic applications, even if you split\nthe  presentation  layer  and  business  layers  into  separate  deployable\nunits. While this may not be a concern for some applications, it does\npose  some  potential  issues  in  terms  of  deployment,  general  robust‐\nness and reliability, performance, and scalability.   \nPattern Analysis","metadata":{"id":24}}],["c0de01bd-c88f-4bb7-8ffd-42dabbd373a2",{"pageContent":"pose  some  potential  issues  in  terms  of  deployment,  general  robust‐\nness and reliability, performance, and scalability.   \nPattern Analysis\nThe  following  table  contains  a  rating  and  analysis  of  the  common\narchitecture characteristics for the layered architecture pattern. The\nrating  for  each  characteristic  is  based  on  the  natural  tendency\nfor that characteristic as a capability based on a typical implementa‐\ntion  of  the  pattern,  as  well  as  what  the  pattern  is  generally  known\nfor.  For  a  side-by-side  comparison  of  how  this  pattern  relates  to\nother  patterns  in  this  report,  please  refer  to  Appendix  A  at  the  end\nof this report.\nOverall agility\nRating: Low\nAnalysis:  Overall  agility  is  the  ability  to  respond  quickly  to  a\nconstantly changing environment. While change can be isolated\nthrough  the  layers  of  isolation  feature  of  this  pattern,  it  is  still\ncumbersome  and  time-consuming  to  make  changes  in  this","metadata":{"id":25}}],["857c7974-34af-42e7-8c75-2a13ece031fe",{"pageContent":"constantly changing environment. While change can be isolated\nthrough  the  layers  of  isolation  feature  of  this  pattern,  it  is  still\ncumbersome  and  time-consuming  to  make  changes  in  this\narchitecture  pattern  because  of  the  monolithic  nature  of  most\nimplementations  as  well  as  the  tight  coupling  of  components\nusually found with this pattern.\nEase of deployment\nRating: Low\nAnalysis:   Depending   on   how   you   implement   this   pattern,\ndeployment can become an issue, particularly for larger applica‐\ntions.   One   small   change   to   a   component   can   require   a\nredeployment of the entire application (or a large portion of the\napplication),  resulting  in  deployments  that  need  to  be  planned,\nscheduled,  and  executed  during  off-hours  or  on  weekends.\nAs such, this pattern does not easily lend itself toward a contin‐\nuous  delivery  pipeline,  further  reducing  the  overall  rating  for\ndeployment.\n8 | Chapter 1: Layered Architecture\nTestability","metadata":{"id":26}}],["b96f903b-d685-4db2-9d81-198d6cb1039d",{"pageContent":"As such, this pattern does not easily lend itself toward a contin‐\nuous  delivery  pipeline,  further  reducing  the  overall  rating  for\ndeployment.\n8 | Chapter 1: Layered Architecture\nTestability\nRating: High\nAnalysis:  Because  components  belong  to  specific  layers  in  the\narchitecture,  other  layers  can  be  mocked  or  stubbed,  making\nthis  pattern  is  relatively  easy  to  test.  A  developer  can  mock  a\npresentation  component  or  screen  to  isolate  testing  within  a\nbusiness  component,  as  well  as  mock  the  business  layer  to  test\ncertain screen functionality.\nPerformance\nRating: Low\nAnalysis:  While  it  is  true  some  layered  architectures  can  per‐\nform  well,  the  pattern  does  not  lend  itself  to  high-performance\napplications  due  to  the  inefficiencies  of  having  to  go  through\nmultiple layers of the architecture to fulfill a business request.\nScalability\nRating: Low\nAnalysis: Because of the trend toward tightly coupled and mon‐","metadata":{"id":27}}],["f83046aa-efbd-4c0e-a32b-ac11e7e933c4",{"pageContent":"multiple layers of the architecture to fulfill a business request.\nScalability\nRating: Low\nAnalysis: Because of the trend toward tightly coupled and mon‐\nolithic implementations of this pattern, applications build using\nthis architecture pattern are generally difficult to scale. You can\nscale  a  layered  architecture  by  splitting  the  layers  into  separate\nphysical  deployments  or  replicating  the  entire  application  into\nmultiple nodes, but overall the granularity is too broad, making\nit expensive to scale.\nEase of development\nRating: High\nAnalysis:   Ease   of   development   gets   a   relatively   high   score,\nmostly  because  this  pattern  is  so  well  known  and  is  not  overly\ncomplex to implement. Because most companies develop appli‐\ncations by separating skill sets by layers (presentation, business,\ndatabase),   this   pattern   becomes   a   natural   choice   for   most\nbusiness-application  development.  The  connection  between  a","metadata":{"id":28}}],["26703139-850b-43ff-aa4d-2c400f000b22",{"pageContent":"database),   this   pattern   becomes   a   natural   choice   for   most\nbusiness-application  development.  The  connection  between  a\ncompany’s  communication  and  organization  structure  and  the\nway  it  develops  software  is  outlined  is  what  is  called  Conway’s\nlaw.  You  can  Google  “Conway’s  law\"  to  get  more  information\nabout this fascinating correlation.\nPattern Analysis | 9\nCHAPTER 2\nEvent-Driven Architecture\nThe   event-driven   architecture   pattern   is   a   popular   distributed\nasynchronous  architecture  pattern  used  to  produce  highly  scalable\napplications.  It  is  also  highly  adaptable  and  can  be  used  for  small\napplications  and  as  well  as  large,  complex  ones.  The  event-driven\narchitecture  is  made  up  of  highly  decoupled,  single-purpose  event\nprocessing  components  that  asynchronously  receive  and  process\nevents. \nThe  event-driven  architecture  pattern  consists  of  two  main  topolo‐","metadata":{"id":29}}],["ae1d9c2f-d0fc-42ef-970f-f56320f03a8f",{"pageContent":"processing  components  that  asynchronously  receive  and  process\nevents. \nThe  event-driven  architecture  pattern  consists  of  two  main  topolo‐\ngies,  the  mediator  and  the  broker.  The  mediator  topology  is  com‐\nmonly  used  when  you  need  to  orchestrate  multiple  steps  within  an\nevent  through  a  central  mediator,  whereas  the  broker  topology  is\nused  when  you  want  to  chain  events  together  without  the  use  of  a\ncentral mediator. Because the architecture characteristics and imple‐\nmentation strategies differ between these two topologies, it is impor‐\ntant  to  understand  each  one  to  know  which  is  best  suited  for  your\nparticular situation.\nMediator Topology\nThe  mediator  topology  is  useful  for  events  that  have  multiple  steps\nand  require  some  level  of  orchestration  to  process  the  event.  For\nexample,  a  single  event  to  place  a  stock  trade  might  require  you  to","metadata":{"id":30}}],["d238cb07-3c9f-48af-9eae-c5cc9809b38a",{"pageContent":"and  require  some  level  of  orchestration  to  process  the  event.  For\nexample,  a  single  event  to  place  a  stock  trade  might  require  you  to\nfirst validate the trade, then check the compliance of that stock trade\nagainst various compliance rules, assign the trade to a broker, calcu‐\nlate the commission, and finally place the trade with that broker. All\nof  these  steps  would  require  some  level  of  orchestration  to  deter‐\n11\nmine the order of the steps and which ones can be done serially and\nin parallel.  \nThere  are  four  main  types  of  architecture  components  within  the\nmediator topology: event queues, an event mediator, event channels,\nand event processors. The event flow starts with a client sending an\nevent  to  an  event  queue,  which  is  used  to  transport  the  event  to  the\nevent  mediator.  The  event  mediator  receives  the  initial  event  and\norchestrates  that  event  by  sending  additional  asynchronous  events","metadata":{"id":31}}],["5e7230f6-cf37-4567-821a-c9c9cf97ba93",{"pageContent":"event  mediator.  The  event  mediator  receives  the  initial  event  and\norchestrates  that  event  by  sending  additional  asynchronous  events\nto  event  channels  to  execute  each  step  of  the  process.  Event  process‐\nors,  which  listen  on  the  event  channels,  receive  the  event  from  the\nevent  mediator  and  execute  specific  business  logic  to  process  the\nevent.  Figure  2-1  illustrates  the  general  mediator  topology  of  the\nevent-driven architecture pattern. \nFigure 2-1. Event-driven architecture mediator topology\nIt  is  common  to  have  anywhere  from  a  dozen  to  several  hundred\nevent  queues  in  an  event-driven  architecture.  The  pattern  does\nnot  specify  the  implementation  of  the  event  queue  component;  it\ncan be a message queue, a web service endpoint, or any combination\nthereof.\nThere are two types of events within this pattern: an initial event and\na  processing event.  The  initial  event  is  the  original  event  received  by","metadata":{"id":32}}],["8c4ed03a-7c5a-4f65-8cb9-15981e289577",{"pageContent":"thereof.\nThere are two types of events within this pattern: an initial event and\na  processing event.  The  initial  event  is  the  original  event  received  by\n12 | Chapter 2: Event-Driven Architecture\nthe    mediator,    whereas    the    processing    events    are    ones    that\nare generated by the mediator and received by the event-processing\ncomponents. \nThe   event-mediator   component   is   responsible   for   orchestrating\nthe steps contained within the initial event. For each step in the ini‐\ntial  event,  the  event  mediator  sends  out  a  specific  processing  event\nto  an  event  channel,  which  is  then  received  and  processed  by  the\nevent  processor.  It  is  important  to  note  that  the  event  mediator\ndoesn’t  actually  perform  the  business  logic  necessary  to  process  the\ninitial event; rather, it knows of the steps required to process the ini‐\ntial event. \nEvent  channels  are  used  by  the  event  mediator  to  asynchronously","metadata":{"id":33}}],["8d926955-f73c-4ec8-b8e5-eb0edaaeb4ec",{"pageContent":"initial event; rather, it knows of the steps required to process the ini‐\ntial event. \nEvent  channels  are  used  by  the  event  mediator  to  asynchronously\npass  specific  processing  events  related  to  each  step  in  the  initial\nevent to the event processors. The event channels can be either mes‐\nsage  queues  or  message  topics,  although  message  topics  are  most\nwidely  used  with  the  mediator  topology  so  that  processing  events\ncan  be  processed  by  multiple  event  processors  (each  performing  a\ndifferent task based on the processing event received). \nThe  event  processor  components  contain  the  application  business\nlogic necessary to process the processing event. Event processors are\nself-contained,  independent,  highly  decoupled  architecture  compo‐\nnents  that  perform  a  specific  task  in  the  application  or  system.\nWhile  the  granularity  of  the  event-processor  component  can  vary","metadata":{"id":34}}],["4447d494-c220-4f84-903f-1dacab8e468e",{"pageContent":"nents  that  perform  a  specific  task  in  the  application  or  system.\nWhile  the  granularity  of  the  event-processor  component  can  vary\nfrom  fine-grained  (e.g.,  calculate  sales  tax  on  an  order)  to  coarse-\ngrained (e.g., process an insurance claim), it is important to keep in\nmind  that  in  general,  each  event-processor  component  should  per‐\nform a single business task and not rely on other event processors to\ncomplete its specific task.\nThe event mediator can be implemented in a variety of ways. As an\narchitect,  you  should  understand  each  of  these  implementation\noptions to ensure that the solution you choose for the event media‐\ntor matches your needs and requirements. \nThe simplest and most common implementation of the event medi‐\nator is through open source integration hubs such as Spring Integra‐\ntion, Apache Camel, or Mule ESB. Event flows in these open source\nintegration  hubs  are  typically  implemented  through  Java  code  or  a","metadata":{"id":35}}],["4e71d92f-a499-464c-934f-f1dfa44558e9",{"pageContent":"tion, Apache Camel, or Mule ESB. Event flows in these open source\nintegration  hubs  are  typically  implemented  through  Java  code  or  a\nDSL  (domain-specific  language).  For  more  sophisticated  mediation\nand  orchestration,  you  can  use  BPEL  (business  process  execution\nlanguage)  coupled  with  a  BPEL  engine  such  as  the  open  source\nMediator Topology | 13\nApache ODE. BPEL is a standard XML-like language that describes\nthe  data  and  steps  required  for  processing  an  initial  event.  For  very\nlarge  applications  requiring  much  more  sophisticated  orchestration\n(including steps involving human interactions), you can implement\nthe  event  mediator  using  a  business  process  manager  (BPM)  such\nas jBPM.\nUnderstanding  your  needs  and  matching  them  to  the  correct  event\nmediator  implementation  is  critical  to  the  success  of  any  event-\ndriven  architecture  using  this  topology.  Using  an  open  source  inte‐","metadata":{"id":36}}],["fb890a3d-3206-466a-b5af-6b2d7c280227",{"pageContent":"mediator  implementation  is  critical  to  the  success  of  any  event-\ndriven  architecture  using  this  topology.  Using  an  open  source  inte‐\ngration  hub  to  do  very  complex  business  process  management\norchestration  is  a  recipe  for  failure,  just  as  is  implementing  a  BPM\nsolution to perform simple routing logic. \nTo  illustrate  how  the  mediator  topology  works,  suppose  you  are\ninsured through an insurance company and you decide to move. In\nthis  case,  the  initial  event  might  be  called  something  like  relocation\nevent.  The  steps  involved  in  processing  a  relocation  event  are  con‐\ntained  within  the  event  mediator  as  shown  in  Figure  2-2.  For  each\ninitial event step, the event mediator creates a processing event (e.g.,\nchange address, recalc quote, etc.), sends that processing event to the\nevent channel and waits for the processing event to be processed by\nthe  corresponding  event  processor  (e.g.,  customer  process,  quote","metadata":{"id":37}}],["4596a647-181c-402d-9747-eeae3344dddd",{"pageContent":"event channel and waits for the processing event to be processed by\nthe  corresponding  event  processor  (e.g.,  customer  process,  quote\nprocess, etc.). This process continues until all of the steps in the ini‐\ntial event have been processed. The single bar over the recalc quote\nand  update  claims  steps  in  the  event  mediator  indicates  that  these\nsteps can be run at the same time. \nBroker Topology\nThe  broker  topology  differs  from  the  mediator  topology  in  that\nthere  is  no  central  event  mediator;  rather,  the  message  flow  is  dis‐\ntributed  across  the  event  processor  components  in  a  chain-like\nfashion   through   a   lightweight   message   broker   (e.g.,   ActiveMQ,\nHornetQ,  etc.).  This  topology  is  useful  when  you  have  a  relatively\nsimple event processing flow and you do not want (or need) central\nevent orchestration.\nThere  are  two  main  types  of  architecture  components  within  the\nbroker topology: a broker component and an event processor compo‐","metadata":{"id":38}}],["8c07f564-fe5a-4c10-a566-7ed8be1d5967",{"pageContent":"event orchestration.\nThere  are  two  main  types  of  architecture  components  within  the\nbroker topology: a broker component and an event processor compo‐\nnent.  The  broker  component  can  be  centralized  or  federated  and\ncontains all of the event channels that are used within the event flow.\n14 | Chapter 2: Event-Driven Architecture\nThe  event  channels  contained  within  the  broker  component  can  be\nmessage queues, message topics, or a combination of both.\nFigure 2-2. Mediator topology example\nThis  topology  is  illustrated  in  Figure  2-3.  As  you  can  see  from  the\ndiagram,  there  is  no  central  event-mediator  component  controlling\nand  orchestrating  the  initial  event;  rather,  each  event-processor\ncomponent  is  responsible  for  processing  an  event  and  publishing  a\nnew  event  indicating  the  action  it  just  performed.  For  example,  an\nevent  processor  that  balances  a  portfolio  of  stocks  may  receive  an","metadata":{"id":39}}],["c8095d34-ddab-48b1-a497-b08e9331823e",{"pageContent":"new  event  indicating  the  action  it  just  performed.  For  example,  an\nevent  processor  that  balances  a  portfolio  of  stocks  may  receive  an\ninitial  event  called  stock  split.  Based  on  that  initial  event,  the  event\nprocessor  may  do  some  portfolio  rebalancing,  and  then  publish  a\nnew event to the broker called rebalance portfolio, which would then\nbe picked up by a different event processor. Note that there may be\ntimes  when  an  event  is  published  by  an  event  processor  but  not\npicked  up  by  any  another  event  processor.  This  is  common  when\nyou are evolving an application or providing for future functionality\nand extensions.    \nBroker Topology | 15\nFigure 2-3. Event-driven architecture broker topology\nTo  illustrate  how  the  broker  topology  works,  we’ll  use  the  same\nexample  as  in  the  mediator  topology  (an  insured  person  moves).\nSince there is no central event mediator to receive the initial event in","metadata":{"id":40}}],["41585ed1-49cc-45fa-9fe7-f0a88aaa016f",{"pageContent":"example  as  in  the  mediator  topology  (an  insured  person  moves).\nSince there is no central event mediator to receive the initial event in\nthe  broker  topology,  the  customer-process  component  receives  the\nevent directly, changes the customer address, and sends out an event\nsaying  it  changed  a  customer’s  address  (e.g.,  change  address  event).\nIn this example, there are two event processors that are interested in\nthe  change  address  event:  the  quote  process  and  the  claims  process.\nThe   quote   processor   component   recalculates   the   new   auto-\ninsurance rates based on the address change and publishes an event\nto  the  rest  of  the  system  indicating  what  it  did  (e.g.,  recalc  quote\nevent).   The   claims   processing   component,   on   the   other   hand,\nreceives the same change address event, but in this case, it updates an\noutstanding insurance claim and publishes an event to the system as","metadata":{"id":41}}],["ad9ca02d-b47b-4556-89ea-ef5d459b9273",{"pageContent":"receives the same change address event, but in this case, it updates an\noutstanding insurance claim and publishes an event to the system as\nan update claim event. These new events are then picked up by other\nevent processor components, and the event chain continues through\nthe system until there are no more events are published for that par‐\nticular initiating event.    \n16 | Chapter 2: Event-Driven Architecture\nFigure 2-4. Broker topology example\nAs you can see from Figure 2-4, the broker topology is all about the\nchaining  of  events  to  perform  a  business  function.  The  best  way  to\nunderstand  the  broker  topology  is  to  think  about  it  as  a  relay  race.\nIn a relay race, runners hold a baton and run for a certain distance,\nthen  hand  off  the  baton  to  the  next  runner,  and  so  on  down  the\nchain until the last runner crosses the finish line. In relay races, once\na runner hands off the baton, she is done with the race. This is also","metadata":{"id":42}}],["47e4f2b4-9476-4281-bf5f-d052cc6f2748",{"pageContent":"chain until the last runner crosses the finish line. In relay races, once\na runner hands off the baton, she is done with the race. This is also\ntrue  with  the  broker  topology:  once  an  event  processor  hands\noff the event, it is no longer involved with the processing of that spe‐\ncific event.\nConsiderations\nThe event-driven architecture pattern is a relatively complex pattern\nto implement, primarily due to its asynchronous distributed nature.\nWhen  implementing  this  pattern,  you  must  address  various  dis‐\ntributed architecture issues, such as remote process availability, lack\nof  responsiveness,  and  broker  reconnection  logic  in  the  event  of  a\nbroker or mediator failure.\nConsiderations | 17\nOne consideration to take into account when choosing this architec‐\nture  pattern  is  the  lack  of  atomic  transactions  for  a  single  business\nprocess.  Because  event  processor  components  are  highly  decoupled\nand  distributed,  it  is  very  difficult  to  maintain  a  transactional","metadata":{"id":43}}],["bd089f4b-c18a-44c9-96e1-b5abd66cb381",{"pageContent":"process.  Because  event  processor  components  are  highly  decoupled\nand  distributed,  it  is  very  difficult  to  maintain  a  transactional\nunit  of  work  across  them.  For  this  reason,  when  designing  your\napplication  using  this  pattern,  you  must  continuously  think  about\nwhich  events  can  and  can’t  run  independently  and  plan  the  granu‐\nlarity of your event processors accordingly. If you find that you need\nto  split  a  single  unit  of  work  across  event  processors—that  is,  if\nyou  are  using  separate  processors  for  something  that  should  be  an\nundivided  transaction—this  is  probably  not  the  right  pattern  for\nyour application.\nPerhaps  one  of  the  most  difficult  aspects  of  the  event-driven  archi‐\ntecture  pattern  is  the  creation,  maintenance,  and  governance  of  the\nevent-processor component contracts. Each event usually has a spe‐\ncific contract associated with it (e.g., the data values and data format","metadata":{"id":44}}],["63354228-7a42-4d9a-99ea-85ae02749e67",{"pageContent":"event-processor component contracts. Each event usually has a spe‐\ncific contract associated with it (e.g., the data values and data format\nbeing  passed  to  the  event  processor).  It  is  vitally  important  when\nusing  this  pattern  to  settle  on  a  standard  data  format  (e.g.,  XML,\nJSON,  Java  Object,  etc.)  and  establish  a  contract  versioning  policy\nright from the start. \nPattern Analysis\nThe  following  table  contains  a  rating  and  analysis  of  the  common\narchitecture characteristics for the event-driven architecture pattern.\nThe  rating  for  each  characteristic  is  based  on  the  natural  tendency\nfor that characteristic as a capability based on a typical implementa‐\ntion  of  the  pattern,  as  well  as  what  the  pattern  is  generally  known\nfor.  For  a  side-by-side  comparison  of  how  this  pattern  relates  to\nother  patterns  in  this  report,  please  refer  to  Appendix  A  at  the  end\nof this report.\nOverall agility\nRating: High","metadata":{"id":45}}],["fa06804a-200e-4eab-a9d2-214e26ae7c2e",{"pageContent":"for.  For  a  side-by-side  comparison  of  how  this  pattern  relates  to\nother  patterns  in  this  report,  please  refer  to  Appendix  A  at  the  end\nof this report.\nOverall agility\nRating: High\nAnalysis:  Overall  agility  is  the  ability  to  respond  quickly  to  a\nconstantly  changing  environment.  Since  event-processor  com‐\nponents  are  single-purpose  and  completely  decoupled  from\nother  event  processor  components,  changes  are  generally  iso‐\nlated to one or a few event processors and can be made quickly\nwithout impacting other components.\n18 | Chapter 2: Event-Driven Architecture\nEase of deployment\nRating: High\nAnalysis:  Overall  this  pattern  is  relatively  easy  to  deploy  due  to\nthe  decoupled  nature  of  the  event-processor  components.  The\nbroker   topology   tends   to   be   easier   to   deploy   than   the\nmediator  topology,  primarily  because  the  event  mediator  com‐\nponent  is  somewhat  tightly  coupled  to  the  event  processors:  a","metadata":{"id":46}}],["4bc8e927-12c2-49a6-acf7-667a9703b3a5",{"pageContent":"mediator  topology,  primarily  because  the  event  mediator  com‐\nponent  is  somewhat  tightly  coupled  to  the  event  processors:  a\nchange  in  an  event  processor  component  might  also  require  a\nchange in the event mediator, requiring both to be deployed for\nany given change.\nTestability\nRating: Low\nAnalysis:  While  individual  unit  testing  is  not  overly  difficult,  it\ndoes  require  some  sort  of  specialized  testing  client  or  testing\ntool to generate events. Testing is also complicated by the asyn‐\nchronous nature of this pattern.\nPerformance\nRating: High\nAnalysis:  While  it  is  certainly  possible  to  implement  an  event-\ndriven  architecture  that  does  not  perform  well  due  to  all  the\nmessaging  infrastructure  involved,  in  general,  the  pattern  ach‐\nieves   high   performance   through   its   asynchronous   capabili‐\nties;  in  other  words,  the  ability  to  perform  decoupled,  parallel\nasynchronous  operations  outweighs  the  cost  of  queuing  and","metadata":{"id":47}}],["49e008c0-0d36-4f6f-873f-6f0b3441f1bd",{"pageContent":"ties;  in  other  words,  the  ability  to  perform  decoupled,  parallel\nasynchronous  operations  outweighs  the  cost  of  queuing  and\ndequeuing messages.\nScalability\nRating: High\nAnalysis: Scalability is naturally achieved in this pattern through\nhighly independent and decoupled event processors. Each event\nprocessor  can  be  scaled  separately,  allowing  for  fine-grained\nscalability.\nEase of development\nRating: Low\nAnalysis:  Development  can  be  somewhat  complicated  due  to\nthe  asynchronous  nature  of  the  pattern  as  well  as  contract  cre‐\nation  and  the  need  for  more  advanced  error  handling  condi‐\ntions  within  the  code  for  unresponsive  event  processors  and\nfailed brokers.\nPattern Analysis | 19\nCHAPTER 3\nMicrokernel Architecture\nThe  microkernel  architecture  pattern  (sometimes  referred  to  as  the\nplug-in  architecture  pattern)  is  a  natural  pattern  for  implementing\nproduct-based applications. A product-based application is one that","metadata":{"id":48}}],["22b67d91-0b9c-4c0b-9d58-dfbb6a1536f3",{"pageContent":"plug-in  architecture  pattern)  is  a  natural  pattern  for  implementing\nproduct-based applications. A product-based application is one that\nis packaged and made available for download in versions as a typical\nthird-party  product.  However,  many  companies  also  develop  and\nrelease  their  internal  business  applications  like  software  products,\ncomplete with versions, release notes, and pluggable features. These\nare  also  a  natural  fit  for  this  pattern.  The  microkernel  architecture\npattern allows you to add additional application features as plug-ins\nto the core application, providing extensibility as well as feature sep‐\naration and isolation.\nPattern Description\nThe microkernel architecture pattern consists of two types of archi‐\ntecture  components:  a  core  system  and  plug-in  modules.  Application\nlogic is divided between independent plug-in modules and the basic\ncore   system,   providing   extensibility,   flexibility,   and   isolation   of","metadata":{"id":49}}],["18c78234-8f46-4abd-9ab8-0fb6fd8cd33d",{"pageContent":"logic is divided between independent plug-in modules and the basic\ncore   system,   providing   extensibility,   flexibility,   and   isolation   of\napplication  features  and  custom  processing  logic.  Figure  3-1  illus‐\ntrates the basic microkernel architecture pattern.\nThe  core  system  of  the  microkernel  architecture  pattern  tradition‐\nally  contains  only  the  minimal  functionality  required  to  make  the\nsystem  operational.  Many  operating  systems  implement  the  micro‐\nkernel  architecture  pattern,  hence  the  origin  of  this  pattern’s  name.\nFrom  a  business-application  perspective,  the  core  system  is  often\n21\ndefined  as  the  general  business  logic  sans  custom  code  for  special\ncases, special rules, or complex conditional processing.\nFigure 3-1. Microkernel architecture pattern\nThe plug-in modules are stand-alone, independent components that\ncontain specialized processing, additional features, and custom code","metadata":{"id":50}}],["cc505cb0-e765-477b-aca3-2a625828e4ef",{"pageContent":"Figure 3-1. Microkernel architecture pattern\nThe plug-in modules are stand-alone, independent components that\ncontain specialized processing, additional features, and custom code\nthat is meant to enhance or extend the core system to produce addi‐\ntional  business  capabilities.  Generally,  plug-in  modules  should  be\nindependent of other plug-in modules, but you can certainly design\nplug-ins  that  require  other  plug-ins  to  be  present.  Either  way,  it  is\nimportant  to  keep  the  communication  between  plug-ins  to  a  mini‐\nmum to avoid dependency issues.  \nThe  core  system  needs  to  know  about  which  plug-in  modules  are\navailable and how to get to them. One common way of implement‐\ning  this  is  through  some  sort  of  plug-in  registry.  This  registry  con‐\ntains  information  about  each  plug-in  module,  including  things  like\nits name, data contract, and remote access protocol details (depend‐\ning on how the plug-in is connected to the core system). For exam‐","metadata":{"id":51}}],["5af106c9-6163-4afa-8360-3dc40fe9ce4e",{"pageContent":"its name, data contract, and remote access protocol details (depend‐\ning on how the plug-in is connected to the core system). For exam‐\nple,  a  plug-in  for  tax  software  that  flags  high-risk  tax  audit  items\nmight   have   a   registry   entry   that   contains   the   name   of   the\nservice  (AuditChecker),  the  data  contract  (input  data  and  output\ndata), and the contract format (XML). It might also contain a WSDL\n(Web   Services   Definition   Language)   if   the   plug-in   is   accessed\nthrough SOAP.  \nPlug-in  modules  can  be  connected  to  the  core  system  through  a\nvariety  of  ways,  including  OSGi  (open  service  gateway  initiative),\nmessaging, web services, or even direct point-to-point binding (i.e.,\nobject  instantiation).  The  type  of  connection  you  use  depends  on\nthe type of application you are building (small product or large busi‐\nness application) and your specific needs (e.g., single deploy or dis‐\n22 | Chapter 3: Microkernel Architecture","metadata":{"id":52}}],["64aa6433-e248-4109-9d9c-f42f50ca57f5",{"pageContent":"the type of application you are building (small product or large busi‐\nness application) and your specific needs (e.g., single deploy or dis‐\n22 | Chapter 3: Microkernel Architecture\ntributed   deployment).   The   architecture   pattern   itself   does   not\nspecify  any  of  these  implementation  details,  only  that  the  plug-in\nmodules must remain independent from one another.\nThe contracts between the plug-in modules and the core system can\nrange  anywhere  from  standard  contracts  to  custom  ones.  Custom\ncontracts  are  typically  found  in  situations  where  plug-in  compo‐\nnents are developed by a third party where you have no control over\nthe contract used by the plug-in. In such cases, it is common to cre‐\nate  an  adapter  between  the  plug-in  contact  and  your  standard  con‐\ntract  so  that  the  core  system  doesn’t  need  specialized  code  for  each\nplug-in.  When  creating  standard  contracts  (usually  implemented","metadata":{"id":53}}],["b209cf50-f147-4822-804c-af922a293753",{"pageContent":"tract  so  that  the  core  system  doesn’t  need  specialized  code  for  each\nplug-in.  When  creating  standard  contracts  (usually  implemented\nthrough XML or a Java Map), it is important to remember to create\na versioning strategy right from the start. \nPattern Examples\nPerhaps  the  best  example  of  the  microkernel  architecture  is  the\nEclipse  IDE.  Downloading  the  basic  Eclipse  product  provides  you\nlittle  more  than  a  fancy  editor.  However,  once  you  start  adding\nplug-ins,  it  becomes  a  highly  customizable  and  useful  product.\nInternet  browsers  are  another  common  product  example  using  the\nmicrokernel architecture: viewers and other plug-ins add additional\ncapabilities  that  are  not  otherwise  found  in  the  basic  browser  (i.e.,\ncore system).\nThe  examples  are  endless  for  product-based  software,  but  what\nabout  large  business  applications?  The  microkernel  architecture","metadata":{"id":54}}],["b3fa5f31-4ec1-4a95-bfc3-bdd544cb805a",{"pageContent":"core system).\nThe  examples  are  endless  for  product-based  software,  but  what\nabout  large  business  applications?  The  microkernel  architecture\napplies  to  these  situations  as  well.  To  illustrate  this  point,  let’s  use\nanother  insurance  company  example,  but  this  time  one  involving\ninsurance claims processing.\nClaims processing is a very complicated process. Each state has dif‐\nferent rules and regulations for what is and isn’t allowed in an insur‐\nance   claim.   For   example,   some   states   allow   free   windshield\nreplacement if your windshield is damaged by a rock, whereas other\nstates  do  not.  This  creates  an  almost  infinite  set  of  conditions  for  a\nstandard claims process. \nNot  surprisingly,  most  insurance  claims  applications  leverage  large\nand complex  rules engines to handle much of this complexity. How‐\never,  these  rules  engines  can  grow  into  a  complex  big  ball  of  mud","metadata":{"id":55}}],["e5cd416d-f4fd-49d8-9fc5-419fc16e9dc2",{"pageContent":"and complex  rules engines to handle much of this complexity. How‐\never,  these  rules  engines  can  grow  into  a  complex  big  ball  of  mud\nwhere   changing   one   rule   impacts   other   rules,   or   making   a\nPattern Examples | 23\nsimple  rule  change  requires  an  army  of  analysts,  developers,  and\ntesters.  Using  the  microkernel  architecture  pattern  can  solve  many\nof these issues.\nThe stack of folders you see in Figure 3-2 represents the core system\nfor  claims  processing.  It  contains  the  basic  business  logic  required\nby  the  insurance  company  to  process  a  claim,  except  without  any\ncustom  processing.  Each  plug-in  module  contains  the  specific  rules\nfor  that  state.  In  this  example,  the  plug-in  modules  can  be  imple‐\nmented using custom source code or separate rules engine instances.\nRegardless of the implementation, the key point is that state-specific\nrules and processing is separate from the core claims system and can","metadata":{"id":56}}],["9a0c2fd7-527f-4c9e-9567-fb10e5d37d86",{"pageContent":"Regardless of the implementation, the key point is that state-specific\nrules and processing is separate from the core claims system and can\nbe  added,  removed,  and  changed  with  little  or  no  effect  on  the  rest\nof the core system or other plug-in modules.\nFigure 3-2. Microkernel architecture example\nConsiderations\nOne great thing about the microkernel architecture pattern is that it\ncan  be  embedded  or  used  as  part  of  another  architecture  pattern.\nFor  example,  if  this  pattern  solves  a  particular  problem  you  have\nwith  a  specific  volatile  area  of  the  application,  you  might  find  that\nyou can’t implement the entire architecture using this pattern. In this\ncase,   you   can   embed   the   microservices   architecture   pattern   in\nanother  pattern  you  are  using  (e.g.,  layered  architecture).  Similarly,\nthe  event-processor  components  described  in  the  previous  section\non   event-driven   architecture   could   be   implemented   using   the","metadata":{"id":57}}],["ffd96b0a-dcaf-45e4-9b4d-932235155110",{"pageContent":"the  event-processor  components  described  in  the  previous  section\non   event-driven   architecture   could   be   implemented   using   the\nmicroservices architecture pattern.\nThe  microservices  architecture  pattern  provides  great  support  for\nevolutionary  design  and  incremental  development.  You  can  first\nproduce  a  solid  core  system,  and  as  the  application  evolves  incre‐\n24 | Chapter 3: Microkernel Architecture\nmentally, add features and functionality without having to make sig‐\nnificant changes to the core system. \nFor  product-based  applications,  the  microkernel  architecture  pat‐\ntern  should  always  be  your  first  choice  as  a  starting  architecture,\nparticularly  for  those  products  where  you  will  be  releasing  addi‐\ntional   features   over   time   and   want   control   over   which   users\nget which features. If you find over time that the pattern doesn’t sat‐\nisfy  all  of  your  requirements,  you  can  always  refactor  your  applica‐","metadata":{"id":58}}],["2937661f-a079-4769-bc01-d4e5c8f71edf",{"pageContent":"get which features. If you find over time that the pattern doesn’t sat‐\nisfy  all  of  your  requirements,  you  can  always  refactor  your  applica‐\ntion  to  another  architecture  pattern  better  suited  for  your  specific\nrequirements.\nPattern Analysis\nThe  following  table  contains  a  rating  and  analysis  of  the  common\narchitecture characteristics for the microkernel architecture pattern.\nThe  rating  for  each  characteristic  is  based  on  the  natural  tendency\nfor that characteristic as a capability based on a typical implementa‐\ntion  of  the  pattern,  as  well  as  what  the  pattern  is  generally  known\nfor.  For  a  side-by-side  comparison  of  how  this  pattern  relates  to\nother  patterns  in  this  report,  please  refer  to  Appendix  A  at  the  end\nof this report.\nOverall agility\nRating: High\nAnalysis:  Overall  agility  is  the  ability  to  respond  quickly  to  a\nconstantly  changing  environment.  Changes  can  largely  be  iso‐","metadata":{"id":59}}],["ab645c42-f159-4a76-a0a7-a34eafccbbf5",{"pageContent":"of this report.\nOverall agility\nRating: High\nAnalysis:  Overall  agility  is  the  ability  to  respond  quickly  to  a\nconstantly  changing  environment.  Changes  can  largely  be  iso‐\nlated and implemented quickly through loosely coupled plug-in\nmodules. In general, the core system of most microkernel archi‐\ntectures  tends  to  become  stable  quickly,  and  as  such  is  fairly\nrobust and requires few changes over time.\nEase of deployment\nRating: High\nAnalysis:   Depending   on   how   the   pattern   is   implemented,\nthe  plug-in  modules  can  be  dynamically  added  to  the  core  sys‐\ntem at runtime (e.g., hot-deployed), minimizing downtime dur‐\ning deployment.\nPattern Analysis | 25\nTestability\nRating: High\nAnalysis:  Plug-in  modules  can  be  tested  in  isolation  and  can  be\neasily mocked by the core system to demonstrate or prototype a\nparticular feature with little or no change to the core system.\nPerformance\nRating: High\nAnalysis: While the microkernel pattern does not naturally lend","metadata":{"id":60}}],["a8b313a2-3a74-4e73-9d93-3829d5f10049",{"pageContent":"particular feature with little or no change to the core system.\nPerformance\nRating: High\nAnalysis: While the microkernel pattern does not naturally lend\nitself  to  high-performance  applications,  in  general,  most  appli‐\ncations built using the microkernel architecture pattern perform\nwell  because  you  can  customize  and  streamline  applications  to\nonly  include  those  features  you  need.  The  JBoss  Application\nServer  is  a  good  example  of  this:  with  its  plug-in  architecture,\nyou can trim down the application server to only those features\nyou   need,   removing   expensive   non-used   features   such   as\nremote  access,  messaging,  and  caching  that  consume  memory,\nCPU, and threads and slow down the app server.\nScalability\nRating: Low\nAnalysis:  Because  most  microkernel  architecture  implementa‐\ntions  are  product  based  and  are  generally  smaller  in  size,  they\nare  implemented  as  single  units  and  hence  not  highly  scalable.","metadata":{"id":61}}],["2af3d62f-9b09-4d7f-8b0d-f28529670a55",{"pageContent":"tions  are  product  based  and  are  generally  smaller  in  size,  they\nare  implemented  as  single  units  and  hence  not  highly  scalable.\nDepending  on  how  you  implement  the  plug-in  modules,  you\ncan  sometimes  provide  scalability  at  the  plug-in  feature  level,\nbut overall this pattern is not known for producing highly scala‐\nble applications.\nEase of development\nRating: Low\nAnalysis:   The   microkernel   architecture   requires   thoughtful\ndesign  and  contract  governance,  making  it  rather  complex  to\nimplement.   Contract   versioning,   internal   plug-in   registries,\nplug-in  granularity,  and  the  wide  choices  available  for  plug-in\nconnectivity  all  contribute  to  the  complexity  involved  with\nimplementing this pattern.\n26 | Chapter 3: Microkernel Architecture\nCHAPTER 4\nMicroservices Architecture Pattern\nThe microservices architecture pattern is quickly gaining ground in\nthe  industry  as  a  viable  alternative  to  monolithic  applications  and","metadata":{"id":62}}],["1ec721ad-dd9a-4bea-be43-963fa1a870d1",{"pageContent":"CHAPTER 4\nMicroservices Architecture Pattern\nThe microservices architecture pattern is quickly gaining ground in\nthe  industry  as  a  viable  alternative  to  monolithic  applications  and\nservice-oriented  architectures.  Because  this  architecture  pattern  is\nstill  evolving,  there’s  a  lot  of  confusion  in  the  industry  about  what\nthis  pattern  is  all  about  and  how  it  is  implemented.  This  section  of\nthe  report  will  provide  you  with  the  key  concepts  and  foundational\nknowledge  necessary  to  understand  the  benefits  (and  trade-offs)  of\nthis  important  architecture  pattern  and  whether  it  is  the  right  pat‐\ntern for your application.     \nPattern Description\nRegardless of the topology or implementation style you chose, there\nare several common core concepts that apply to the general architec‐\nture  pattern.  The  first  of  these  concepts  is  the  notion  of  separately\ndeployed  units.  As  illustrated  in  Figure  4-1,  each  component  of  the","metadata":{"id":63}}],["3250eec0-60fa-46bb-96f7-4beaee1470b0",{"pageContent":"ture  pattern.  The  first  of  these  concepts  is  the  notion  of  separately\ndeployed  units.  As  illustrated  in  Figure  4-1,  each  component  of  the\nmicroservices  architecture  is  deployed  as  a  separate  unit,  allowing\nfor easier deployment through an effective and streamlined delivery\npipeline,  increased  scalability,  and  a  high  degree  of  application  and\ncomponent decoupling within your application. \nPerhaps the most important concept to understand with this pattern\nis  the  notion  of  a  service  component.  Rather  than  think  about  serv‐\nices  within  a  microservices  architecture,  it  is  better  to  think  about\nservice  components,  which  can  vary  in  granularity  from  a  single\nmodule  to  a  large  portion  of  the  application.  Service  components\ncontain one or more modules (e.g., Java classes) that represent either\n27\na  single-purpose  function  (e.g.,  providing  the  weather  for  a  specific","metadata":{"id":64}}],["b00fe016-f6df-470a-950f-078784a127d4",{"pageContent":"contain one or more modules (e.g., Java classes) that represent either\n27\na  single-purpose  function  (e.g.,  providing  the  weather  for  a  specific\ncity or town) or an independent portion of a large business applica‐\ntion  (e.g.,  stock  trade  placement  or  determining  auto-insurance\nrates). Designing the right level of service component granularity is\none  of  the  biggest  challenges  within  a  microservices  architecture.\nThis  challenge  is  discussed  in  more  detail  in  the  following  service-\ncomponent orchestration subsection. \nFigure 4-1. Basic Microservices architecture pattern\nAnother  key  concept  within  the  microservices  architecture  pattern\nis  that  it  is  a  distributed  architecture,  meaning  that  all  the  compo‐\nnents  within  the  architecture  are  fully  decoupled  from  one  other\nand  accessed  through  some  sort  of  remote  access  protocol  (e.g.,\nJMS, AMQP, REST, SOAP, RMI, etc.). The distributed nature of this","metadata":{"id":65}}],["33db9642-019f-462d-9c50-60ad8e33ecf4",{"pageContent":"and  accessed  through  some  sort  of  remote  access  protocol  (e.g.,\nJMS, AMQP, REST, SOAP, RMI, etc.). The distributed nature of this\narchitecture pattern is how it achieves some of its superior scalabil‐\nity and deployment characteristics. \nOne  of  the  exciting  things  about  the  microservices  architecture  is\nthat  it  evolved  from  issues  associated  with  other  common  architec‐\nture  patterns,  rather  than  being  created  as  a  solution  waiting  for  a\nproblem  to  occur.  The  microservices  architecture  style  naturally\nevolved  from  two  main  sources:  monolithic  applications  developed\nusing  the  layered  architecture  pattern  and  distributed  applications\ndeveloped through the service-oriented architecture pattern. \nThe  evolutionary  path  from  monolithic  applications  to  a  microser‐\nvices  architecture  style  was  prompted  primarily  through  the  devel‐\nopment   of   continuous   delivery,   the   notion   of   a   continuous","metadata":{"id":66}}],["c0378633-fe8e-46e0-8fd3-b665078fb489",{"pageContent":"vices  architecture  style  was  prompted  primarily  through  the  devel‐\nopment   of   continuous   delivery,   the   notion   of   a   continuous\n28 | Chapter 4: Microservices Architecture Pattern\ndeployment   pipeline   from   development   to   production   which\nstreamlines the deployment of applications. Monolithic applications\ntypically consist of tightly coupled components that are part of a sin‐\ngle  deployable  unit,  making  it  cumbersome  and  difficult  to  change,\ntest,  and  deploy  the  application  (hence  the  rise  of  the  common\n“monthly   deployment”   cycles   typically   found   in   most   large   IT\nshops).  These  factors  commonly  lead  to  brittle  applications  that\nbreak  every  time  something  new  is  deployed.  The  microservices\narchitecture pattern addresses these issues by separating the applica‐\ntion into multiple deployable units (service components) that can be\nindividually  developed,  tested,  and  deployed  independent  of  other\nservice components.","metadata":{"id":67}}],["97295f3f-0444-43b6-ae9f-c597a5fbbb21",{"pageContent":"tion into multiple deployable units (service components) that can be\nindividually  developed,  tested,  and  deployed  independent  of  other\nservice components.\nThe other evolutionary path that lead to the microservices architec‐\nture  pattern  is  from  issues  found  with  applications  implementing\nthe service-oriented architecture pattern (SOA). While the SOA pat‐\ntern  is  very  powerful  and  offers  unparalleled  levels  of  abstraction,\nheterogeneous  connectivity,  service  orchestration,  and  the  promise\nof aligning business goals with IT capabilities, it is nevertheless com‐\nplex,  expensive,  ubiquitous,  difficult  to  understand  and  implement,\nand  is  usually  overkill  for  most  applications.  The  microservices\narchitecture   style   addresses   this   complexity   by   simplifying   the\nnotion of a service, eliminating orchestration needs, and simplifying\nconnectivity and access to service components.  \nPattern Topologies","metadata":{"id":68}}],["f3ceba31-0d83-490d-a57e-2d47f2573aca",{"pageContent":"notion of a service, eliminating orchestration needs, and simplifying\nconnectivity and access to service components.  \nPattern Topologies\nWhile there are literally dozens of ways to implement a microservi‐\nces architecture pattern, three main topologies stand out as the most\ncommon  and  popular:  the  API  REST-based  topology,  application\nREST-based topology, and the centralized messaging topology. \nThe  API  REST-based  topology  is  useful  for  websites  that  expose\nsmall,   self-contained   individual   services   through   some   sort   of\nAPI  (application  programming  interface).  This  topology,  which  is\nillustrated  in  Figure  4-2,  consists  of  very  fine-grained  service  com‐\nponents  (hence  the  name  microservices)  that  contain  one  or  two\nmodules that perform specific business functions independent from\nthe  rest  of  the  services.  In  this  topology,  these  fine-grained  service\ncomponents  are  typically  accessed  using  a  REST-based  interface","metadata":{"id":69}}],["f16054e4-e503-44b6-9f64-293ef92df737",{"pageContent":"the  rest  of  the  services.  In  this  topology,  these  fine-grained  service\ncomponents  are  typically  accessed  using  a  REST-based  interface\nimplemented  through  a  separately  deployed  web-based  API  layer.\nExamples  of  this  topology  include  some  of  the  common  single-\nPattern Topologies | 29\npurpose cloud-based RESTful web services found by Yahoo, Google,\nand Amazon.\nFigure 4-2. API REST-based topology\nThe  application  REST-based  topology  differs  from  the  API  REST-\nbased  approach  in  that  client  requests  are  received  through  tradi‐\ntional  web-based  or  fat-client  business  application  screens  rather\nthan  through  a  simple  API  layer.  As  illustrated  in  Figure  4-3,  the\nuser-interface  layer  of  the  application  is  deployed  as  a  separate  web\napplication  that  remotely  accesses  separately  deployed  service  com‐\nponents  (business  functionality)  through  simple  REST-based  inter‐","metadata":{"id":70}}],["c2e5ce2e-6c03-410e-b34a-45800ae62400",{"pageContent":"application  that  remotely  accesses  separately  deployed  service  com‐\nponents  (business  functionality)  through  simple  REST-based  inter‐\nfaces.  The  service  components  in  this  topology  differ  from  those  in\nthe API-REST-based topology in that these service components tend\nto  be  larger,  more  coarse-grained,  and  represent  a  small  portion  of\nthe  overall  business  application  rather  than  fine-grained,  single-\naction services. This topology is common for small to medium-sized\nbusiness applications that have a relatively low degree of complexity.\n30 | Chapter 4: Microservices Architecture Pattern\nFigure 4-3. Application REST-based topology\nAnother  common  approach  within  the  microservices  architecture\npattern  is  the  centralized  messaging  topology.  This  topology  (illus‐\ntrated  in  Figure  4-4)  is  similar  to  the  previous  application  REST-\nbased topology except that instead of using REST for remote access,","metadata":{"id":71}}],["606c57d5-9195-485b-a84a-929cf54fcda5",{"pageContent":"trated  in  Figure  4-4)  is  similar  to  the  previous  application  REST-\nbased topology except that instead of using REST for remote access,\nthis  topology  uses  a  lightweight  centralized  message  broker  (e.g.,\nActiveMQ,  HornetQ,  etc.).  It  is  vitally  important  when  looking  at\nthis topology not to confuse it with the service-oriented architecture\npattern  or  consider  it  “SOA-Lite.\"  The  lightweight  message  broker\nfound in this topology does not perform any orchestration, transfor‐\nmation, or complex routing; rather, it is just a lightweight transport\nto access remote service components.\nThe centralized messaging topology is typically found in larger busi‐\nness  applications  or  applications  requiring  more  sophisticated  con‐\ntrol  over  the  transport  layer  between  the  user  interface  and  the\nservice  components.  The  benefits  of  this  topology  over  the  simple\nREST-based  topology  discussed  previously  are  advanced  queuing","metadata":{"id":72}}],["8045d5b4-2f83-4596-aa7a-a2288d457c05",{"pageContent":"service  components.  The  benefits  of  this  topology  over  the  simple\nREST-based  topology  discussed  previously  are  advanced  queuing\nmechanisms,  asynchronous  messaging,  monitoring,  error  handling,\nand better overall load balancing and scalability. The single point of\nfailure  and  architectural  bottleneck  issues  usually  associated  with  a\ncentralized  broker  are  addressed  through  broker  clustering  and\nbroker  federation  (splitting  a  single  broker  instance  into  multiple\nbroker  instances  to  divide  the  message  throughput  load  based  on\nfunctional areas of the system).  \nPattern Topologies | 31\nFigure 4-4. Centralized messaging topology\nAvoid Dependencies and Orchestration\nOne of the main challenges of the microservices architecture pattern\nis determining the correct level of granularity for the service compo‐\nnents.  If  service  components  are  too  coarse-grained  you  may  not\nrealize the benefits that come with this architecture pattern (deploy‐","metadata":{"id":73}}],["3f7ae069-1f15-440a-b218-2b4efa3bb93f",{"pageContent":"nents.  If  service  components  are  too  coarse-grained  you  may  not\nrealize the benefits that come with this architecture pattern (deploy‐\nment,  scalability,  testability,  and  loose  coupling).  However,  service\ncomponents that are too fine-grained will lead to service orchestra‐\ntion  requirements,  which  will  quickly  turn  your  lean  microservices\narchitecture  into  a  heavyweight  service-oriented  architecture,  com‐\nplete  with  all  the  complexity,  confusion,  expense,  and  fluff  typically\nfound with SOA-based applications. \nIf  you  find  you  need  to  orchestrate  your  service  components  from\nwithin the user interface or API layer of the application, then chan‐\nces  are  your  service  components  are  too  fine-grained.  Similarly,  if\nyou find you need to perform inter-service communication between\nservice  components  to  process  a  single  request,  chances  are  your\nservice components are either too fine-grained or they are not parti‐","metadata":{"id":74}}],["35039c96-d182-45ea-91a0-9ed4736aa70f",{"pageContent":"service  components  to  process  a  single  request,  chances  are  your\nservice components are either too fine-grained or they are not parti‐\ntioned correctly from a business functionality standpoint.\nInter-service  communication,  which  could  force  undesired  cou‐\nplings  between  components,  can  be  handled  instead  through  a\n32 | Chapter 4: Microservices Architecture Pattern\nshared database. For example, if a service component handing Inter‐\nnet orders needs customer information, it can go to the database to\nretrieve  the  necessary  data  as  opposed  to  invoking  functionality\nwithin the customer-service component. \nThe  shared  database  can  handle  information  needs,  but  what  about\nshared  functionality?  If  a  service  component  needs  functionality\ncontained within another service component or common to all ser‐\nvice  components,  you  can  sometimes  copy  the  shared  functionality\nacross   service   components   (thereby   violating   the   DRY   princi‐","metadata":{"id":75}}],["3f7712d9-d5e4-42b9-a078-0a43f937716c",{"pageContent":"vice  components,  you  can  sometimes  copy  the  shared  functionality\nacross   service   components   (thereby   violating   the   DRY   princi‐\nple: don’t repeat yourself ). This is a fairly common practice in most\nbusiness  applications  implementing  the  microservices  architecture\npattern,  trading  off  the  redundancy  of  repeating  small  portions  of\nbusiness logic for the sake of keeping service components independ‐\nent  and  separating  their  deployment.  Small  utility  classes  might  fall\ninto this category of repeated code. \nIf  you  find  that  regardless  of  the  level  of  service  component  granu‐\nlarity  you  still  cannot  avoid  service-component  orchestration,  then\nit’s  a  good  sign  that  this  might  not  be  the  right  architecture  pattern\nfor  your  application.  Because  of  the  distributed  nature  of  this  pat‐\ntern,  it  is  very  difficult  to  maintain  a  single  transactional  unit  of","metadata":{"id":76}}],["1304fe81-19f3-4bc6-8bd1-4e07f154a275",{"pageContent":"for  your  application.  Because  of  the  distributed  nature  of  this  pat‐\ntern,  it  is  very  difficult  to  maintain  a  single  transactional  unit  of\nwork  across  (and  between)  service  components.  Such  a  practice\nwould  require  some  sort  of  transaction  compensation  framework\nfor  rolling  back  transactions,  which  adds  significant  complexity  to\nthis relatively simple and elegant architecture pattern.       \nConsiderations\nThe microservices architecture pattern solves many of the common\nissues  found  in  both  monolithic  applications  as  well  as  service-\noriented   architectures.   Since   major   application   components   are\nsplit  up  into  smaller,  separately  deployed  units,  applications  built\nusing  the  microservices  architecture  pattern  are  generally  more\nrobust,  provide  better  scalability,  and  can  more  easily  support  con‐\ntinuous delivery.\nAnother advantage of this pattern is that it provides the capability to","metadata":{"id":77}}],["8c7f3337-d581-482d-b0a6-a9d6f7a73a23",{"pageContent":"robust,  provide  better  scalability,  and  can  more  easily  support  con‐\ntinuous delivery.\nAnother advantage of this pattern is that it provides the capability to\ndo real-time production deployments, thereby significantly reducing\nthe need for the traditional monthly or weekend “big bang” produc‐\ntion  deployments.  Since  change  is  generally  isolated  to  specific  ser‐\nvice  components,  only  the  service  components  that  change  need\nto  be  deployed.  If  you  only  have  a  single  instance  of  a  service  com‐\nConsiderations | 33\nponent, you can write specialized code in the user interface applica‐\ntion  to  detect  an  active  hot-deployment  and  redirect  users  to  an\nerror  page  or  waiting  page.  Alternatively,  you  can  swap  multiple\ninstances  of  a  service  component  in  and  out  during  a  real-time\ndeployment, allowing for continuous availability during deployment\ncycles (something that is very difficult to do with the layered archi‐\ntecture pattern).","metadata":{"id":78}}],["9fc91db9-675b-46e0-af1a-75d473572298",{"pageContent":"deployment, allowing for continuous availability during deployment\ncycles (something that is very difficult to do with the layered archi‐\ntecture pattern).  \nOne final consideration to take into account is that since the micro‐\nservices  architecture  pattern  is  a  distributed  architecture,  it  shares\nsome of the same complex issues found in the event-driven architec‐\nture pattern, including contract creation, maintenance, and govern‐\nment,  remote  system  availability,  and  remote  access  authentication\nand authorization. \nPattern Analysis\nThe  following  table  contains  a  rating  and  analysis  of  the  common\narchitecture  characteristics  for  the  microservices  architecture  pat‐\ntern.  The  rating  for  each  characteristic  is  based  on  the  natural  ten‐\ndency  for  that  characteristic  as  a  capability  based  on  a  typical\nimplementation  of  the  pattern,  as  well  as  what  the  pattern  is  gener‐","metadata":{"id":79}}],["8fda20ba-455d-47ce-a115-8f759a127f45",{"pageContent":"dency  for  that  characteristic  as  a  capability  based  on  a  typical\nimplementation  of  the  pattern,  as  well  as  what  the  pattern  is  gener‐\nally  known  for.  For  a  side-by-side  comparison  of  how  this  pattern\nrelates to other patterns in this report, please refer to Appendix A at\nthe end of this report.\nOverall agility\nRating: High\nAnalysis:  Overall  agility  is  the  ability  to  respond  quickly  to  a\nconstantly  changing  environment.  Due  to  the  notion  of  sepa‐\nrately  deployed  units,  change  is  generally  isolated  to  individual\nservice components, which allows for fast and easy deployment.\nAlso,  applications  build  using  this  pattern  tend  to  be  very\nloosely coupled, which also helps facilitate change.\nEase of deployment\nRating: High\nAnalysis:  The  deployment  characteristics  of  the  microservices\npattern  rate  very  high  due  to  the  fine-grained  and  independent\nnature of the remote services. Services are generally deployed as","metadata":{"id":80}}],["f7f181d6-3119-41f6-9993-b147c7423b1f",{"pageContent":"pattern  rate  very  high  due  to  the  fine-grained  and  independent\nnature of the remote services. Services are generally deployed as\nseparate  units  of  software,  resulting  in  the  ability  to  do  “hot\ndeployments” any time during the day or night. Overall deploy‐\nment  risk  is  also  significantly  reduced,  in  that  failed  deploy‐\n34 | Chapter 4: Microservices Architecture Pattern\nments are able to be restored more quickly and only impact the\noperations on the service being deployed, resulting in continued\noperations for all other operations.\nTestability\nRating: High\nAnalysis:  Due  to  the  separation  and  isolation  of  business  func‐\ntionality  into  independent  applications,  testing  can  be  scoped,\nallowing for more targeted testing efforts. Regression testing for\na particular service component is much easier and more feasible\nthan  regression  testing  for  an  entire  monolithic  application.\nAlso,  since  the  service  components  in  this  pattern  are  loosely","metadata":{"id":81}}],["eaacd808-eb30-4a95-8236-479825be07b8",{"pageContent":"than  regression  testing  for  an  entire  monolithic  application.\nAlso,  since  the  service  components  in  this  pattern  are  loosely\ncoupled, there is much less of a chance from a development per‐\nspective  of  making  a  change  that  breaks  another  part  of  the\napplication, easing the testing burden of having to test the entire\napplication for one small change.\nPerformance\nRating: Low\nAnalysis:  While  you  can  create  applications  implemented  from\nthis pattern that perform very well, overall this pattern does not\nnaturally lend itself to high-performance applications due to the\ndistributed nature of the microservices architecture pattern.\nScalability\nRating: High\nAnalysis:   Because   the   application   is   split   into   separately\ndeployed  units,  each  service  component  can  be  individually\nscaled,  allowing  for  fine-tuned  scaling  of  the  application.  For\nexample, the admin area of a stock-trading application may not","metadata":{"id":82}}],["d6e8ecb6-3410-4e31-9045-cb5ef39c46da",{"pageContent":"deployed  units,  each  service  component  can  be  individually\nscaled,  allowing  for  fine-tuned  scaling  of  the  application.  For\nexample, the admin area of a stock-trading application may not\nneed to scale due to the low user volumes for that functionality,\nbut  the  trade-placement  service  component  may  need  to  scale\ndue to the high throughput needed by most trading applications\nfor this functionality.\nEase of development\nRating: High\nAnalysis: Because functionality is isolated into separate and dis‐\ntinct  service  components,  development  becomes  easier  due  to\nthe  smaller  and  isolated  scope.  There  is  much  less  chance  a\ndeveloper  will  make  a  change  in  one  service  component  that\nwould  affect  other  service  components,  thereby  reducing  the\ncoordination needed among developers or development teams.\nPattern Analysis | 35\nCHAPTER 5\nSpace-Based Architecture\nMost   web-based   business   applications   follow   the   same   general","metadata":{"id":83}}],["261f9cd4-25f7-41d8-a817-08dd8b975faa",{"pageContent":"coordination needed among developers or development teams.\nPattern Analysis | 35\nCHAPTER 5\nSpace-Based Architecture\nMost   web-based   business   applications   follow   the   same   general\nrequest  flow:  a  request  from  a  browser  hits  the  web  server,  then  an\napplication  server,  then  finally  the  database  server.  While  this  pat‐\ntern works great for a small set of users, bottlenecks start appearing\nas  the  user  load  increases,  first  at  the  web-server  layer,  then  at  the\napplication-server layer, and finally at the database-server layer. The\nusual response to bottlenecks based on an increase in user load is to\nscale out the web servers. This is relatively easy and inexpensive, and\nsometimes works to address the bottleneck issues. However, in most\ncases  of  high  user  load,  scaling  out  the  web-server  layer  just  moves\nthe  bottleneck  down  to  the  application  server.  Scaling  application\nservers  can  be  more  complex  and  expensive  than  web  servers  and","metadata":{"id":84}}],["d8ba1a60-07d4-42fd-a8a0-8371a88a98cf",{"pageContent":"the  bottleneck  down  to  the  application  server.  Scaling  application\nservers  can  be  more  complex  and  expensive  than  web  servers  and\nusually  just  moves  the  bottleneck  down  to  the  database  server,\nwhich is even more difficult and expensive to scale. Even if you can\nscale  the  database,  what  you  eventually  end  up  with  is  a  triangle-\nshaped  topology,  with  the  widest  part  of  the  triangle  being  the  web\nservers  (easiest  to  scale)  and  the  smallest  part  being  the  database\n(hardest to scale). \nIn  any  high-volume  application  with  an  extremely  large  concurrent\nuser  load,  the  database  will  usually  be  the  final  limiting  factor  in\nhow many transactions you can process concurrently. While various\ncaching  technologies  and  database  scaling  products  help  to  address\nthese  issues,  the  fact  remains  that  scaling  out  a  normal  application\nfor extreme loads is a very difficult proposition.\n37","metadata":{"id":85}}],["960f0e2d-a9ab-4d48-a528-35fa0aa75d93",{"pageContent":"these  issues,  the  fact  remains  that  scaling  out  a  normal  application\nfor extreme loads is a very difficult proposition.\n37\nThe  space-based  architecture  pattern  is  specifically  designed  to\naddress and solve scalability and concurrency issues. It is also a use‐\nful  architecture  pattern  for  applications  that  have  variable  and\nunpredictable  concurrent  user  volumes.  Solving  the  extreme  and\nvariable  scalability  issue  architecturally  is  often  a  better  approach\nthan  trying  to  scale  out  a  database  or  retrofit  caching  technologies\ninto a non-scalable architecture.   \nPattern Description\nThe  space-based  pattern  (also  sometimes  referred  to  as  the  cloud\narchitecture  pattern)  minimizes  the  factors  that  limit  application\nscaling.   This   pattern   gets   its   name   from   the   concept   of   tuple\nspace,  the  idea  of  distributed  shared  memory.  High  scalability  is\nachieved  by  removing  the  central  database  constraint  and  using","metadata":{"id":86}}],["e40d569f-220f-424d-865a-04a604514f06",{"pageContent":"space,  the  idea  of  distributed  shared  memory.  High  scalability  is\nachieved  by  removing  the  central  database  constraint  and  using\nreplicated in-memory data grids instead. Application data is kept in-\nmemory  and  replicated  among  all  the  active  processing  units.  Pro‐\ncessing  units  can  be  dynamically  started  up  and  shut  down  as  user\nload  increases  and  decreases,  thereby  addressing  variable  scalabil‐\nity.  Because  there  is  no  central  database,  the  database  bottleneck  is\nremoved, providing near-infinite scalability within the application.\nMost applications that fit into this pattern are standard websites that\nreceive a request from a browser and perform some sort of action. A\nbidding  auction  site  is  a  good  example  of  this.  The  site  continually\nreceives  bids  from  internet  users  through  a  browser  request.  The\napplication would receive a bid for a particular item, record that bid","metadata":{"id":87}}],["48e9267d-22c2-4bf3-ae1e-2a2bea26b63d",{"pageContent":"receives  bids  from  internet  users  through  a  browser  request.  The\napplication would receive a bid for a particular item, record that bid\nwith a timestamp, and update the latest bid information for the item,\nand send the information back to the browser. \nThere  are  two  primary  components  within  this  architecture  pat‐\ntern:  a  processing  unit  and  virtualized  middleware.  Figure  5-1  illus‐\ntrates  the  basic  space-based  architecture  pattern  and  its  primary\narchitecture components.\nThe  processing-unit  component  contains  the  application  compo‐\nnents  (or  portions  of  the  application  components).  This  includes\nweb-based  components  as  well  as  backend  business  logic.  The  con‐\ntents of the processing unit varies based on the type of application—\nsmaller web-based applications would likely be deployed into a sin‐\ngle  processing  unit,  whereas  larger  applications  may  split  the  appli‐","metadata":{"id":88}}],["075c2f40-ac2a-46dc-ac36-e5824e9d80b4",{"pageContent":"smaller web-based applications would likely be deployed into a sin‐\ngle  processing  unit,  whereas  larger  applications  may  split  the  appli‐\ncation  functionality  into  multiple  processing  units  based  on  the\nfunctional  areas  of  the  application.  The  processing  unit  typically\n38 | Chapter 5: Space-Based Architecture\ncontains  the  application  modules,  along  with  an  in-memory  data\ngrid  and  an  optional  asynchronous  persistent  store  for  failover.  It\nalso contains a replication engine that is used by the virtualized mid‐\ndleware  to  replicate  data  changes  made  by  one  processing  unit  to\nother active processing units. \nFigure 5-1. Space-based architecture pattern\nThe  virtualized-middleware  component  handles  housekeeping  and\ncommunications.   It   contains   components   that   control   various\naspects  of  data  synchronization  and  request  handling.  Included  in\nthe  virtualized  middleware  are  the  messaging  grid,  data  grid,  pro‐","metadata":{"id":89}}],["58b19e53-d32b-439e-83b6-2311aae895c5",{"pageContent":"aspects  of  data  synchronization  and  request  handling.  Included  in\nthe  virtualized  middleware  are  the  messaging  grid,  data  grid,  pro‐\ncessing  grid,  and  deployment  manager.  These  components,  which\nare described in detail in the next section, can be custom written or\npurchased as third-party products.   \nPattern Dynamics\nThe magic of the space-based architecture pattern lies in the virtual‐\nized  middleware  components  and  the  in-memory  data  grid  con‐\ntained  within  each  processing  unit.  Figure  5-2  shows  the  typical\nprocessing unit architecture containing the application modules, in-\nmemory data grid, optional asynchronous persistence store for fail‐\nover, and the data-replication engine. \nThe virtualized middleware is essentially the controller for the archi‐\ntecture and manages requests, sessions, data replication, distributed\nrequest  processing,  and  process-unit  deployment.  There  are  four","metadata":{"id":90}}],["bb2bf229-bcf4-420a-8cd2-3d6ed4e9c398",{"pageContent":"tecture and manages requests, sessions, data replication, distributed\nrequest  processing,  and  process-unit  deployment.  There  are  four\nmain  architecture  components  in  the  virtualized  middleware:  the\nPattern Dynamics | 39\nmessaging  grid,  the  data  grid,  the  processing  grid,  and  the  deploy‐\nment manager. \nFigure 5-2. Processing-unit component\nMessaging Grid\nThe  messaging  grid,  shown  in  Figure  5-3,  manages  input  request\nand session information. When a request comes into the virtualized-\nmiddleware component, the messaging-grid component determines\nwhich  active  processing  components  are  available  to  receive  the\nrequest   and   forwards   the   request   to   one   of   those   processing\nunits. The complexity of the messaging grid can range from a simple\nround-robin  algorithm  to  a  more  complex  next-available  algorithm\nthat  keeps  track  of  which  request  is  being  processed  by  which  pro‐\ncessing unit.\nData Grid","metadata":{"id":91}}],["9771bbbf-5e33-4f1f-a6e8-6ca342e0b61a",{"pageContent":"round-robin  algorithm  to  a  more  complex  next-available  algorithm\nthat  keeps  track  of  which  request  is  being  processed  by  which  pro‐\ncessing unit.\nData Grid\nThe data-grid component is perhaps the most important and crucial\ncomponent  in  this  pattern.  The  data  grid  interacts  with  the  data-\nreplication engine in each processing unit to manage the data repli‐\ncation between processing units when data updates occur. Since the\nmessaging grid can forward a request to any of the processing units\navailable, it is essential that each processing unit contains exactly the\nsame data in its in-memory data grid. Although Figure 5-4 shows a\nsynchronous  data  replication  between  processing  units,  in  reality\nthis  is  done  in  parallel  asynchronously  and  very  quickly,  sometimes\ncompleting  the  data  synchronization  in  a  matter  of  microseconds\n(one millionth of a second).\n40 | Chapter 5: Space-Based Architecture\nFigure 5-3. Messaging-grid component","metadata":{"id":92}}],["fa01dc5c-e398-4fe7-bd6f-1bf5c0c058cc",{"pageContent":"completing  the  data  synchronization  in  a  matter  of  microseconds\n(one millionth of a second).\n40 | Chapter 5: Space-Based Architecture\nFigure 5-3. Messaging-grid component\nFigure 5-4. Data-grid component\nProcessing Grid\nThe processing grid, illustrated in Figure 5-5, is an optional compo‐\nnent  within  the  virtualized  middleware  that  manages  distributed\nrequest  processing  when  there  are  multiple  processing  units,  each\nhandling  a  portion  of  the  application.  If  a  request  comes  in  that\nrequires  coordination  between  processing  unit  types  (e.g.,  an  order\nprocessing unit and a customer processing unit), it is the processing\nPattern Dynamics | 41\ngrid  that  mediates  and  orchestrates  the  request  between  those  two\nprocessing units.\nFigure 5-5. Processing-grid component\nDeployment Manager\nThe deployment-manager component manages the dynamic startup\nand  shutdown  of  processing  units  based  on  load  conditions.  This","metadata":{"id":93}}],["287fd64b-3706-4e7d-a381-ad36460a639d",{"pageContent":"Figure 5-5. Processing-grid component\nDeployment Manager\nThe deployment-manager component manages the dynamic startup\nand  shutdown  of  processing  units  based  on  load  conditions.  This\ncomponent continually monitors response times and user loads, and\nstarts up new processing units when load increases, and shuts down\nprocessing  units  when  the  load  decreases.  It  is  a  critical  component\nto achieving variable scalability needs within an application.\nConsiderations\nThe  space-based  architecture  pattern  is  a  complex  and  expensive\npattern  to  implement.  It  is  a  good  architecture  choice  for  smaller\nweb-based  applications  with  variable  load  (e.g.,  social  media  sites,\nbidding  and  auction  sites).  However,  it  is  not  well  suited  for  tradi‐\ntional large-scale relational database applications with large amounts\nof operational data.\nAlthough  the  space-based  architecture  pattern  does  not  require  a","metadata":{"id":94}}],["f98e2fef-e608-4df6-9fbf-9550e4c949d4",{"pageContent":"tional large-scale relational database applications with large amounts\nof operational data.\nAlthough  the  space-based  architecture  pattern  does  not  require  a\ncentralized datastore, one is commonly included to perform the ini‐\ntial  in-memory  data  grid  load  and  asynchronously  persist  data\nupdates  made  by  the  processing  units.  It  is  also  a  common  practice\nto  create  separate  partitions  that  isolate  volatile  and  widely  used\n42 | Chapter 5: Space-Based Architecture\ntransactional  data  from  non-active  data,  in  order  to  reduce  the\nmemory footprint of the in-memory data grid within each process‐\ning unit. \nIt is important to note that while the alternative name of this pattern\nis  the  cloud-based  architecture,  the  processing  units  (as  well  as  the\nvirtualized  middleware)  do  not  have  to  reside  on  cloud-based  hos‐\nted  services  or  PaaS  (platform  as  a  service).  It  can  just  as  easily","metadata":{"id":95}}],["1fed16c7-c860-4dc6-81e5-6c4a75008d2b",{"pageContent":"virtualized  middleware)  do  not  have  to  reside  on  cloud-based  hos‐\nted  services  or  PaaS  (platform  as  a  service).  It  can  just  as  easily\nreside on local servers, which is one of the reasons I prefer the name\n“space-based architecture.”\nFrom  a  product  implementation  perspective,  you  can  implement\nmany of the architecture components in this pattern through third-\nparty   products   such   as   GemFire,   JavaSpaces,   GigaSpaces,   IBM\nObject  Grid,  nCache,  and  Oracle  Coherence.  Because  the  imple‐\nmentation of this pattern varies greatly in terms of cost and capabili‐\nties (particularly data replication times), as an architect, you should\nfirst establish what your specific goals and needs are before making\nany product selections.  \nPattern Analysis\nThe  following  table  contains  a  rating  and  analysis  of  the  common\narchitecture characteristics for the space-based architecture pattern.\nThe  rating  for  each  characteristic  is  based  on  the  natural  tendency","metadata":{"id":96}}],["f6828c84-939d-4910-9042-d4b8f456432d",{"pageContent":"architecture characteristics for the space-based architecture pattern.\nThe  rating  for  each  characteristic  is  based  on  the  natural  tendency\nfor that characteristic as a capability based on a typical implementa‐\ntion  of  the  pattern,  as  well  as  what  the  pattern  is  generally  known\nfor.  For  a  side-by-side  comparison  of  how  this  pattern  relates  to\nother  patterns  in  this  report,  please  refer  to  Appendix  A  at  the  end\nof this report.\nOverall agility\nRating: High\nAnalysis:  Overall  agility  is  the  ability  to  respond  quickly  to  a\nconstantly   changing   environment.   Because   processing   units\n(deployed  instances  of  the  application)  can  be  brought  up  and\ndown quickly, applications respond well to changes related to an\nincrease   or   decrease   in   user   load   (environment   changes).\n Architectures created using this pattern generally respond well\nto coding changes due to the small application size and dynamic\nnature of the pattern.","metadata":{"id":97}}],["9ffb156d-d0d5-46ab-bb00-0e3402f19419",{"pageContent":"Architectures created using this pattern generally respond well\nto coding changes due to the small application size and dynamic\nnature of the pattern.\nPattern Analysis | 43\nEase of deployment\nRating: High\nAnalysis:  Although  space-based  architectures  are  generally  not\ndecoupled and distributed, they are dynamic, and sophisticated\ncloud-based  tools  allow  for  applications  to  easily  be  “pushed”\nout to servers, simplifying deployment.\nTestability\nRating: Low\nAnalysis: Achieving very high user loads in a test environment is\nboth  expensive  and  time  consuming,  making  it  difficult  to  test\nthe scalability aspects of the application.\nPerformance\nRating: High\nAnalysis: High performance is achieved through the in-memory\ndata access and caching mechanisms build into this pattern.\nScalability\nRating: High\nAnalysis:  High  scalability  come  from  the  fact  that  there  is  little\nor  no  dependency  on  a  centralized  database,  therefore  essen‐","metadata":{"id":98}}],["3622884c-69e8-4cf9-9c70-5a6cc5bc8632",{"pageContent":"Scalability\nRating: High\nAnalysis:  High  scalability  come  from  the  fact  that  there  is  little\nor  no  dependency  on  a  centralized  database,  therefore  essen‐\ntially  removing  this  limiting  bottleneck  from  the  scalability\nequation.\nEase of development\nRating: Low\nAnalysis: Sophisticated caching and in-memory data grid prod‐\nucts  make  this  pattern  relatively  complex  to  develop,  mostly\nbecause  of  the  lack  of  familiarity  with  the  tools  and  products\nused  to  create  this  type  of  architecture.  Furthermore,  special\ncare must be taken while developing these types of architectures\nto  make  sure  nothing  in  the  source  code  impacts  performance\nand scalability.\n44 | Chapter 0: Space-Based Architecture\nAPPENDIX A\nPattern Analysis Summary\nFigure  A-1  summarizes  the  pattern-analysis  scoring  for  each  of  the\narchitecture  patterns  described  in  this  report.  This  summary  will\nhelp  you  determine  which  pattern  might  be  best  for  your  situation.","metadata":{"id":99}}],["d5a4f4f6-8541-4b51-8bde-6e0c1f6ef6a2",{"pageContent":"architecture  patterns  described  in  this  report.  This  summary  will\nhelp  you  determine  which  pattern  might  be  best  for  your  situation.\nFor example, if your primary architectural concern is scalability, you\ncan  look  across  this  chart  and  see  that  the  event-driven  pattern,\nmicroservices  pattern,  and  space-based  pattern  are  probably  good\narchitecture  pattern  choices.  Similarly,  if  you  choose  the  layered\narchitecture  pattern  for  your  application,  you  can  refer  to  the  chart\nto  see  that  deployment,  performance,  and  scalability  might  be  risk\nareas in your architecture.  \n45\nFigure A-1. Pattern-analysis summary\nWhile  this  chart  will  help  guide  you  in  choosing  the  right  pattern,\nthere is much more to consider when choosing an architecture pat‐\ntern.  You  must  analyze  all  aspects  of  your  environment,  including\ninfrastructure  support,  developer  skill  set,  project  budget,  project","metadata":{"id":100}}],["8044e192-5748-43d1-bdf8-422ab282ecdc",{"pageContent":"tern.  You  must  analyze  all  aspects  of  your  environment,  including\ninfrastructure  support,  developer  skill  set,  project  budget,  project\ndeadlines,  and  application  size  (to  name  a  few).  Choosing  the  right\narchitecture  pattern  is  critical,  because  once  an  architecture  is  in\nplace, it is very hard (and expensive) to change.\n46 | Appendix A: Pattern Analysis Summary\nAbout the Author\nMark   Richards   is   an   experienced,   hands-on   software   architect\ninvolved  in  the  architecture,  design,  and  implementation  of  micro‐\nservices   architectures,   service-oriented   architectures,   and   dis‐\ntributed systems in J2EE and other technologies. He has been in the\nsoftware  industry  since  1983  and  has  significant  experience  and\nexpertise  in  application,  integration,  and  enterprise  architecture.\nMark served as the president of the New England Java Users Group\nfrom  1999  through  2003.  He  is  the  author  of  numerous  technical","metadata":{"id":101}}],["3feb83d0-2cf5-43c4-a54e-878dd2cb2db3",{"pageContent":"Mark served as the president of the New England Java Users Group\nfrom  1999  through  2003.  He  is  the  author  of  numerous  technical\nbooks   and   videos,   including   \nSoftware   Architecture   Fundamen‐\ntals  (O’Reilly  video),  Enterprise  Messaging  (O’Reilly  video),  Java\nMessage Service, 2nd Edition (O’Reilly), and a contributing author\nto   97  Things  Every  Software  Architect  Should  Know  (O’Reilly).\nMark  has  a  master’s  degree  in   computer  science  and  numerous\narchitect  and  developer  certifications  from  IBM,  Sun,  The  Open\nGroup,  and  BEA.  He  is   a  regular  conference  speaker  at    the  No\nFluff  Just  Stuff  (NFJS)  Symposium  Series  and  has  spoken  at    more\nthan 100 conferences and user groups around the world on a vari‐\nety of   enterprise-related technical topics. When he is  not working,\nMark  can  usually  be  found  hiking  in   the  White  Mountains  or\nalong the Appalachian Trail.","metadata":{"id":102}}],["fab66ed2-9e01-48e0-9e12-afd2863b4508",{"pageContent":"www.EBooksWorld.ir\nDesigning \nSoftware \nArchitectures\nwww.EBooksWorld.ir\nT\nhe SEI Series in Software Engineering is a collaborative undertaking of the\nCarnegie Mellon Software Engineering Institute (SEI) and Addison-Wesley to \ndevelop and publish books on software engineering and related topics. The common \ngoal of the SEI and Addison-Wesley is to provide the most current information on \nthese topics in a form that is easily usable by practitioners and students.\nTitles in the series describe frameworks, tools, methods, and technologies designed \nto help organizations, teams, and individuals improve their technical or management \ncapabilities. Some books describe processes and practices for developing higher-\nquality software, acquiring programs for complex systems, or delivering services more \ne\u001f  ectively. Other books focus on software and system architecture and product-line \ndevelopment. Still others, from the SEI’s CERT Program, describe technologies and","metadata":{"id":103}}],["8860cfb7-c10e-493c-92a1-b4d6ecd54c26",{"pageContent":"e\u001f  ectively. Other books focus on software and system architecture and product-line \ndevelopment. Still others, from the SEI’s CERT Program, describe technologies and \npractices needed to manage software and network security risk. These and all titles \nin the series address critical problems in software engineering for which practical \nsolutions are available. \nVisit informit.com/sei for a complete list of available publications.\nThe SEI Series in Software Engineering\n Software Engineering Institute of Carnegie Mellon University and Addison-Wesley\nMake sure to connect with us!\ninformit.com/socialconnect\nwww.EBooksWorld.ir\nDesigning \nSoftware \nArchitectures\nA Practical Approach \nHumberto Cervantes\nRick Kazman\nBoston • Columbus • Indianapolis • New York • San Francisco • Amsterdam • Cape Town \nDubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto • Delhi • Mexico City \nSão Paulo • Sidney • Hong Kong • Seoul • Singapore • Taipei • Tokyo\nwww.EBooksWorld.ir","metadata":{"id":104}}],["d78dadb1-1975-4660-95f1-ce30c6d55bcd",{"pageContent":"Dubai • London • Madrid • Milan • Munich • Paris • Montreal • Toronto • Delhi • Mexico City \nSão Paulo • Sidney • Hong Kong • Seoul • Singapore • Taipei • Tokyo\nwww.EBooksWorld.ir\nThe SEI Series in Software Engineering\nMany  of  the  designations  used  by  manufacturers  and  sellers  to  distinguish  their  products  are  \nclaimed  as  trademarks.  Where  those  designations  appear  in  this  book,  and  the  publisher  was  \naware of a trademark claim, the designations have been printed with initial capital letters or in \nall capitals.\nCMM,  CMMI,  Capability  Maturity  Model,  Capability  Maturity  Modeling,  Carnegie  Mellon,  \nCERT, and CERT Coordination Center are registered in the U.S. Patent and Trademark Office \nby Carnegie Mellon University. \nATAM;  Architecture  Tradeoff  Analysis  Method;  CMM  Integration;  COTS  Usage-Risk  Evalu-\nation;  CURE;  EPIC;  Evolutionary  Process  for  Integrating  COTS  Based  Systems;  Framework","metadata":{"id":105}}],["b975645b-9d92-46eb-a097-73a6ffdcd2a4",{"pageContent":"ATAM;  Architecture  Tradeoff  Analysis  Method;  CMM  Integration;  COTS  Usage-Risk  Evalu-\nation;  CURE;  EPIC;  Evolutionary  Process  for  Integrating  COTS  Based  Systems;  Framework  \nfor  Software  Product  Line  Practice;  IDEAL;  Interim  Profile;  OAR;  OCTAVE;  Operationally  \nCritical Threat, Asset, and Vulnerability Evaluation; Options Analysis for Reengineering; Per-\nsonal Software Process; PLTP; Product Line Technical Probe; PSP; SCAMPI; SCAMPI Lead \nAppraiser;  SCAMPI  Lead  Assessor;  SCE;  SEI;  SEPG;  Team  Software  Process;  and  TSP  are  \nservice marks of Carnegie Mellon University.  \nFor  information  about  buying  this  title  in  bulk  quantities,  or  for  special  sales  opportunities  \n(which  may  include  electronic  versions;  custom  cover  designs;  and  content  particular  to  your  \nbusiness,  training  goals,  marketing  focus,  or  branding  interests),  please  contact  our  corporate  \nsales department at corpsales@pearsoned.com or (800) 382-3419.","metadata":{"id":106}}],["31b6a676-66e4-462e-9a5b-c7b60e482081",{"pageContent":"business,  training  goals,  marketing  focus,  or  branding  interests),  please  contact  our  corporate  \nsales department at corpsales@pearsoned.com or (800) 382-3419.\nFor government sales inquiries, please contact governmentsales@pearsoned.com. \nFor questions about sales outside the United States, please contact intlcs@pearson.com. \nVisit us on the Web: informit.com/aw\nLibrary of Congress Cataloging-in-Publication Data\nNames: Cervantes, Humberto, 1974- author. | Kazman, Rick, author.\nTitle: Designing software architectures : a practical approach / Humberto\n Cervantes, Rick Kazman.\nDescription: Boston : Addison-Wesley, [2016] | Series: The SEI series in\n software engineering | Includes bibliographical references and index.\nIdentifiers: LCCN 2016005436| ISBN 9780134390789 (hardcover : alk. paper) |\n ISBN 0134390784 (hardcover : alk. paper)\nSubjects: LCSH: Software architecture. | Big data.\nClassification: LCC QA76.758 .C44 2016 | DDC 005.1/2—dc23","metadata":{"id":107}}],["e4efaaa7-68b4-499c-8e77-9ac0a48ee420",{"pageContent":"ISBN 0134390784 (hardcover : alk. paper)\nSubjects: LCSH: Software architecture. | Big data.\nClassification: LCC QA76.758 .C44 2016 | DDC 005.1/2—dc23\nLC record available at https://lccn.loc.gov/2016005436\nCopyright © 2016 Pearson Education, Inc.\nAll  rights  reserved.  Printed  in  the  United  States  of  America.  This  publication  is  protected  by  \ncopyright,  and  permission  must  be  obtained  from  the  publisher  prior  to  any  prohibited  repro-\nduction, storage in a retrieval system, or transmission in any form or by any means, electronic, \nmechanical,  photocopying,  recording,  or  likewise.  For  information  regarding  permissions,  re-\nquest forms and the appropriate contacts within the Pearson Education Global Rights & Permis-\nsions Department, please visit www.pearsoned.com/permissions.\nISBN-13: 978-013-439078-9 \nISBN-10: 0-13-439078-4\nText printed in the United States on recycled paper at RR Donnelley in Crawfordsville, Indiana. \nFirst printing, May 2016\nwww.EBooksWorld.ir\nv","metadata":{"id":108}}],["18e82d7a-ab94-44a1-bdf3-d793f1e509b5",{"pageContent":"ISBN-13: 978-013-439078-9 \nISBN-10: 0-13-439078-4\nText printed in the United States on recycled paper at RR Donnelley in Crawfordsville, Indiana. \nFirst printing, May 2016\nwww.EBooksWorld.ir\nv\nContents\nPreface        xiii\nAcknowledgments        xvii\n    CHAPTER    1    Introduction        1\n1.1 Motivations                1\n1.2 Software Architecture                3\n1.2.1 The Importance of Software Architecture        3\n1.2.2\n Life-Cycle Activities        4\n1.3 The Role of the Architect                7\n1.4 A Brief History of ADD                8\n1.5 Summary                9\n1.6 Further Reading                10\n CHAPTER 2 Architectural Design     11\n2.1 Design in General                11\n2.2 Design in Software Architecture                13\n2.2.1 Architectural Design        14\n2.2.2\n Element Interaction Design        14\n2.2.3\n Element Internals Design        15\n2.3 Why Is Architectural Design So Important?                16\n2.4 Architectural Drivers                17\n2.4.1 Design Purpose        18\n2.4.2","metadata":{"id":109}}],["6b430309-6612-4674-8ea8-ca494d5e6858",{"pageContent":"2.2.3\n Element Internals Design        15\n2.3 Why Is Architectural Design So Important?                16\n2.4 Architectural Drivers                17\n2.4.1 Design Purpose        18\n2.4.2\n Quality Attributes        19\n2.4.3\n Primary Functionality        25\n2.4.4\n Architectural Concerns        26\n2.4.5\n Constraints        27\n2.5 Design Concepts: The Building Blocks for Creating \nStructures                28\n2.5.1 Reference Architectures        29\n2.5.2\n Architectural Design Patterns        29\n2.5.3\n Deployment Patterns        32\nwww.EBooksWorld.ir\nvi Contents \n2.5.4 Tactics        33\n2.5.5\n Externally Developed Components        35\n2.6 Architecture Design Decisions                38\n2.7 Summary                40\n2.8 Further Reading                41\n CHAPTER 3 The Architecture Design Process             43\n3.1 The Need for a Principled Method                43\n3.2 Attribute-Driven Design 3.0                44\n3.2.1 Step 1: Review Inputs        44\n3.2.2\n  Step 2: Establish the Iteration Goal by Selecting \nDrivers","metadata":{"id":110}}],["80af3016-6884-462b-a1bf-603d1ec8c196",{"pageContent":"3.2 Attribute-Driven Design 3.0                44\n3.2.1 Step 1: Review Inputs        44\n3.2.2\n  Step 2: Establish the Iteration Goal by Selecting \nDrivers\n        46\n3.2.3\n  Step 3: Choose One or More Elements of the System \nto Refine\n        46\n3.2.4\n  Step 4: Choose One or More Design Concepts That \nSatisfy the Selected Drivers\n        47\n3.2.5\n  Step 5: Instantiate Architectural Elements, Allocate \nResponsibilities, and Define Interfaces\n        47\n3.2.6\n  Step 6: Sketch Views and Record Design \nDecisions\n        48\n3.2.7\n  Step 7: Perform Analysis of Current Design and \nReview Iteration Goal and Achievement of Design \nPurpose\n        48\n3.2.8\n Iterate If Necessary        49\n3.3 Following a Design Roadmap According  \nto System Type                49\n3.3.1  Design of Greenfield Systems for Mature \nDomains\n        50\n3.3.2\n Design of Greenfield Systems for Novel Domains        52\n3.3.3\n Design for an Existing System (Brownfield)        53\n3.4 Identifying and Selecting Design Concepts                53","metadata":{"id":111}}],["e5da73cc-1344-468c-8045-a138d87efede",{"pageContent":"Domains\n        50\n3.3.2\n Design of Greenfield Systems for Novel Domains        52\n3.3.3\n Design for an Existing System (Brownfield)        53\n3.4 Identifying and Selecting Design Concepts                53\n3.4.1 Identification of Design Concepts        54\n3.4.2\n Selection of Design Concepts        55\n3.5 Producing Structures                58\n3.5.1 Instantiating Elements        59\n3.5.2\n  Associating Responsibilities and Identifying \nProperties\n        60\n3.5.3\n Establishing Relationships Between the Elements        61\n3.6 Defining Interfaces                61\n3.6.1 External Interfaces        61\nwww.EBooksWorld.ir\nContents vii\n3.6.2 Internal Interfaces        61\n3.7 Creating Preliminary Documentation During \nDesign                65\n3.7.1 Recording Sketches of the Views        65\n3.7.2\n Recording Design Decisions        68\n3.8 Tracking Design Progress                69\n3.8.1 Use of an Architectural Backlog        69\n3.8.2\n Use of a Design Kanban Board        70\n3.9 Summary                72\n3.10","metadata":{"id":112}}],["098e0dd0-56d3-402d-bdb1-e5dd6f358554",{"pageContent":"3.8 Tracking Design Progress                69\n3.8.1 Use of an Architectural Backlog        69\n3.8.2\n Use of a Design Kanban Board        70\n3.9 Summary                72\n3.10\n Further Reading                72\n CHAPTER 4 Case Study: FCAPS System             75\n4.1 Business Case                75\n4.2 System Requirements                77\n4.2.1 Use Case Model        77\n4.2.2\n Quality Attribute Scenarios        78\n4.2.3\n Constraints        79\n4.2.4\n Architectural Concerns        80\n4.3 The Design Process                80\n4.3.1 ADD Step 1: Review Inputs        80\n4.3.2\n  Iteration 1: Establishing an Overall System \nStructure\n        81\n4.3.3\n  Iteration 2: Identifying Structures to Support Primary \nFunctionality\n        89\n4.3.4\n  Iteration 3: Addressing Quality Attribute Scenario \nDriver (QA-3)\n        101\n4.4 Summary                105\n4.5 Further Reading                105\nCHAPTER 5  Case Study: Big Data System     107\n5.1 Business Case                107\n5.2 System Requirements                108","metadata":{"id":113}}],["51f24f8b-6e74-4d13-b226-cc96d9025931",{"pageContent":"4.4 Summary                105\n4.5 Further Reading                105\nCHAPTER 5  Case Study: Big Data System     107\n5.1 Business Case                107\n5.2 System Requirements                108\n5.2.1 Use Case Model        108\n5.2.2\n Quality Attribute Scenarios        109\n5.2.3\n Constraints        110\n5.2.4\n Architectural Concerns        110\n5.3 The Design Process                111\n5.3.1 ADD Step 1: Review Inputs        111\n5.3.2\n  Iteration 1: Reference Architecture and Overall \nSystem Structure\n        112\nwww.EBooksWorld.ir\nviii Contents \n5.3.3 Iteration 2: Selection of Technologies        120\n5.3.4\n  Iteration 3: Refinement of the Data Stream \nElement\n        131\n5.3.5\n Iteration 4: Refinement of the Serving Layer        138\n5.4 Summary                143\n5.5 Further Reading                144\n CHAPTER 6 Case Study: Banking System             145\n6.1 Business Case                145\n6.1.1 Use Case Model        147\n6.1.2\n Quality Attribute Scenarios        148\n6.1.3\n Constraints        148\n6.1.4","metadata":{"id":114}}],["e3fe157f-af46-48be-b538-6626762d0ac8",{"pageContent":"CHAPTER 6 Case Study: Banking System             145\n6.1 Business Case                145\n6.1.1 Use Case Model        147\n6.1.2\n Quality Attribute Scenarios        148\n6.1.3\n Constraints        148\n6.1.4\n Architectural Concerns        148\n6.2 Existing Architectural Documentation                149\n6.2.1 Module View        149\n6.2.2\n Allocation View        150\n6.3 The Design Process                151\n6.3.1 ADD Step 1: Review Inputs        152\n6.3.2\n Iteration 1: Supporting the New Drivers        152\n6.4 Summary                158\n6.5 Further Reading                159\n CHAPTER 7 Other Design Methods     161\n7.1 A General Model of Software Architecture \nDesign                161\n7.2 Architecture-Centric Design Method                164\n7.3 Architecture Activities in the Rational Unified \nProcess        165\n7.4 The Process of Software Architecting                167\n7.5 A Technique for Architecture and Design        169\n7.6 Viewpoints and Perspectives Method                171\n7.7 Summary                173","metadata":{"id":115}}],["b1a8d1b3-cce1-43cc-886a-59f7b315f9a1",{"pageContent":"7.4 The Process of Software Architecting                167\n7.5 A Technique for Architecture and Design        169\n7.6 Viewpoints and Perspectives Method                171\n7.7 Summary                173\n7.8 Further Reading                174\n CHAPTER 8 Analysis in the Design Process     175\n8.1 Analysis and Design                175\n8.2 Why Analyze?                178\n8.3 Analysis Techniques                179\nwww.EBooksWorld.ir\nContents ix\n8.4 Tactics-Based Analysis                180\n8.5 Reflective Questions                186\n8.6 Scenario-Based Design Reviews                187\n8.7 Architecture Description Languages                190\n8.8 Summary                191\n8.9 Further Reading                192\n CHAPTER 9     The Architecture Design Process in the \nOrganization        193\n9.1 Architecture Design and the Development Life \nCycle                193\n9.1.1  Architecture Design During  \nPre-Sales\n        194\n9.1.2\n  Architecture Design During Development and \nOperation\n        197","metadata":{"id":116}}],["ea6695b7-8f4b-499b-bd0c-44de655213df",{"pageContent":"9.1 Architecture Design and the Development Life \nCycle                193\n9.1.1  Architecture Design During  \nPre-Sales\n        194\n9.1.2\n  Architecture Design During Development and \nOperation\n        197\n9.2 Organizational Aspects                202\n9.2.1 Designing as an Individual or as a Team        202\n9.2.2\n  Using a Design Concepts Catalog in  \nYour Organization\n        203\n9.3 Summary                204\n9.4 Further Reading                204\n    CHAPTER    10    Final    Words        207\n10.1 On the Need for Methods                207\n10.2 Next Steps                209\n10.3 Further Reading                210\nAPPENDIX A A Design Concepts Catalog     211\nA.1 Reference Architectures                211\nA.1.1 Web Applications        212\nA.1.2\n Rich Client Applications        214\nA.1.3\n Rich Internet Applications        215\nA.1.4\n Mobile Applications        218\nA.1.5\n Service Applications        218\nA.2 Deployment Patterns                221\nA.2.1 Nondistributed Deployment        221\nA.2.2","metadata":{"id":117}}],["8ed87ad0-230f-4590-af27-079f48634883",{"pageContent":"Rich Internet Applications        215\nA.1.4\n Mobile Applications        218\nA.1.5\n Service Applications        218\nA.2 Deployment Patterns                221\nA.2.1 Nondistributed Deployment        221\nA.2.2\n Distributed Deployment        222\nA.2.3\n  Performance Patterns: Load-Balanced \nCluster\n        223\nwww.EBooksWorld.ir\nx Contents x Contents \nA.3 Architectural Design Patterns                224\nA.3.1 Structural Patterns        224\nA.3.2\n Interface Partitioning        226\nA.3.3\n Concurrency        228\nA.3.4\n Database Access        229\nA.4 Tactics                230\nA.4.1 Availability Tactics        230\nA.4.2\n Interoperability Tactics        232\nA.4.3\n Modifiability Tactics        233\nA.4.4\n Performance Tactics        235\nA.4.5\n Security Tactics        236\nA.4.6\n Testability Tactics        238\nA.4.7\n Usability Tactics        240\nA.5 Externally Developed Components                241\nA.5.1 Spring Framework        241\nA.5.2\n Swing Framework        243\nA.5.3\n Hibernate Framework        244\nA.5.4","metadata":{"id":118}}],["bf8a6621-15bb-45ed-bc59-2fbfa5e5850f",{"pageContent":"A.4.7\n Usability Tactics        240\nA.5 Externally Developed Components                241\nA.5.1 Spring Framework        241\nA.5.2\n Swing Framework        243\nA.5.3\n Hibernate Framework        244\nA.5.4\n Java Web Start Framework        245\nA.6 Summary                245\nA.7 Further Reading                246\nAPPENDIX B Tactics-Based Questionnaires     247\nB.1 Using the Questionnaires                247\nB.2 Availability                248\nB.3 Interoperability                252\nB.4 Modifiability                253\nB.5 Performance                255\nB.6 Security                257\nB.7 Testability                260\nB.8 Usability                261\nB.9 DevOps                263\nB.10 Further Reading                267\nGlossary        269\nAbout the Authors     275\nIndex        277\nwww.EBooksWorld.ir\nI dedicate this book to my parents, Ilse and Humberto; to my wife, Gabriela; \nand to my sons, Julian and Alexis. Thank you for all your love, support, and \ninspiration. \nH. C.","metadata":{"id":119}}],["f6508e8f-a946-4494-a693-a52329a7338e",{"pageContent":"www.EBooksWorld.ir\nI dedicate this book to my parents, Ilse and Humberto; to my wife, Gabriela; \nand to my sons, Julian and Alexis. Thank you for all your love, support, and \ninspiration. \nH. C.\nI dedicate this book to my wife, for her loving support, and to my Grandmasters, \nHee Il Cho and Philip Ameris, for the examples that they set, leading me to \nalways strive to be my best.\nR. K.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\nxiii\nPreface\nWhen asked about software architecture, people think frequently about models—\nthat is, the representations of the structures that constitute the architecture. Less \nfrequently,  people  think  about  the  thought  processes  that  produce  these  struc-\ntures—that is, the process of design. Design is a complex activity to perform and \na complex topic to write about, as it involves making a myriad of decisions that \ntake  into  account  many  aspects  of  a  system.  These  aspects  are  oftentimes  hard","metadata":{"id":120}}],["fdfcf90d-cab2-475e-8c11-1f5b7a6a13c0",{"pageContent":"a complex topic to write about, as it involves making a myriad of decisions that \ntake  into  account  many  aspects  of  a  system.  These  aspects  are  oftentimes  hard  \nto express, particularly when they originate from experience and knowledge that \nis  hard-earned  in  the  “battlefield”  of  previous  software  development  projects.  \nNevertheless,  the  activity  of  design  is  the  basis  of  software  architecture  and,  as  \nsuch, it begs to be explained. Although experience can hardly be communicated \nthrough  a  book,  what  can  be  shared  is  a  method  that  can  help  you  perform  the  \nprocess of design in a systematic way.\nThis  book  is  about  that  design  process  and  about  one  particular  design  \nmethod, called Attribute-Driven Design (ADD). We believe that this method is a \npowerful tool that will help you perform design in a principled, disciplined, and \nrepeatable  way.  In  this  book,  employing  ADD  and  several  examples  of  ADD’s","metadata":{"id":121}}],["87056d57-06e4-4aa5-b2f9-8a4b88c35b90",{"pageContent":"powerful tool that will help you perform design in a principled, disciplined, and \nrepeatable  way.  In  this  book,  employing  ADD  and  several  examples  of  ADD’s  \nuse  in  the  real  world,  we  show  you  how  to  perform  architectural  design.  Even  \nthough you may not currently possess sufficient design experience, we illustrate \nhow the method promotes reusing design concepts—that is, proven solutions that \nembody the experience of others.\nAlthough ADD has existed for more than a decade, relatively little has been \nwritten  about  it  and  few  examples  have  been  provided  to  explain  how  it  is  per-\nformed.  This  lack  of  published  information  has  made  it  difficult  for  people  to  \nadopt  the  method  or  to  teach  others  about  it.  Furthermore,  the  documentation  \nthat has been published about ADD is somewhat “high level” and can be hard to \nrelate to the concepts, practices, and technologies that architects use in their day-\nto-day activities.","metadata":{"id":122}}],["78a9cf55-5306-43d0-a479-d52c03d38d5f",{"pageContent":"that has been published about ADD is somewhat “high level” and can be hard to \nrelate to the concepts, practices, and technologies that architects use in their day-\nto-day activities. \nWe have been working with practicing architects for several years, coaching \nthem on how to perform design, and learning in the process. We have learned, for \nexample,  that  practicing  architects  take  technologies  into  consideration  early  in  \nthe design process and this is something that was not part of the original version \nof  ADD.  For  this  reason,  the  method  felt  “disconnected”  from  reality  for  many  \nwww.EBooksWorld.ir\nxiv Preface \npractitioners.  In  this  book,  we  provide  a  revised  version  of  ADD  in  which  we  \nhave tried to bridge the gap between theory and practice.\nWe  have  also  been  teaching  software  architecture  and  software  design  for  \nmany years. Along the way, we realized how hard it is for people without any ex-","metadata":{"id":123}}],["36254722-e96d-4f7f-aaba-4da63dd5d4a4",{"pageContent":"We  have  also  been  teaching  software  architecture  and  software  design  for  \nmany years. Along the way, we realized how hard it is for people without any ex-\nperience to perform design. This understanding motivated us to create a roadmap \nfor  design  that,  we  believe,  is  helpful  in  guiding  people  to  perform  the  design  \nprocess. We also created a game that is useful in teaching about software design; \nit can be considered a companion to this book.\nThe target audience for this book is anyone interested in the design of soft-\nware architectures. We believe it will be particularly useful for practitioners who \nmust  perform  this  task  but  who  currently  perform  it  in  an  ad  hoc  way.  Experi-\nenced practitioners who already perform design following an established method \nwill also find new ideas—for example, how to track design progress using a Kan-\nban board, how to analyze a design using tactics-based questionnaires, and how","metadata":{"id":124}}],["e393e06a-a86f-4aef-a707-148927063592",{"pageContent":"will also find new ideas—for example, how to track design progress using a Kan-\nban board, how to analyze a design using tactics-based questionnaires, and how \nto incorporate a design method for early estimation. Finally, people who are al-\nready familiar with the other architecture methods from the Software Engineer-\ning  Institute  will  find  information  about  the  ways  to  connect  ADD  to  methods  \nsuch as the Quality Attribute Workshop (QAW), the Architecture Tradeoff Analy-\nsis Method (ATAM), and the Cost Benefit Analysis Method (CBAM). This book \nwill also be useful to students and teachers of computer science or software engi-\nneering programs. We believe that the case studies included here will help them \nunderstand  how  to  perform  the  design  process  more  easily.  Certainly,  we  have  \nbeen using similar examples in our courses with great success. As Albert Einstein \nsaid, “Example isn’t another way to teach; it is the only way to teach.”","metadata":{"id":125}}],["53238bd3-4da3-4746-bb30-5f91af3c11b7",{"pageContent":"been using similar examples in our courses with great success. As Albert Einstein \nsaid, “Example isn’t another way to teach; it is the only way to teach.”\nOur hope is that this book will help you in understanding that design can be \nperformed  following  a  method,  and  that  this  realization  will  help  you  produce  \nbetter software systems in the future.\nThe book is structured as follows. \n ■\nIn Chapter 1, we briefly introduce software architecture and the Attribute- \nDriven Design method. \n ■\nIn Chapter 2, we discuss architecture design in more detail, along with the \nmain inputs to the design process—what we call architectural drivers, plus \nthe design concepts that will help you satisfy these drivers using proven \nsolutions. \n ■\nChapter 3 presents the ADD method in detail. We discuss each of the steps \nof the method along with various techniques that can be used to perform \nthese steps appropriately. \n ■\nChapter 4 is our first case study, which illustrates the development of a","metadata":{"id":126}}],["534c5060-3750-4ddb-8f0c-53bb492b642e",{"pageContent":"of the method along with various techniques that can be used to perform \nthese steps appropriately. \n ■\nChapter 4 is our first case study, which illustrates the development of a \ngreenfield system. For this case study, we have made an effort to show how \na majority of the concepts described in Chapter 3 are used in the design \nprocess, so you can think of this case study as being more “academic” in \nnature (although it is derived from a real-world system). \n ■\nChapter 5 presents our second case study, which was co-written with prac-\nticing software architects and as such is much more technical and detailed \nwww.EBooksWorld.ir\nPreface xv\nin nature. It will show you the nitty-gritty details of how ADD is used in the \ndesign of a Big Data system that involves many different technologies. This \nexample illustrates the development of a system in what we consider to be a \n“novel” domain, as opposed to the more traditional domain used in Chapter 4. \n ■","metadata":{"id":127}}],["322d5b00-6dff-4410-8d4e-59ca648aa210",{"pageContent":"example illustrates the development of a system in what we consider to be a \n“novel” domain, as opposed to the more traditional domain used in Chapter 4. \n ■\nChapter 6 is a shorter case study that illustrates the use of ADD in the \ndesign of an extension of a legacy (or brownfield) system, which is a com-\nmon situation. This example demonstrates that architectural design is not \nsomething that is performed only once, when the first version of the system \nis developed, but rather is an activity that can be performed at different mo-\nments of the development process. \n ■\nChapter 7 presents other design methods. In our revision of ADD, we \nadopted ideas from other authors who have also investigated the process of \ndesign, and here we briefly summarize their approaches both as an homage \nto their work and as a means to compare ADD to these methods. \n ■\nChapter 8 discusses the topic of analysis in depth, even though this is a book","metadata":{"id":128}}],["3f93b802-5655-4cbb-bf0e-45ab290c4f92",{"pageContent":"to their work and as a means to compare ADD to these methods. \n ■\nChapter 8 discusses the topic of analysis in depth, even though this is a book \non design. Analysis is naturally performed as part of design, so here we de-\nscribe techniques that can be used both during the design process or after \na portion of the design has been completed. In particular, we introduce the \nuse of tactics-based questionnaires, which are helpful in understanding, in a \ntime-efficient and simple manner, the decisions made in the design process. \n ■\nChapter 9 describes how the design process fits at an organizational level. \nFor instance, performing some amount of architectural design at the earli-\nest moments of the project’s life is useful for estimation purposes. We also \nshow how ADD can be associated with different software development \napproaches. \n ■\nChapter 10 concludes the book. \nWe  also  include  two  appendixes.  Appendix  A  presents A Design  Concepts","metadata":{"id":129}}],["dea552bf-9dda-406e-a879-ab16a3b52f0f",{"pageContent":"show how ADD can be associated with different software development \napproaches. \n ■\nChapter 10 concludes the book. \nWe  also  include  two  appendixes.  Appendix  A  presents A Design  Concepts  \nCatalog,  which,  as  its  name  suggests,  is  a  catalog  of  different  types  of  design  \nconcepts that can be used to design for a particular application domain. This cat-\nalog includes design concepts that we have gathered from different sources, re-\nflecting how experienced and disciplined architects work in the real world. In this \ncase, our catalog contains a sample of the design concepts used in the case study \npresented in Chapter 4. Appendix B provides a set of tactics-based questionnaires \n(as introduced in Chapter 8) for the seven most common quality attributes and an \nadditional questionnaire for DevOps.\nRegister  your  copy  of  Designing  Software  Architectures  at  informit.com  for  \nconvenient  access  to  downloads,  updates,  and  corrections  as  they  become","metadata":{"id":130}}],["5ea6a9fe-3cf0-4a9a-bb8d-e8b2203bd7a0",{"pageContent":"Register  your  copy  of  Designing  Software  Architectures  at  informit.com  for  \nconvenient  access  to  downloads,  updates,  and  corrections  as  they  become  \navailable. To start the registration process, go to informit.com/register and log \nin  or  create  an  account.  Enter  the  product  ISBN  (9780134390789)  and  click  \nSubmit. Once the process is complete, you will find any available bonus con-\ntent under “Registered Products.”\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\nxvii\nAcknowledgments\nThe   authors   wish   to   acknowledge   our   reviewers—Marty   Barrett,   Roger   \nChampagne, Siva Muthu, Robert Nord, Vishal Prabhu, Andriy Shapochka, David \nSisk,  Perla  Velasco-Elizondo,  and  Olaf  Zimmermann—for  their  generosity  in  \nproviding  both  opinions  and  comments.  We  also  wish  to  thank  Serge  Haziyev  \nand Olha Hrytsay for their contributions to Chapter 5. In addition, we would be","metadata":{"id":131}}],["6e88f9ab-62c0-4c70-b747-6ddfea503ea8",{"pageContent":"providing  both  opinions  and  comments.  We  also  wish  to  thank  Serge  Haziyev  \nand Olha Hrytsay for their contributions to Chapter 5. In addition, we would be \nremiss  if  we  did  not  thank  the  many  architects  at  Softserve—Serge,  Olha,  and  \nAndriy included—for their overall strong support of our work.\nHumberto wishes to thank the directors and the group of architects at Quark-\nsoft; many ideas for the revision of ADD and one of the case studies presented in \nthis book originated from putting the method into practice at this company. Thank \nyou to the architects and developers in other companies with whom I have had the \nopportunity to collaborate and exchange ideas—I have learned a lot from them. I \nalso wish to thank the people at the Software Engineering Institute, who have wel-\ncomed me and other academics for many years at the ACE Educators Workshop. I \nalso want to give recognition to my university, Universidad Autónoma Metropoli-","metadata":{"id":132}}],["06a61680-e268-46a9-be6d-584e759c9e01",{"pageContent":"comed me and other academics for many years at the ACE Educators Workshop. I \nalso want to give recognition to my university, Universidad Autónoma Metropoli-\ntana Iztapalapa, as it has always supported my work. Thanks to my colleagues Perla \nVelasco-Elizondo and Luis Castro, who have accompanied me for several years in \nthis architectural journey. Thank you to Alonso Leal, who gave me the opportunity \nto become a practicing architect many years ago. Thanks to Richard S. Hall, who \ntaught  me  many  skills  that  have  proved  invaluable  in  writing  this  book.  Finally,  I  \nwish to thank my coauthor Rick, for being such a nice person and colleague; it is \nalways a pleasure to work and exchange opinions with him.\nRick wishes to thank James Ivers and his research group at the Software En-\ngineering Institute. In particular, I would like to thank Rod Nord, for his careful \nand insightful review comments and suggestions. I would also like to thank my","metadata":{"id":133}}],["fa57ae23-ec3a-4c84-9fce-be4d53e7ab32",{"pageContent":"gineering Institute. In particular, I would like to thank Rod Nord, for his careful \nand insightful review comments and suggestions. I would also like to thank my \nlong-time collaborator and mentor Len Bass, who got me started on this software \narchitecture journey many years ago. Without Len, who knows where I would be \ntoday.  In  addition,  I  would  like  to  thank  Linda  Northrop,  who  vigorously  sup-\nported my research for many years and provided many wonderful “opportunities \nto excel.” Finally, I would like to thank my coauthor Humberto, who has always \nbeen energetic, positive, and a true pleasure to work with.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n1\n1\nIntroduction\nIn  this  chapter  we  provide  an  introduction  to  the  topic  of  software  architecture.  \nWe briefly discuss what architecture is and why it is fundamental to take it into \naccount when developing software systems. We also discuss the different activi-","metadata":{"id":134}}],["6491d086-fd51-4580-a4b7-f17229b82961",{"pageContent":"We briefly discuss what architecture is and why it is fundamental to take it into \naccount when developing software systems. We also discuss the different activi-\nties that are associated with the development of software architecture so that ar-\nchitectural design—which is the primary topic of this book—can be understood \nin the context of these activities. We also briefly discuss the role of the architect, \nwho  is  the  person  responsible  for  creating  the  design.  Finally,  we  introduce  the  \nAttribute-Driven Design (ADD) method, the architecture design method that we \nwill discuss extensively in this book.\n1.1    Motivations\nOur  goal  in  this  book  is  to  teach  you  how  to  design  software  architecture  in  a  \nsystematic, predictable, repeatable, and cost-effective way. If you are reading this \nbook, then presumably you already have an interest in architecture and aspire to \nbe an architect. The good news is that this goal is within your grasp. To convince","metadata":{"id":135}}],["14934090-31fa-4547-a20c-08ea139c44f4",{"pageContent":"book, then presumably you already have an interest in architecture and aspire to \nbe an architect. The good news is that this goal is within your grasp. To convince \nyou  of  that  point,  we  will  spend  a  few  moments  talking  about  the  idea  of  de-\nsign—the design of anything—and we will see how and why architectural design \nis not so different. In most fields, “design” involves the same sorts of challenges \nand considerations—meeting stakeholder needs, adhering to budgets and sched-\nules, dealing with constraints, and so forth. While the primitives and tools of de-\nsign may vary from field to field, the goals and steps of design do not.\nwww.EBooksWorld.ir\n2 Chapter 1—Introduction\nThis is encouraging news, because it means that design is not the sole prov-\nince of wizards. That is, design can be taught, and it can be learned. Most design, \nparticularly in engineering, consists of putting known design primitives together","metadata":{"id":136}}],["3d3b4fe1-49f3-4ebf-b9d2-1f3227e9f4bf",{"pageContent":"ince of wizards. That is, design can be taught, and it can be learned. Most design, \nparticularly in engineering, consists of putting known design primitives together \nin (sometimes innovative) ways that achieve predictable outcomes. Of course, the \ndevil is in the details, but that is why we have methods. It may seem difficult at \nfirst to imagine that a creative endeavor such as design can be captured in a step-\nby-step  method;  this,  however,  is  not  only  possible  but  also  valuable,  as  Parnas  \nand  Clements  have  discussed  in  their  paper  “A  Rational  Design  Process:  How  \nand Why to Fake It”. Of course, not everyone can be a great designer, just as not \neveryone can be a Thomas Edison or a LeBron James or a Ronaldo. What we do \nclaim is that everyone can be a much better designer, and that structured methods \nsupported  by  reusable  chunks  of  design  knowledge,  which  we  provide  in  this  \nbook, can help pave the road from mediocrity to excellence.","metadata":{"id":137}}],["f35e3f34-eb31-4945-8fee-3f52f499544a",{"pageContent":"supported  by  reusable  chunks  of  design  knowledge,  which  we  provide  in  this  \nbook, can help pave the road from mediocrity to excellence.\nWhy  are  we  writing  a  book  on  software  architecture  design?  While  much  \nhas been written about design in general, and while there have been some writ-\nings  on  software  architecture  design,  there  is  no  existing  book  dedicated  solely  \nto architecture design. Moreover, most of what has been written on architecture \ndesign is relatively abstract.\nOur goal in writing this book was to provide a practical method that can be \nenacted  by  any  competent  software  engineer,  and  also  (and  just  as  important)  \nto provide a set of rich case studies that realize the method. Albert Einstein was \nreputed to have said, “Example isn’t another way to teach, it is the only way to \nteach”. We firmly believe that. Most of us learn better from examples than from","metadata":{"id":138}}],["69230eac-0f47-45ca-b275-2b5633896740",{"pageContent":"reputed to have said, “Example isn’t another way to teach, it is the only way to \nteach”. We firmly believe that. Most of us learn better from examples than from \nsets  of  rules  or  steps  or  principles.  Of  course,  we  need  the  steps  and  rules  and  \nprinciples to structure what we do and to create the examples, but the examples \nspeak to our day-to-day concerns and help us by making the steps concrete.\nThis  is  not  to  say  that  architecture  design  will  ever  be  simple.  If  you  are  \nbuilding a complex system, then chances are that you are trying to balance many \ncompeting  forces—things  like  time  to  market,  cost,  performance,  evolvability,  \nusability, availability, and so on. If you are pushing the boundaries in any of these \ndimensions, then your job as an architect will be even more complex. This is true \nin  any  engineering  discipline,  not  just  software.  If  you  examine  the  history  of","metadata":{"id":139}}],["e71d680c-8b00-431e-b582-ba2824f22a92",{"pageContent":"dimensions, then your job as an architect will be even more complex. This is true \nin  any  engineering  discipline,  not  just  software.  If  you  examine  the  history  of  \nbuilding large ships or skyscrapers or any other complex “system”, you will see \nhow the architects of those systems struggled with making the appropriate deci-\nsions and tradeoffs. No, architecture design may never be easy, but our purpose \nis  to  make  it  tractable  and  achievable  by  well-trained,  well-educated  software  \nengineers.\nwww.EBooksWorld.ir\n1.2 Software Architecture 3\n1.2 Software Architecture\nMuch has been written on what software architecture is. We adopt the definition \nof software architecture from Software Architecture in Practice (third edition):\nThe  software  architecture  of  a  system  is  the  set  of  structures  needed  to  \nreason  about  the  system,  which  comprise  software  elements,  relations  \namong them, and properties of both.","metadata":{"id":140}}],["e12a77c5-fc7e-47bc-bc63-5b1b9d7d8cdb",{"pageContent":"The  software  architecture  of  a  system  is  the  set  of  structures  needed  to  \nreason  about  the  system,  which  comprise  software  elements,  relations  \namong them, and properties of both.\nAs  you  will  see,  our  design  method  embodies  this  definition  and  helps  to  \nguide the designer in creating an architecture that has the desired properties.\n1.2.1 The Importance of Software Architecture\nMuch  has  also  been  written  on  why  architecture  is  important.  Again,  following  \nSoftware  Architecture  in  Practice,  we  note  that  architecture  is  important  for  a  \nwide variety of reasons, and a similarly wide variety of consequences stem from \nthose reasons:\n§\tAn architecture will inhibit or enable a system’s driving quality attributes.\n§\tThe decisions made in an architecture allow you to reason about and man-\nage change as the system evolves.\n§\tThe analysis of an architecture enables early prediction of a system’s \nqualities.","metadata":{"id":141}}],["602a6c4e-29e2-483b-aaef-8a9a68d6e219",{"pageContent":"§\tThe decisions made in an architecture allow you to reason about and man-\nage change as the system evolves.\n§\tThe analysis of an architecture enables early prediction of a system’s \nqualities.\n§\tA documented architecture enhances communication among stakeholders.\n§\tThe architecture is a carrier of the earliest and hence most fundamental, \nhardest-to-change design decisions.\n§\tAn architecture defines a set of constraints on subsequent implementation.\n§\tThe architecture influences the structure of an organization, and vice versa.\n§\tAn architecture can provide the basis for evolutionary, or even throwaway, \nprototyping.\n§\tAn architecture is the key artifact that allows the architect and the project \nmanager to reason about cost and schedule.\n§\tAn architecture can be created as a transferable, reusable model that forms \nthe heart of a product line.\n§\tArchitecture-based development focuses attention on the assembly of com-\nponents, rather than simply on their creation.","metadata":{"id":142}}],["ad75807e-e154-4a44-91c2-84a4a5b3faec",{"pageContent":"the heart of a product line.\n§\tArchitecture-based development focuses attention on the assembly of com-\nponents, rather than simply on their creation.\n§\tBy restricting design alternatives, architecture channels the creativity of \ndevelopers, reducing design and system complexity.\n§\tAn architecture can be the foundation for training a new team member.\nIf an architecture is important for all of these reasons—if it affects the struc-\nture of the organization, and the qualities of the system, and the people involved \nin its creation and evolution—then surely great care must be taken in designing \nwww.EBooksWorld.ir\n4 Chapter 1—Introduction\nthis  crucial  artifact.  Sadly,  that  is  most  often  not  the  case.  Architectures  often  \n“evolve”  or  “emerge”.  While  we  have  nothing  against  evolution  or  emergence,  \nand  while  we  emphatically  are  not  arguing  for  “big  design  up  front”,  doing  no  \narchitecture at all is often too risky for anything but the simplest projects. Would","metadata":{"id":143}}],["2e3874af-7ee3-4656-8691-58f24ba75374",{"pageContent":"and  while  we  emphatically  are  not  arguing  for  “big  design  up  front”,  doing  no  \narchitecture at all is often too risky for anything but the simplest projects. Would \nyou  want  to  drive  over  a  bridge  or  ride  in  a  jet  that  had  not  been  carefully  de-\nsigned? Of course not. But you use software every day that is buggy, costly, inse-\ncure, unreliable, fault prone, and slow—and many of these undesirable character-\nistics can be avoided!\nThe core message of this book is that architecture design does not need to be \ndifficult or scary; it is not the sole province of wizards; and it does not have to be \ncostly and all done up front. Our job is to show you how and convince you that it \nis within your reach.\n1.2.2 Life-Cycle Activities\nSoftware architecture design is one of the software architecture life-cycle activi-\nties (Figure 1.1). As in any software project life cycle, this activity is concerned","metadata":{"id":144}}],["c59ee64a-edcc-49ab-9913-29d6b717ebe4",{"pageContent":"1.2.2 Life-Cycle Activities\nSoftware architecture design is one of the software architecture life-cycle activi-\nties (Figure 1.1). As in any software project life cycle, this activity is concerned \nwith the translation of requirements into a design into an implementation. Specif-\nically, the architect needs to worry about the following issues:\n§\tArchitectural requirements. Among all the requirements, a few will have \na particular importance with respect to the software architecture. These \narchitecturally significant requirements (ASRs) include not only the most \nimportant functionality of the system and the constraints that need to be \ntaken into account, but also—and most importantly—quality attributes \nsuch as high performance, high availability, ease of evolution, and iron-clad \nsecurity. These requirements, along with a clear design purpose and other \narchitectural concerns that may never be written down or may be invisible","metadata":{"id":145}}],["27c7bdc9-aae5-4535-bf23-f37bb4f7e4ef",{"pageContent":"security. These requirements, along with a clear design purpose and other \narchitectural concerns that may never be written down or may be invisible \nto external stakeholders, will guide you to choose one set of architectural \nstructures and components over another. We will refer to these ASRs and \nconcerns as drivers, as they can be said to drive the design.\n§\tArchitectural design. Design is a translation, from the world of needs (re-\nquirements) to the world of solutions, in terms of structures composed of \ncode, frameworks, and components. A good design is one that satisfies the \ndrivers. Architectural design is the focus of this book.\nwww.EBooksWorld.ir\n1.2 Software Architecture 5\nArchitectural\nRequirements\nArchitectural\nDesign\nArchitectural\nDocumentation\nArchitectural\nEvaluation\n<<precedes>>\n<<precedes>>\n<<precedes>>\n<<precedes>>\n<<precedes>>\n<<influences>>\nArchitectural\nImplementation\nFocus of the\nbook\nFIGURE 1.1 Software architecture life-cycle activities","metadata":{"id":146}}],["3f523c26-137f-4ed8-9806-31cd926b1c86",{"pageContent":"Architectural\nEvaluation\n<<precedes>>\n<<precedes>>\n<<precedes>>\n<<precedes>>\n<<precedes>>\n<<influences>>\nArchitectural\nImplementation\nFocus of the\nbook\nFIGURE 1.1 Software architecture life-cycle activities\n§\tArchitectural documentation. Some level of preliminary documentation (or \nsketches) of the structures should be created as part of architectural design. \nThis activity, however, refers to the creation of a more formal document \nfrom these sketches. If the project is small and has a precedent, then archi-\ntecture documentation may be minimal. In contrast, if the project is large, \nif distributed teams are collaborating, or if significant technical challenges \nexist, then architectural documentation will repay the effort invested in this \nactivity. While documentation is often avoided and derided by program-\nmers, it is a standard, non-negotiable deliverable in almost every other engi-\nneering discipline. If your system is big enough and if it is mission critical,","metadata":{"id":147}}],["101c1fbd-5787-4bfa-a084-5592520567fe",{"pageContent":"mers, it is a standard, non-negotiable deliverable in almost every other engi-\nneering discipline. If your system is big enough and if it is mission critical, \nit should be documented. In other engineering disciplines, a “blueprint”—\nsome sort of documented design—is an absolutely essential step in moving \ntoward implementation and the commitment of resources.\nwww.EBooksWorld.ir\n6 Chapter 1—Introduction\n§\tArchitectural evaluation. As with documentation, if your project is non-\ntrivial, then you owe it to yourself and to your stakeholders to evaluate \nit—that is, to ensure that the decisions made are appropriate to address the \ncritical requirements. Would you deliver code without testing it? Of course \nnot. Similarly, why would you commit enormous resources to fleshing out \nan architecture if you had not first “tested” the design? You might want to \ndo this when first creating the system or when putting it through a major","metadata":{"id":148}}],["fa4f5bb5-ac4c-4dc8-ab49-edfd57a7a182",{"pageContent":"an architecture if you had not first “tested” the design? You might want to \ndo this when first creating the system or when putting it through a major \nrefactoring. Typically evaluation is done informally and internally, but for \ntruly important projects it is advisable to have a formal evaluation done by \nan external team.\n§\tArchitectural implementation/conformance checking. Finally, you need \nto implement the architecture that you have created (and evaluated). As \nan architect, you may need to tweak the design as the system grows and \nas requirements evolve. This is normal. In addition to this tweaking, your \nmajor responsibility during implementation is to ensure conformance of \nthe code to the design. If developers are not faithfully implementing the \narchitecture, they may be undermining the qualities that you have designed \nin. Again, consider what is done in other fields of engineering. When a \nconcrete foundation for a new building is poured, the building that rests on","metadata":{"id":149}}],["185f7510-82ae-4079-9d29-e9a7f90d7693",{"pageContent":"in. Again, consider what is done in other fields of engineering. When a \nconcrete foundation for a new building is poured, the building that rests on \ntop of that foundation is not constructed until the foundation has first been \ntested, typically via a core sample, to ensure that it is strong enough, dense \nenough, sufficiently impermeable to water and gases, and so forth. Without \nconformance checking, we have no way of ensuring the quality of what is \nbeing subsequently constructed.\nNote  that  we  are  not  proposing  a  specific  life-cycle  methodology  in  \nFigure  1.1.  The  stereotype  <<precedes>>  simply  means  that  some  effort  in  an  \nactivity must be performed, and hence precede, effort in a later activity. For ex-\nample,  you  cannot  perform  design  activities  if  you  have  no  idea  about  the  re-\nquirements,  and  you  cannot  evaluate  an  architecture  if  you  have  not  first  made  \nsome design decisions.","metadata":{"id":150}}],["3a477ffe-67f2-4f37-9f12-961841b752f6",{"pageContent":"quirements,  and  you  cannot  evaluate  an  architecture  if  you  have  not  first  made  \nsome design decisions.\nToday  most  commercial  software  is  developed  using  some  form  of  Agile  \nmethodology. None of these architecture activities is incompatible with Agile prac-\ntices.  The  question  for  a  software  architect  is  not  “Should  I  do  Agile  or  architec-\nture?”, but rather “How much architecture should I do up front versus how much \nshould  I  defer  until  the  project’s  requirements  have  solidified  somewhat?”  and  \n“How much of the architecture should I formally document, and when?” Agile and \narchitecture are happy companions for many software projects.\nWe will discuss the relationship between architecture design and various soft-\nware  life-cycle  methods  and  process  models,  including  iterative  development,  in  \nChapter 9.\nwww.EBooksWorld.ir\n1.3 The Role of the Architect 7\n1.3 The Role of the Architect","metadata":{"id":151}}],["d964677c-a9b7-47c0-9699-3b39983db072",{"pageContent":"ware  life-cycle  methods  and  process  models,  including  iterative  development,  in  \nChapter 9.\nwww.EBooksWorld.ir\n1.3 The Role of the Architect 7\n1.3 The Role of the Architect\nAn architect is much more than “just” a designer. This role, which may be played \nby  one  or  more  individuals,  has  a  long  list  of  duties,  skills,  and  knowledge  \nthat  must  be  satisfied  if  it  is  to  be  successful.  These  prerequisites  include  the  \nfollowing:\n§\tLeadership: mentoring, team-building, establishing a vision, coaching\n§\tCommunication: both technical and nontechnical, encouraging \ncollaboration\n§\tNegotiation: dealing with internal and external stakeholders and their con-\nflicting needs and expectations\n§\tTechnical skills: life-cycle skills, expertise with technologies, continuous \nlearning, coding\n§\tProject skills: budgeting, personnel, schedule management, risk \nmanagement\n§\tAnalytical skills: architectural analysis, general analysis mindset for project","metadata":{"id":152}}],["7e0fd078-e768-4999-99d4-e23acdcf2f01",{"pageContent":"learning, coding\n§\tProject skills: budgeting, personnel, schedule management, risk \nmanagement\n§\tAnalytical skills: architectural analysis, general analysis mindset for project \nmanagement and measurement (see the sidebar “The Meaning of Analysis”)\nA successful design is not a static document that is “thrown over the wall”. \nThat is, architects must not only design well, but must also be intimately involved \nin  every  aspect  of  the  project,  from  conception  and  business  justification  to  de-\nsign and creation, through to operation, maintenance, and eventually retirement.\nThe Meaning of Analysis\nIn the Merriam-Webster Dictionary, the word analysis is defined as follows:\n§\tThe careful study of something to learn about its parts, what they do, and \nhow they are related to each other\n§\tAn explanation of the nature and meaning of something\nIn this book we use the word analysis for different purposes, and both \nof these definitions apply. For instance, as part of the architectural evalu-","metadata":{"id":153}}],["34c7f6b2-0b18-470c-aa6a-1a6231b55a53",{"pageContent":"In this book we use the word analysis for different purposes, and both \nof these definitions apply. For instance, as part of the architectural evalu-\nation activity, an existing architecture is analyzed to gauge if it is appropri-\nate to satisfy its associated drivers. During the design process, the inputs \nare analyzed to make design decisions. The creation of prototypes is also \na form of analysis. In fact, analysis is so important to the design process \nthat we devote Chapter 8 to just this topic. Here we also discuss, in more \ndetail, the relationship between analysis and evaluation. In this book, we \nfocus primarily on the design activity, its associated technical skills, and \nits integration into the development life cycle. For a fuller treatment of the \nother aspects of an architect’s life, we invite you to read a more general \nbook on software architecture, such as Software Architecture in Practice or \nJust Enough Software Architecture.\nwww.EBooksWorld.ir\n8 Chapter 1—Introduction","metadata":{"id":154}}],["7a6888f7-7e74-413b-8666-bd237a4811f3",{"pageContent":"book on software architecture, such as Software Architecture in Practice or \nJust Enough Software Architecture.\nwww.EBooksWorld.ir\n8 Chapter 1—Introduction\n1.4 A Brief History of ADD\nWhile  an  architect  has  many  duties  and  responsibilities,  in  this  book  we  focus  \non what is arguably the single most important skill that a software engineer must \nmaster to be called “architect”: the process of design. To make architectural de-\nsign  more  tractable  and  repeatable,  in  this  book  we  focus  most  of  our  attention  \non  the  Attribute-Driven  Design  (ADD)  method,  which  provides  step-by-step  \nguidance on how to iteratively perform the design activity shown in Figure 1.1. \nChapter  3  describes  the  most  recent  version  of  ADD,  version  3.0,  in  detail,  so  \nhere  we  provide  a  bit  of  background  for  those  who  are  familiar  with  previous  \nversions  of  ADD.  The  first  version  of  ADD  (ADD  1.0,  originally  called  ABD,","metadata":{"id":155}}],["7630d2ec-d47a-44f4-b7dd-8cae79dd4c37",{"pageContent":"here  we  provide  a  bit  of  background  for  those  who  are  familiar  with  previous  \nversions  of  ADD.  The  first  version  of  ADD  (ADD  1.0,  originally  called  ABD,  \nfor “Architecture-Based Design”) was published in January 2000, and the second \nversion  (ADD  2.0)  was  published  in  November  2006.  The  third  edition  of  the  \nbook Software Architecture in Practice presents this method with a reduced num-\nber of steps. This discussion, however, does not introduce a new version of ADD, \nbut rather a repackaged version that summarizes the actual steps of the method.\nADD is, to our knowledge, the most comprehensive and most widely used \ndocumented  architecture  design  method.  (We  provide  an  overview  of  a  number  \nof alternative design methods in Chapter 7.) When ADD appeared, it was the first \ndesign  method  to  focus  specifically  on  quality  attributes  and  their  achievement","metadata":{"id":156}}],["96fd8986-6fd4-4fc0-9f0b-1975b38a3dcc",{"pageContent":"of alternative design methods in Chapter 7.) When ADD appeared, it was the first \ndesign  method  to  focus  specifically  on  quality  attributes  and  their  achievement  \nthrough  the  creation  of  architectural  structures  and  their  representation  through  \nviews.  Another  important  contribution  of  ADD  is  that  it  includes  architecture  \nanalysis and documentation as an integral part of the design process. In ADD, de-\nsign activities include refining the sketches created during early design iterations \nto produce a more detailed architecture, and continuously evaluating the design.\nWhile ADD 2.0 was useful for linking quality attributes to design choices, it \nhad several shortcomings that needed to be addressed:\n§\tADD 2.0 guides the architect to use and combine tactics and patterns to \nachieve the satisfaction of quality attribute scenarios. Patterns and tactics \nare abstractions, however, and the method did not explain how to map these","metadata":{"id":157}}],["a77bc144-d64b-4951-99f7-0f36a468a8f8",{"pageContent":"achieve the satisfaction of quality attribute scenarios. Patterns and tactics \nare abstractions, however, and the method did not explain how to map these \nabstractions to concrete implementation technologies.\n§\tADD 2.0 was invented before Agile methods became widely adopted and, \ntherefore, did not offer guidance for architecture design in an Agile setting.\n§\tADD 2.0 provided no guidance on how to begin the design process. While \nthis omission enhanced its generalizability, it presented difficulties for nov-\nice designers, who often do not know where to begin. Specifically, ADD 2.0 \ndid not explicitly promote the (re)use of reference architectures, which are \nan ideal starting point for many architects, as we will discuss later in this \nbook.\n§\tADD 2.0 did not explicitly consider different design purposes. For exam-\nple, one might be doing design as part of a pre-sales process or as part of \nwww.EBooksWorld.ir\n1.5    Summary    9","metadata":{"id":158}}],["35d66c0e-0425-469b-828a-49aa72bdfcbb",{"pageContent":"book.\n§\tADD 2.0 did not explicitly consider different design purposes. For exam-\nple, one might be doing design as part of a pre-sales process or as part of \nwww.EBooksWorld.ir\n1.5    Summary    9\n“standard” design for construction. These are very different purposes and \nwill result in different uses of ADD.\n§\tADD 2.0 did not consider that design requires some architectural concerns \n(i.e., internal requirements) to be addressed whether or not they are ex-\npressed in the list of “traditional” drivers (requirements and constraints). It \nis a rare user who will ask that a system be “testable” or will require that \nthe system provide special testing interfaces, but a wise architect might \nchoose to include such an infrastructure, particularly if the system is com-\nplex and used in contexts that are difficult to control and replicate.\n§\tADD 2.0 iterations are always driven by the selection and decomposition \nof architectural elements. This occurs because ADD 2.0 instructs that first","metadata":{"id":159}}],["e963bc13-9db7-4f0e-83c7-a2be226c4ff3",{"pageContent":"§\tADD 2.0 iterations are always driven by the selection and decomposition \nof architectural elements. This occurs because ADD 2.0 instructs that first \nan element to decompose must be chosen, and then the drivers must be \nidentified. In ADD 3.0, we recognize that sometimes a design step is driven \nby the critical architectural requirements, which guides the selection and \ndecomposition of elements.\n§\tADD 2.0 includes (initial) documentation and analysis, but they are not ex-\nplicit steps of the design process.\nADD 3.0 addresses all of these shortcomings. To be sure, ADD 3.0 is evo-\nlutionary, not revolutionary. It was catalyzed by the creation of ADD 2.5,\n1\n which \nwas itself a reaction to attempting to use ADD in the real world, in many different \ncontexts.\nWe published ADD 2.5 in 2013. In that work, we advocated the use of ap-\nplication frameworks such as JSF, Spring, or Hibernate as first-class design con-\ncepts. This change was intended to address ADD 2.0’s shortcoming of being too","metadata":{"id":160}}],["bde30332-a089-4705-b8ff-5078419bd7ff",{"pageContent":"plication frameworks such as JSF, Spring, or Hibernate as first-class design con-\ncepts. This change was intended to address ADD 2.0’s shortcoming of being too \nabstract to apply easily. ADD starts with drivers, systematically links them to de-\nsign decisions, and then links those decisions to the available implementation op-\ntions, including externally developed components. For Agile development, ADD \n3.0 promotes quick design iterations in which a small number of design decisions \nare  made,  potentially  followed  by  an  implementation  spike.  In  addition,  ADD  \n3.0 explicitly promotes the (re)use of reference architectures and is paired with a \n“design concepts catalog”, which includes a broad selection of tactics, patterns, \nframeworks, reference architectures, and technologies (see Appendix A).\n1.5    Summary\nHaving covered our motivations and background, we now move on to the heart \nand  soul  of  this  book.  In  the  next  few  chapters,  we  describe  what  we  mean  by","metadata":{"id":161}}],["d9372c29-3d8b-41a5-99ee-052e401463f1",{"pageContent":"1.5    Summary\nHaving covered our motivations and background, we now move on to the heart \nand  soul  of  this  book.  In  the  next  few  chapters,  we  describe  what  we  mean  by  \ndesign and by architectural design in particular, we discuss ADD, and we provide \nthree case studies showing in detail how ADD can be used in the real world. We \n1.  This is our own coding notation; the 2.5 number is not used elsewhere.\nwww.EBooksWorld.ir\n10 Chapter 1—Introduction\nalso discuss the critical role that analysis plays in the design process and provide \nexamples of how analysis can be performed on design artifacts.\n1.6 Further Reading\nFred  Brooks  has  written  a  thoughtful  series  of  essays  on  the  nature  of  design,  \nreflecting his 50 years of experience as a designer and researcher: F. P. Brooks, Jr. \nThe Design of Design: Essays from a Computer Scientist. Addison-Wesley, 2010.\nThe usefulness of having a documented process for design and other devel-","metadata":{"id":162}}],["f1319614-8514-4d89-9b3f-4a542e5edafb",{"pageContent":"The Design of Design: Essays from a Computer Scientist. Addison-Wesley, 2010.\nThe usefulness of having a documented process for design and other devel-\nopment activities is discussed in D. Parnas and P. Clements, “A Rational Design \nProcess: How and Why to Fake It”, IEEE Transactions on Software Engineering, \nSE-12, 2, February 1986.\nThe definition of software architecture used here, as well as the arguments \nfor  the  importance  of  architecture  and  the  role  of  the  architect,  all  derive  from  \nL. Bass, P. Clements, and R. Kazman, Software Architecture in Practice, 3rd ed., \nAddison-Wesley, 2012.\nSeveral books cover the different activities of the architecture development \nlife  cycle,  including  G.  Fairbanks,  Just  Enough  Software  Architecture:  A  Risk  \nDriven  Approach,  Marshall  &  Brainerd,  2010,  and  the  ones  whose  design  ap-\nproaches are described in Chapter 7.\nAn  early  reference  for  the  first  version  of  ADD  can  be  found  in  F.  Bach-","metadata":{"id":163}}],["965a2f78-7b14-4d10-b3ab-d5d7516efc73",{"pageContent":"proaches are described in Chapter 7.\nAn  early  reference  for  the  first  version  of  ADD  can  be  found  in  F.  Bach-\nmann, L. Bass, G. Chastek, P. Donohoe, and F. Peruzzi, The Architecture Based \nDesign  Method,  CMU/SEI-2000-TR-001.  The  second  version  of  ADD  was  de-\nscribed in R. Wojcik, F. Bachmann, L. Bass, P. Clements, P. Merson, R. Nord, and \nW. Wood, Attribute-Driven Design (ADD), Version 2.0, CMU/SEI-2006-TR-023. \nThe version of ADD that we have referred to here as ADD 2.5 was published in \nH. Cervantes, P. Velasco-Elizondo, and R. Kazman, “A Principled Way of Using \nFrameworks in Architectural Design”, IEEE Software, 46–53, March/April 2013.\nwww.EBooksWorld.ir\n11\n2\nArchitectural Design\nWe now dive into the process of architecture design: what it is, why it is impor-\ntant, how it works (at an abstract level). and which major concepts and activities \nit involves. We first discuss architectural drivers: the various factors that “drive”","metadata":{"id":164}}],["b6757ab7-d2fa-45a3-9f2e-349e064f6e68",{"pageContent":"tant, how it works (at an abstract level). and which major concepts and activities \nit involves. We first discuss architectural drivers: the various factors that “drive” \ndesign  decisions,  some  of  which  are  documented  as  requirements,  but  many  of  \nwhich are not. In addition, we provide an overview of design concepts—the ma-\njor building blocks that you will select, combine, instantiate, analyze, and docu-\nment as part of your design process.\n2.1 Design in General\nDesign  is  both  a  verb  and  a  noun.  Design  is  a  process,  an  activity,  and  hence  a  \nverb. The process results in the creation of a design—a description of a desired \nend  state.  Thus  the  output  of  the  design  process  is  the  thing,  the  noun,  the  arti-\nfact  that  you  will  eventually  implement.  Designing  means  making  decisions  to  \nachieve goals and satisfy requirements and constraints. The outputs of the design","metadata":{"id":165}}],["67e460fd-eb47-47dc-9fe5-7c90a64cb81a",{"pageContent":"fact  that  you  will  eventually  implement.  Designing  means  making  decisions  to  \nachieve goals and satisfy requirements and constraints. The outputs of the design \nprocess are a direct reflection of those goals, requirements, and constraints. Think \nabout  houses,  for  example.  Why  do  traditional  houses  in  China  look  different  \nfrom those in Switzerland or Algeria? Why does a yurt look like a yurt, which is \ndifferent from an igloo or a chalet or a longhouse?\nThe architectures of these styles of houses have evolved over the centuries \nto  reflect  their  unique  sets  of  goals,  requirements,  and  constraints.  Houses  in  \nwww.EBooksWorld.ir\n12 Chapter 2—Architectural Design\nChina feature symmetric enclosures, sky wells to increase ventilation, south-fac-\ning courtyards to collect sunlight and provide protection from cold north winds, \nand so forth. A-frame houses have steep pitched roofs that extend to the ground,","metadata":{"id":166}}],["838d916d-f73f-43bd-bc01-953930221c0f",{"pageContent":"ing courtyards to collect sunlight and provide protection from cold north winds, \nand so forth. A-frame houses have steep pitched roofs that extend to the ground, \nmeaning  minimal  painting  and  protection  from  heavy  snow  loads  (which  just  \nslide off to the ground). Igloos are built of ice, reflecting the availability of ice, \nthe  relative  poverty  of  other  building  materials,  and  the  constraints  of  time  (a  \nsmall one can be built in an hour).\nIn each case, the process of design involved the selection and adaptation of a \nnumber of solution approaches. Even igloo designs can vary. Some are small and \nmeant  for  a  temporary  travel  shelter.  Others  are  large,  often  connecting  several  \nstructures,  meant  for  entire  communities  to  meet.  Some  are  simple  unadorned  \nsnow  huts.  Others  are  lined  with  furs,  with  ice  “windows”,  and  doors  made  of  \nanimal skin.\nThe process of design, in each case, balances the various “forces” facing the","metadata":{"id":167}}],["04f99076-3c93-454a-8856-11bb14806094",{"pageContent":"snow  huts.  Others  are  lined  with  furs,  with  ice  “windows”,  and  doors  made  of  \nanimal skin.\nThe process of design, in each case, balances the various “forces” facing the \ndesigner. Some designs require considerable skill to execute (such as carving and \nstacking  snow  blocks  in  such  a  way  that  they  produce  a  self-supporting  dome).  \nOthers require relatively little skill—a lean-to can be constructed from branches \nand  bark  by  almost  anyone.  But  the  qualities  that  these  structures  exhibit  may  \nalso vary considerably. Lean-tos provide little protection from the elements and \nare  easily  destroyed,  whereas  an  igloo  can  withstand  Arctic  storms  and  support  \nthe weight of a person standing on the roof.\nIs  design  “hard”?  Well,  yes  and  no.  Novel  design  is  hard.  It  is  pretty  clear  \nhow to design a conventional bicycle, but the design for the Segway broke new \nground. Fortunately, most design is not novel, because most of the time our re-","metadata":{"id":168}}],["72e995f3-cbeb-4eb1-88b0-8c35904f5eb4",{"pageContent":"how to design a conventional bicycle, but the design for the Segway broke new \nground. Fortunately, most design is not novel, because most of the time our re-\nquirements  are  not  novel.  Most  people  want  a  bicycle  that  will  reliably  convey  \nthem from place to place. The same holds true in every domain. Consider houses, \nfor example. Most people living in Phoenix want a house that can be easily and \neconomically  kept  cool,  whereas  most  people  in  Edmonton  are  primarily  con-\ncerned with a house that can be kept warm. In contrast, people living in Japan and \nLos Angeles are concerned with buildings that can withstand earthquakes.\nThe good news for you, the architect, is that there are ample proven designs \nand  design  fragments,  or  building  blocks  that  we  call  design  concepts,  that  can  \nbe  reused  and  combined  to  reliably  achieve  these  goals.  If  your  design  is  truly  \nnovel—if you are designing the next Sydney Opera House—then the design pro-","metadata":{"id":169}}],["c06fac39-a533-4ae3-a05c-40f925393dfc",{"pageContent":"be  reused  and  combined  to  reliably  achieve  these  goals.  If  your  design  is  truly  \nnovel—if you are designing the next Sydney Opera House—then the design pro-\ncess will likely be “hard”. The Sydney Opera House, for example, cost 14 times \nits  original  budget  estimate  and  was  delivered  ten  years  late.  So,  too,  with  the  \ndesign of software architectures.\nwww.EBooksWorld.ir\n2.2 Design in Software Architecture 13\n2.2 Design in Software Architecture\nArchitectural design for software systems is no different than design in general: It \ninvolves making decisions, working with available skills and materials, to satisfy \nrequirements and constraints. In architectural design, we make decisions to trans-\nform our design purpose, requirements, constraints, and architectural concerns—\nwhat  we  call  the  architectural  drivers—into  structures,  as  shown  in  Figure  2.1.  \nThese structures are then used to guide the project. They guide analysis and con-","metadata":{"id":170}}],["e8f4fdbb-c2ef-4f46-8215-2cb2835cfa90",{"pageContent":"what  we  call  the  architectural  drivers—into  structures,  as  shown  in  Figure  2.1.  \nThese structures are then used to guide the project. They guide analysis and con-\nstruction, and serve as the foundation for educating a new project member. They \nalso guide cost and schedule estimation, team formation, risk analysis and miti-\ngation, and, of course, implementation.\nArchitectural design is, therefore, a key step to achieving your product and \nproject goals. Some of these goals are technical (e.g., achieving low and predict-\nable latency in a video game or an e-commerce website), and some are nontech-\nnical  (e.g.,  keeping  the  workforce  employed,  entering  a  new  market,  meeting  a  \ndeadline). The decisions that you, as an architect, make will have implications for \nthe achievement of these goals and may, in some cases, be in conflict. The choice\nDesign Purpose\nPrimary Functionality\nConstraints\nArchitectural Concerns\nArchitectural Drivers\nQuality Attributes\n<<uses>>","metadata":{"id":171}}],["c1042579-e4e4-425e-a1ff-30b6254435ac",{"pageContent":"the achievement of these goals and may, in some cases, be in conflict. The choice\nDesign Purpose\nPrimary Functionality\nConstraints\nArchitectural Concerns\nArchitectural Drivers\nQuality Attributes\n<<uses>>\n(Documented) Structures\nresulting from \ndesign decisions\n<<produces>>\n<<selects and \ninstantiates>>\nThe Architect\nCandidate \ndesign\ndecisions\nDesign Concepts\nServer Side\n«Layer»\nServices SS\n«Layer»\nBusiness Logic SS\n«Layer»\nData SS\n«facade»\nRequestService\nTopologyController\nDomainEntities\nRegionDataMapper\nTimeServerDataMapper\nEventDataMapper\nTimeServerConnector\nTimeServerEventsController\nDataCollectionController\nServerClient\nTechnician\n:NetworkStatusMonitoringView\n:NetworkStatusMonitoringController:RequestManager:RequestService\n:TopologyController:RegionDataMapper\nlaunch()\ninitialize()\nrequestTopology()\nsendRequest(Request)\nrequestTopology()\nretrieve(id) :Region\n:Region\n:Region\n:Response\n:Region\n:boolean\ngetRootRegion() :Region\npopulateView()\ninteract()\npc :User Workstation\n«replicated»\n:Application Server\n«replicated»","metadata":{"id":172}}],["8c2aec4f-77f0-4dfe-9064-976210acce44",{"pageContent":"requestTopology()\nretrieve(id) :Region\n:Region\n:Region\n:Response\n:Region\n:boolean\ngetRootRegion() :Region\npopulateView()\ninteract()\npc :User Workstation\n«replicated»\n:Application Server\n«replicated»\ndatabase :Database Server\n:Time Server\nServer-Side Application\n«Java Web Start»\nClient-Side \nApplication\n«SNMP»\n«JDBC»\nFIGURE 2.1 Overview of the architecture design activity  \n(\nArchitect image © Brett Lamb | Dreamstime.com)\nwww.EBooksWorld.ir\n14 Chapter 2—Architectural Design\nof a particular reference architecture (e.g., the Rich Client Application) may pro-\nvide a good foundation for achieving your latency goals and will keep your work-\nforce employed because they are already familiar with that reference architecture \nand its supporting technology stack. But this choice may not help you enter a new \nmarket—mobile games, for example. \nIn  general,  when  designing,  a  change  in  some  structure  to  achieve  one  \nquality  attribute  will  have  negative  effects  on  other  quality  attributes.  These","metadata":{"id":173}}],["e3e33fcb-7424-4b6b-b447-c53c4c399a9c",{"pageContent":"In  general,  when  designing,  a  change  in  some  structure  to  achieve  one  \nquality  attribute  will  have  negative  effects  on  other  quality  attributes.  These  \ntradeoffs  are  a  fact  of  life  for  every  practicing  architect  in  every  domain.  We  \nwill  see  this  over  and  over  again  in  the  examples  and  case  studies  provided  in  \nthis book. Thus the architect’s job is not one of finding an optimal solution, but \nrather  one  of  satisficing—searching  through  a  potentially  large  space  of  design  \nalternatives and decisions until an acceptable solution is found.\n2.2.1 Architectural Design\nGrady  Booch  has  said,  “All  architecture  is  design,  but  not  all  design  is  archi-\ntecture”. What makes a decision “architectural”? A decision is architectural if it \nhas  non-local  consequences  and  those  consequences  matter  to  the  achievement  \nof  an  architectural  driver.  No  decision  is,  therefore,  inherently  architectural  or","metadata":{"id":174}}],["11b09435-c9d4-4470-8896-11ec6104f3e0",{"pageContent":"has  non-local  consequences  and  those  consequences  matter  to  the  achievement  \nof  an  architectural  driver.  No  decision  is,  therefore,  inherently  architectural  or  \nnon-architectural. The choice of a buffering strategy within a single element may \nhave little effect on the rest of the system, in which case it is an implementation \ndetail  that  is  of  no  concern  to  anyone  except  the  implementer  or  maintainer  of  \nthat element. In contrast, the buffering strategy may have enormous implications \nfor performance (if the buffering affects the achievement of latency or through-\nput  or  jitter  goals)  or  availability  (if  the  buffers  might  not  be  large  enough  and  \ninformation gets lost) or modifiability (if we wish to flexibly change the buffering \nstrategy  in  different  deployments  or  contexts).  The  choice  of  a  buffering  strat-\negy,  like  most  design  choices,  is  neither  inherently  architectural  nor  inherently","metadata":{"id":175}}],["efb56615-f2e4-4dec-8469-a7085bbbeb69",{"pageContent":"strategy  in  different  deployments  or  contexts).  The  choice  of  a  buffering  strat-\negy,  like  most  design  choices,  is  neither  inherently  architectural  nor  inherently  \nnon-architectural. Instead, this distinction is completely dependent on the current \nand anticipated architectural drivers.\n2.2.2 Element Interaction Design\nArchitectural design generally results in the identification of only a subset of the \nelements that are part of the system’s structure. This is to be expected because, \nduring  initial  architectural  design,  the  architect  will  focus  on  the  primary  func-\ntionality of the system. What makes a use case primary? A combination of busi-\nness importance, risk, and complexity considerations feed into this designation. \nOf course, to your users, everything is urgent and top priority. More realistically, \na small number of use cases provide the most fundamental business value or rep-","metadata":{"id":176}}],["737e9e2e-bacd-41af-8c9c-2d0138e54517",{"pageContent":"Of course, to your users, everything is urgent and top priority. More realistically, \na small number of use cases provide the most fundamental business value or rep-\nresent the greatest risk (if they are done wrong), so these are deemed primary.\nEvery system has many more use cases, beyond the primary ones, that need \nto  be  satisfied.  The  elements  that  support  these  nonprimary  use  cases  and  their  \nwww.EBooksWorld.ir\n2.2 Design in Software Architecture 15\ninterfaces are identified as part of what we call element interaction design. This \nlevel  of  design  usually  follows  architectural  design.  The  location  and  relation-\nships  of  these  elements,  however,  are  constrained  by  the  decisions  that  were  \nmade during architectural design. These elements can be units of work (i.e., mod-\nules) assigned to an individual or to a team, so this level of design is important for \ndefining not only how nonprimary functionality is allocated, but also for planning","metadata":{"id":177}}],["91f31e50-8d14-423d-9a14-a3a383c3afb4",{"pageContent":"ules) assigned to an individual or to a team, so this level of design is important for \ndefining not only how nonprimary functionality is allocated, but also for planning \npurposes  (e.g.,  team  formation  and  communication,  budgeting,  outsourcing,  re-\nlease planning, unit and integration test planning).\nDepending on the scale and complexity of the system, the architect should be \ninvolved in element interaction design, either directly or in an auditing role. This \ninvolvement  ensures  that  the  system’s  important  quality  attributes  are  not  com-\npromised—for example, if the elements are not defined, located, and connected \ncorrectly. It will also help the architect spot opportunities for generalization.\n2.2.3 Element Internals Design\nA third level of design follows element interaction design, which we call element \ninternals design. In this level of design, which is usually conducted as part of the \nelement development activities, the internals of the elements identified in the pre-","metadata":{"id":178}}],["abced3e1-4d1c-407d-a58f-760c32279e7e",{"pageContent":"internals design. In this level of design, which is usually conducted as part of the \nelement development activities, the internals of the elements identified in the pre-\nvious design level are established, so as to satisfy the element’s interface.\nArchitectural decisions can and do occur at the three levels of design. More-\nover,  during  architectural  design,  the  architect  may  need  to  delve  as  deeply  as  \nelement internals design to achieve a particular architectural driver. An example \nof  this  is  the  selection  of  a  buffering  strategy  that  was  previously  discussed.  In  \nthis  sense,  architectural  design  can  involve  considerable  detail,  which  explains  \nwhy we do not like to think about it in terms of “high-level design” or “detailed \ndesign” (see the sidebar “Detailed Design?”).\nArchitectural  design  precedes  element  interaction  design,  which  precedes  \nelement internals design. This is logically necessary: One cannot design an ele-","metadata":{"id":179}}],["50724853-2a5c-4225-b686-f1a3798deafb",{"pageContent":"Architectural  design  precedes  element  interaction  design,  which  precedes  \nelement internals design. This is logically necessary: One cannot design an ele-\nment’s internals until the elements themselves have been defined, and one cannot \nreason about interaction until several elements and some patterns of interactions \namong them have been defined. But as projects grow and evolve, there is, in prac-\ntice, considerable iteration between these activities.\nDetailed Design?\nThe term “detailed design” is often used to refer to the design of the inter-\nnals of modules. Although it is widely used, we really don’t like this term, \nwhich is presented as somehow in opposition to “high-level design”. We \nprefer the more precise terms “architectural design”, “element interaction \ndesign”, and “element internals design”.\nwww.EBooksWorld.ir\n16 Chapter 2—Architectural Design\nAfter all, architectural design may be quite detailed, if your system is","metadata":{"id":180}}],["8a1f18fe-3f36-4179-95bc-432a496c4aa9",{"pageContent":"design”, and “element internals design”.\nwww.EBooksWorld.ir\n16 Chapter 2—Architectural Design\nAfter all, architectural design may be quite detailed, if your system is \ncomplex. And some design “details” will turn out to be architectural. For the \nsame reason, we also don’t like the terms “high-level design” and “low-level \ndesign”. Who can really know what these terms actually mean? Clearly, \n“high-level design” should be somehow “higher” or more abstract, and cover \nmore of the architectural landscape than “low-level design”, but beyond that \nwe are at a loss to imbue these terms with any precise meaning.\nSo here is what we recommend: Just avoid using terms such as “high”, \n“low”, or “detailed” altogether. There is always a better, more precise \nchoice, such as “architectural”, “element interaction”, or “element internals” \ndesign!\nThink carefully about the impact of the decisions you are making, the \ninformation that you are trying to convey in your design documentation,","metadata":{"id":181}}],["ad629950-77e6-4d8a-b514-61e5434aac7b",{"pageContent":"design!\nThink carefully about the impact of the decisions you are making, the \ninformation that you are trying to convey in your design documentation, \nand the likely audience for that information, and then give that process an \nappropriate, meaningful name. \n2.3 Why Is Architectural Design So Important?\nThere is a very high cost to a project of not making certain design decisions, or \nof not making them early enough. This manifests itself in many different ways. \nEarly on, an initial architecture is critical for project proposals (or, as it is some-\ntimes called in the consulting world, the pre-sales process). Without doing some \narchitectural  thinking  and  some  early  design  work,  you  cannot  confidently  pre-\ndict  project  cost,  schedule,  and  quality.  Even  at  this  early  stage,  an  architecture  \nwill  determine  the  key  approaches  for  achieving  architectural  drivers,  the  gross  \nwork-breakdown  structure,  and  the  choices  of  tools,  skills,  and  technologies","metadata":{"id":182}}],["bef32716-bd37-4cec-9bb2-2dae00639705",{"pageContent":"will  determine  the  key  approaches  for  achieving  architectural  drivers,  the  gross  \nwork-breakdown  structure,  and  the  choices  of  tools,  skills,  and  technologies  \nneeded to realize the system.\nIn  addition,  architecture  is  a  key  enabler  of  agility,  as  we  will  discuss  in  \nChapter 9. Whether your organization has embraced Agile processes or not, it is \ndifficult  to  imagine  anyone  who  would  willingly  choose  an  architecture  that  is  \nbrittle and hard to change or extend or tune—and yet it happens all the time. This \nso-called technical  debt  occurs  for  a  variety  of  reasons,  but  paramount  among  \nthese is the combination of a focus on features—typically driven by stakeholder \ndemands—and  the  inability  of  architects  and  project  managers  to  measure  the  \nreturn on investment of good architectural practices. Features provide immediate \nbenefit. Architectural improvement provides immediate costs and long-term ben-","metadata":{"id":183}}],["7c19e84e-af9c-446e-a29f-8199a15a0df5",{"pageContent":"return on investment of good architectural practices. Features provide immediate \nbenefit. Architectural improvement provides immediate costs and long-term ben-\nefits. Put this way, why would anyone ever “invest” in architecture? The answer \nis simple: Without architecture, the benefits that the system is supposed to bring \nwill be far harder to realize.\nSimply put, if you do not make some key architectural decisions early and \nif you allow your architecture to degrade, you will be unable to maintain sprint \nwww.EBooksWorld.ir\n2.4 Architectural Drivers 17\nvelocity, because you cannot easily respond to change requests. However, we ve-\nhemently disagree with what the original creators of the Agile Manifesto claimed: \n“The  best  architectures,  requirements,  and  designs  emerge  from  self-organizing  \nteams”.  Indeed,  our  demurral  with  this  point  is  precisely  why  we  have  written  \nthis  book.  Good  architectural  design  is  difficult  (and  still  rare),  and  it  does  not","metadata":{"id":184}}],["e1fbfe3d-d1ce-4ad6-b6f2-fb66f3b0e0ae",{"pageContent":"teams”.  Indeed,  our  demurral  with  this  point  is  precisely  why  we  have  written  \nthis  book.  Good  architectural  design  is  difficult  (and  still  rare),  and  it  does  not  \njust “emerge”. This opinion mirrors a growing consensus within the Agile com-\nmunity. More and more, we see techniques such as “disciplined agility at scale”, \nthe  “walking  skeleton”,  and  the  “scaled  Agile  framework”  embraced  by  Agile  \nthought leaders and practitioners alike. Each of these techniques advocates some \narchitectural thinking and design prior to much, if any, development. To reiterate, \narchitecture enables agility, and not the other way around.\nFurthermore, the architecture will influence, but not determine, other deci-\nsions that are not in and of themselves design decisions. These decisions do not \ninfluence  the  achievement  of  quality  attributes  directly,  but  they  may  still  need  \nto be made by the architect. For example, such decisions may include selection","metadata":{"id":185}}],["60bd4386-238d-4fc7-9239-fa3587a9702e",{"pageContent":"influence  the  achievement  of  quality  attributes  directly,  but  they  may  still  need  \nto be made by the architect. For example, such decisions may include selection \nof  tools;  structuring  the  development  environment;  supporting  releases,  deploy-\nment, and operations; and making work assignments.\nFinally,  a  well-designed,  properly  communicated  architecture  is  key  to  \nachieving agreements that will guide the team. The most important kinds to make \nare  agreements  on  interfaces  and  on  shared  resources.  Agreeing  on  interfaces  \nearly  is  important  for  component-based  development,  and  critically  important  \nfor distributed development. These decisions will be made sooner or later. If you \ndon’t  make  the  decisions  early,  the  system  will  be  much  more  difficult  to  inte-\ngrate.  In  Section  3.6,  we  will  discuss  how  to  define  interfaces  as  part  of  archi-","metadata":{"id":186}}],["caac74fb-b65f-44f4-ab31-bf319029d877",{"pageContent":"don’t  make  the  decisions  early,  the  system  will  be  much  more  difficult  to  inte-\ngrate.  In  Section  3.6,  we  will  discuss  how  to  define  interfaces  as  part  of  archi-\ntectural  design—both  the  external  interfaces  to  other  systems  and  the  internal  \ninterfaces that mediate your element interactions.\n2.4 Architectural Drivers\nBefore  commencing  design  with  ADD  (or  with  any  other  design  method,  for  \nthat  matter),  you  need  to  think  about  what  you  are  doing  and  why.  While  this  \nstatement may seem blindingly obvious, the devil is, as usual, in the details. We \ncategorize these “what” and “why” questions as architectural drivers. As shown \nin Figure 2.1, these drivers include a design purpose, quality attributes, primary \nfunctionality,   architectural   concerns,   and   constraints.   These   considerations   \nare  critical  to  the  success  of  the  system  and,  as  such,  they  drive  and  shape  the  \narchitecture.","metadata":{"id":187}}],["1842230f-582d-4bc3-9439-ae4e425ab272",{"pageContent":"are  critical  to  the  success  of  the  system  and,  as  such,  they  drive  and  shape  the  \narchitecture.\nAs  with  any  other  important  requirements,  architectural  drivers  need  to  be  \nbaselined and managed throughout the development life cycle.\nwww.EBooksWorld.ir\n18 Chapter 2—Architectural Design\n2.4.1 Design Purpose\nFirst,  you  need  to  be  clear  about  the  purpose  of  the  design  that  you  want  to  \nachieve. When and why are you doing this architecture design? Which business \ngoals is the organization most concerned about at this time?\n1. You may be doing architecture design as part of a project proposal (for the \npre-sales process in a consulting organization, or for internal project selec-\ntion and prioritization in a company, as discussed in Section 9.1.1). It is not \nuncommon that, as part of determining project feasibility, schedule, and bud-\nget, an initial architecture is created. Such an architecture would not be very","metadata":{"id":188}}],["89198ea7-b0f6-4330-8c3d-00fc12c001b8",{"pageContent":"uncommon that, as part of determining project feasibility, schedule, and bud-\nget, an initial architecture is created. Such an architecture would not be very \ndetailed; its purpose is to understand and break down the architecture in suffi-\ncient detail that the units of work are understood and hence may be estimated.\n2. You may be doing architecture design as part of the process of creating an \nexploratory prototype. In this case, the purpose of the architecture design \nprocess is not so much to create a releasable or reusable system, but rather to \nexplore the domain, to explore new technology, to place something execut-\nable in front of a customer to elicit rapid feedback, or to explore some quality \nattribute (such as performance scalability or failover for availability).\n3. You may be designing your architecture during development. This could be \nfor an entire new system, for a substantial portion of a new system, or for a","metadata":{"id":189}}],["39676776-d2de-4036-ae5a-ba37e21c1bca",{"pageContent":"3. You may be designing your architecture during development. This could be \nfor an entire new system, for a substantial portion of a new system, or for a \nportion of an existing system that is being refactored or replaced. In this case, \nthe purpose is to do enough design work to satisfy requirements, guide sys-\ntem construction and work assignments, and prepare for an eventual release.\nThese  purposes  may  be  interpreted  and  realized  differently  for  greenfield  \nsystems in mature domains, for greenfield systems in novel domains, and for ex-\nisting systems. In a mature domain, the pre-sales process, for example, might be \nrelatively  straightforward;  the  architect  can  reuse  existing  systems  as  examples  \nand confidently make estimates based on analogy. In novel domains, the pre-sales \nestimation process will be far more complex and risky, and may have highly vari-\nable results. In these circumstances, a prototype of the system, or a key part of the","metadata":{"id":190}}],["2ca08be2-fb17-4944-9807-a69253f23d9a",{"pageContent":"estimation process will be far more complex and risky, and may have highly vari-\nable results. In these circumstances, a prototype of the system, or a key part of the \nsystem, may need to be created to mitigate risk and reduce uncertainty. In many \ncases, this architecture may also need to be quickly adapted as new requirements \nare learned and embraced. In brownfield systems, while the requirements are bet-\nter  understood,  the  existing  system  is  itself  a  complex  object  that  must  be  well  \nunderstood for planning to be accurate.\nFinally, the development organization’s goals during development or main-\ntenance may affect the architecture design process. For example, the organization \nmight be interested in designing for reuse, designing for future extension or sub-\nsetting, designing for scalability, designing for continuous delivery, designing to \nbest utilize existing project capabilities and team member skills, and so forth. Or","metadata":{"id":191}}],["eaa129b8-b889-40f2-a333-6f157ce5a7c1",{"pageContent":"setting, designing for scalability, designing for continuous delivery, designing to \nbest utilize existing project capabilities and team member skills, and so forth. Or \nthe  organization  might  have  a  strategic  relationship  with  a  vendor.  Or  the  CIO  \nmight have a specific like or dislike and wants to impose it on your project.\nwww.EBooksWorld.ir\n2.4 Architectural Drivers 19\nWhy  do  we  bother  to  list  these  considerations?  Because  they  will  affect  \nboth the process of design and the outputs of design. Architectures exist to help \nachieve business goals. The architect should be clear about these goals and should \ncommunicate them (and negotiate them!) and establish a clear design purpose be-\nfore beginning the design process.\n2.4.2 Quality Attributes\nIn  the  book  Software  Architecture  in  Practice, quality  attributes  are  defined  as  \nbeing measurable or testable properties of a system that are used to indicate how","metadata":{"id":192}}],["df2f05af-1430-4d02-a602-74d65b266154",{"pageContent":"2.4.2 Quality Attributes\nIn  the  book  Software  Architecture  in  Practice, quality  attributes  are  defined  as  \nbeing measurable or testable properties of a system that are used to indicate how \nwell  the  system  satisfies  the  needs  of  its  stakeholders.  Because  quality  tends  to  \nbe  a  subjective  concept  in  itself,  these  properties  allow  quality  to  be  expressed  \nsuccinctly and objectively.\nAmong the drivers, quality attributes are the ones that shape the architecture \nthe most significantly. The critical choices that you make when you are doing ar-\nchitectural design determine, in large part, the ways that your system will or will \nnot meet these driving quality attribute goals.\nGiven their importance, you must worry about eliciting, specifying, priori-\ntizing,  and  validating  quality  attributes.  Given  that  so  much  depends  on  getting  \nthese  drivers  right,  this  sounds  like  a  daunting  task.  Fortunately,  a  number  of","metadata":{"id":193}}],["b24e7948-ae72-48ba-aa2b-f27e78c7be3e",{"pageContent":"tizing,  and  validating  quality  attributes.  Given  that  so  much  depends  on  getting  \nthese  drivers  right,  this  sounds  like  a  daunting  task.  Fortunately,  a  number  of  \nwell-understood, widely disseminated techniques can help you here (see sidebar \n“The Quality Attribute Workshop and the Utility Tree”):\n§\tQuality Attribute Workshop (QAW) is a facilitated brainstorming session \ninvolving a group of system stakeholders that covers the bulk of the activi-\nties of eliciting, specifying, prioritizing, and achieving consensus on quality \nattributes.\n§\tMission Thread Workshop serves the same purpose as QAW, but for a sys-\ntem of systems.\n§\tThe Utility Tree can be used by the architect to prioritize quality attribute \nrequirements according to their technical difficulty and risk.\nWe  believe  that  the  best  way  to  discuss,  document,  and  prioritize  quality  \nattribute requirements is as a set of scenarios. A scenario, in its most basic form,","metadata":{"id":194}}],["52f86927-9c19-45e1-93e8-539d96f8e86a",{"pageContent":"We  believe  that  the  best  way  to  discuss,  document,  and  prioritize  quality  \nattribute requirements is as a set of scenarios. A scenario, in its most basic form, \ndescribes the system’s response to some stimulus. Why are scenarios the best ap-\nproach? Because all other approaches are worse! Endless time may be wasted in \ndefining terms such as “performance” or “modifiability” or “configurability”, as \nthese discussions tend to shed little light on the real system. It is meaningless to \nsay that a system will be “modifiable”, because every system is modifiable with \nrespect to some changes and not modifiable with respect to others. One can, how-\never, specify the modifiability response measure you would like to achieve (say, \nelapsed time or effort) in response to a specific change request. For example, you \nmight want to specify that “a change to update shipping rates on the e-commerce \nwww.EBooksWorld.ir\n20 Chapter 2—Architectural Design","metadata":{"id":195}}],["33f39e14-b528-49e5-809d-757dc910aa13",{"pageContent":"might want to specify that “a change to update shipping rates on the e-commerce \nwww.EBooksWorld.ir\n20 Chapter 2—Architectural Design\nwebsite is completed and tested in less than 1 person-day of effort”—an unam-\nbiguous criterion.\nThe heart of a quality attribute scenario, therefore, is the pairing of a stim-\nulus with a response. Suppose that you are building a video game and you have \na  functional  requirement  like  this:  “The  game  shall  change  view  modes  when  \nthe user presses the <C> button”. This functional requirement, if it is important, \nneeds to be associated with quality attribute requirements. For example:\n§\tHow fast should the function be?\n§\tHow secure should the function be?\n§\tHow modifiable should the function be?\nTo  address  this  problem,  we  use  a  scenario  to  describe  a  quality  attribute  \nrequirement. A quality attribute scenario is a short description of how a system is \nrequired to respond to some stimulus. For example, we might annotate the func-","metadata":{"id":196}}],["ef1f23ae-64f1-46f2-9ff2-58038eced81a",{"pageContent":"requirement. A quality attribute scenario is a short description of how a system is \nrequired to respond to some stimulus. For example, we might annotate the func-\ntional requirement given earlier as follows: “The game shall change view modes \nin < 500 ms when the user presses the <C> button”. A scenario associates a stim-\nulus (in this case, the pressing of the <C> button) with a response (changing the \nview mode) that is measured using a response measure (< 500 ms). A complete \nquality  attribute  scenario  adds  three  other  parts:  the  source  of  the  stimulus  (in  \nthis  case,  the  user),  the  artifact  affected  (in  this  case,  because  we  are  dealing  \nwith  end-to-end  latency,  the  artifact  is  the  entire  system)  and  the  environment  \n(are we in normal operation, startup, degraded mode, or some other mode?). In \ntotal, then, there are six parts of a completely well-specified scenario, as shown \nin Figure 2.2.\nStimulus\nResponse\nResponse\nMeasure\nSource\nof Stimulus\nArtifact","metadata":{"id":197}}],["80d4f559-97f0-4cf9-84d0-3218ee2a4651",{"pageContent":"total, then, there are six parts of a completely well-specified scenario, as shown \nin Figure 2.2.\nStimulus\nResponse\nResponse\nMeasure\nSource\nof Stimulus\nArtifact\nEnvironment\n3\n2\n1\n4\nFIGURE 2.2 The six parts of a quality attribute scenario\nwww.EBooksWorld.ir\n2.4 Architectural Drivers 21\nScenarios are testable, falsifiable hypotheses about the quality attribute be-\nhavior of the system under consideration. Because they have explicit stimuli and \nresponses,  we  can  evaluate  a  design  in  terms  of  how  likely  it  is  to  support  the  \nscenario, and we can take measurements and test a prototype or fully fleshed-out \nsystem for whether it satisfies the scenario in practice. If the analysis (or proto-\ntyping results) indicates that the scenario’s response goal cannot be met, then the \nhypothesis is deemed falsified.\nAs  with  other  requirements,  scenarios  should  be  prioritized.  This  can  be  \nachieved  by  considering  two  dimensions  that  are  associated  with  each  scenario","metadata":{"id":198}}],["2620c516-471d-44dc-8f71-bed4457ba195",{"pageContent":"As  with  other  requirements,  scenarios  should  be  prioritized.  This  can  be  \nachieved  by  considering  two  dimensions  that  are  associated  with  each  scenario  \nand that are assigned a rank of importance:\n§\tThe first dimension corresponds to the importance of the scenario with re-\nspect to the success of the system. This is ranked by the customer.\n§\tThe second dimension corresponds to the degree of technical risk associ-\nated with the scenario. This is ranked by the architect.\nA  low/medium/high  (L/M/H)  scale  is  used  to  rank  both  dimensions.  Once  \nthe dimensions have been ranked, scenarios are prioritized by selecting those that \nhave a combination of (H, H), (H, M), or (M, H) rankings.\nIn  addition,  some  traditional  requirements  elicitation  techniques  can  be  \nmodified  slightly  to  focus  on  quality  attribute  requirements,  such  as  Joint  Re-\nquirements Planning (JRP), Joint Application Design (JAD), discovery prototyp-\ning, and accelerated systems analysis.","metadata":{"id":199}}],["0a9ed15e-3e2d-48fb-9112-9686be6df37e",{"pageContent":"quirements Planning (JRP), Joint Application Design (JAD), discovery prototyp-\ning, and accelerated systems analysis.\nBut whatever technique you use, do not start design without a prioritized list \nof  measurable  quality  attributes!  While  stakeholders  might  plead  ignorance  (“I  \ndon’t  know  how  fast  it  needs  to  be;  just  make  it  fast!”),  you  can  almost  always  \nelicit at least a range of possible responses. Instead of saying the system should \nbe “fast”, ask the stakeholder if a 10-second response time is acceptable. If that \nis unacceptable, ask if 5 seconds is OK, or 1 second. You will find that, in most \ncases, users know more than they realize about their requirements, and you can at \nleast “box them in” to a range.\nThe Quality Attribute Workshop and the Utility Tree\nThe Quality Attribute Workshop (QAW)\nThe QAW is a facilitated, stakeholder-focused method to generate, pri-\noritize, and refine quality attribute scenarios. A QAW meeting is ideally","metadata":{"id":200}}],["6c7087f4-65ee-4210-b0a5-5f0b7f0ec25b",{"pageContent":"The Quality Attribute Workshop (QAW)\nThe QAW is a facilitated, stakeholder-focused method to generate, pri-\noritize, and refine quality attribute scenarios. A QAW meeting is ideally \nenacted before the software architecture has been defined although, in \npractice, we have seen the QAW being used at all points in the software \ndevelopment life cycle. The QAW is focused on system-level concerns \nand specifically the role that software will play in the system. The steps of \nthe QAW are as follows:\nwww.EBooksWorld.ir\n22 Chapter 2—Architectural Design\n1. QAW Presentation and Introductions\nThe QAW facilitators describe the motivation for the QAW and explain \neach step of the method.\n2. Business Goals Presentation\nA stakeholder representing the project’s business concerns presents the \nsystem’s business context, broad functional requirements, constraints, \nand known quality attribute requirements. The quality attributes that \nwill be refined in later QAW steps will be derived from, and should be","metadata":{"id":201}}],["b07c5a37-d377-4782-91cb-a81cc684de4b",{"pageContent":"and known quality attribute requirements. The quality attributes that \nwill be refined in later QAW steps will be derived from, and should be \ntraceable to, the business goals presented in this step. For this reason, \nthese business goals must be prioritized.\n3. Architectural Plan Presentation\nThe architect presents the system architectural plans as they currently \nexist. Although the architecture has frequently not been defined yet \n(particularly for greenfield systems), the architect often knows quite a lot \nabout it even at this early stage. For example, the architect might already \nknow about technologies that are mandated, other systems that this \nsystem must interact with, standards that must be followed, subsystems \nor components that could be reused, and so forth.\n4. Identification of Architectural Drivers\nThe facilitators share their list of key architectural drivers that they \nassembled during steps 2 and 3 and ask the stakeholders for","metadata":{"id":202}}],["8a5559de-bfd3-4bae-ad98-aac2f53e87ca",{"pageContent":"4. Identification of Architectural Drivers\nThe facilitators share their list of key architectural drivers that they \nassembled during steps 2 and 3 and ask the stakeholders for \nclarifications, additions, deletions, and corrections. The idea here is to \nreach a consensus on a distilled list of architectural drivers that covers \nmajor functional requirements, business drivers, constraints, and quality \nattributes.\n5. Scenario Brainstorming\nGiven this context, each stakeholder now has the opportunity to express \na scenario representing that stakeholder’s needs and desires with \nrespect to the system. The facilitators ensure that each scenario has an \nexplicit stimulus and response. The facilitators also ensure traceability \nand completeness: At least one representative scenario should exist for \neach architectural driver listed in step 4 and should cover all the business \ngoals listed in step 2.\n6. Scenario Consolidation\nSimilar scenarios are consolidated where reasonable. In step 7, the","metadata":{"id":203}}],["bd2dc307-0ff9-44b4-82a4-c167383b70c6",{"pageContent":"each architectural driver listed in step 4 and should cover all the business \ngoals listed in step 2.\n6. Scenario Consolidation\nSimilar scenarios are consolidated where reasonable. In step 7, the \nstakeholders vote for their favorite scenarios, and consolidation helps \nto prevent votes from being spread across several scenarios that are \nexpressing essentially the same concern.\n7. Scenario Prioritization\nPrioritization of the scenarios is accomplished by allocating to each \nstakeholder a number of votes equal to 30 percent of the total number of \nscenarios. The stakeholders can distribute these votes to any scenario \nor scenarios. Once all the stakeholders have voted, the results are tallied \nand the scenarios are sorted in order of popularity.\nwww.EBooksWorld.ir\n2.4 Architectural Drivers 23\n8. Scenario Refinement\nThe highest-priority scenarios are refined and elaborated. The facilitators \nhelp the stakeholders express these in the form of six-part scenarios:","metadata":{"id":204}}],["03a83aa0-5670-4016-aab6-2f3e855b7f58",{"pageContent":"2.4 Architectural Drivers 23\n8. Scenario Refinement\nThe highest-priority scenarios are refined and elaborated. The facilitators \nhelp the stakeholders express these in the form of six-part scenarios: \nsource, stimulus, artifact, environment, response, and response \nmeasure.\nThe output of the QAW is therefore a prioritized list of scenarios, aligned \nwith business goals, where the highest-priority scenarios have been \nexplored and refined. A QAW can be conducted in as little as 2–3 hours \nfor a simple system or as part of an iteration, and as much as 2 days for a \ncomplex system where requirements completeness is a goal.\nUtility Tree\nIf no stakeholders are readily available to consult, you still need to decide \nwhat to do and how to prioritize the many challenges facing the system. \nOne way to organize your thoughts is to create a Utility Tree. The Utility \nTree, such as the one shown in the following figure, helps to articulate \nyour quality attribute goals in detail, and then to prioritize them.","metadata":{"id":205}}],["0ed4cb01-8625-45a3-8813-5362b16b01cd",{"pageContent":"Tree, such as the one shown in the following figure, helps to articulate \nyour quality attribute goals in detail, and then to prioritize them.\nUtility\nPerformance\nUsability\nAvailability\nSecurity\nPeak \nload\nLatency\nFeedback\nLearnability\nSW failure\nNetwork failure\nAuthentication\nAudit trail\nTime servers send traps to the management system at peak \nload. 100% of the traps are successfully processed and stored.\nThe management system collects data from time server during \npeak load. All data collected within 5 minutes.\nUser displays time server event history. The list of events \nfrom the last 24 hours is displayed within 1 second.\nA failure occurs in the management system. The management \nsystem resumes operation in less than 30 seconds.\nA user changes a system configuration. The change is logged\n \n100% of the time.\nA new user can configure their account and be operating with \nless than 8 hours of training.\nCritical events are reported and visible to the user in < 5 \nseconds.","metadata":{"id":206}}],["304c928b-d2f4-4ba5-8730-8ae9ba08d6e8",{"pageContent":"100% of the time.\nA new user can configure their account and be operating with \nless than 8 hours of training.\nCritical events are reported and visible to the user in < 5 \nseconds.\nAuthentication ensures 99.999% of unauthorized login \nattempts can be detected.\n(H, H)\n(H, H)\n(M, M)\n(H, L)\n(H, M)\n(M, H)\n(L, L)\n(H, L)\nwww.EBooksWorld.ir\n24 Chapter 2—Architectural Design\nIt works as follows. First write the word “Utility” on a sheet of paper. Then \nwrite the various quality attributes that constitute utility for your system. \nFor example, you might know, based on the business goals for the system, \nthat the most important qualities for the system are that the system be fast, \nsecure, and easy to modify. In turn, you would write these words under-\nneath “Utility”. Next, because we don’t really know what any of those terms \nactually means, we describe the aspect of the quality attribute that we are \nmost concerned with. For example, while “performance” is vague, “latency","metadata":{"id":207}}],["47fccecf-12d9-4cc5-ba8b-0c21d0bbde0e",{"pageContent":"actually means, we describe the aspect of the quality attribute that we are \nmost concerned with. For example, while “performance” is vague, “latency \nof database transactions” is a bit less vague. Likewise, while “modifiability” \nis vague, “ease of adding new codecs” is a bit less vague.\nThe leaves of the tree are expressed as scenarios, which provide con-\ncrete examples of the quality attribute considerations that you just enumer-\nated. For example, for “latency of database transactions”, you might create \na scenario such as “1000 users simultaneously update their own customer \nrecords under normal conditions with an average latency of 1 second”. \nFor “ease of adding new codecs”, you might create a scenario such as \n“Customer requests that a new custom codec be added to the system. \nCodec is added with no side effects in 2 person-weeks of effort”.\nFinally, the scenarios that you have created must be prioritized. We do \nthis prioritization by using the technique of ranking across two dimensions,","metadata":{"id":208}}],["33863db9-7898-4d62-a512-96adde252b73",{"pageContent":"Finally, the scenarios that you have created must be prioritized. We do \nthis prioritization by using the technique of ranking across two dimensions, \nresulting in a priority matrix such as the following (where the numbers in \nthe cells are from a set of system scenarios).\nBusiness \nImportance/\nTechnical RiskLMH\nL\n5, 6, 17, 20, 221, 1412, 19\nM\n9, 12, 168, 203, 13, 15\nH\n10, 18, 214, 72 ,   11\nOur job, as architects, is to focus on the lower-right-hand portion of this table (H, \nH): those scenarios that are of high business importance and high risk. Once we \nhave satisfactorily addressed those scenarios, we can move to the (M, H) or (H, \nM) ones, and then move up and to the left until all of the system’s scenarios are \naddressed (or perhaps until we run out of time or budget, as is often the case).\nIt should be noted that the QAW and the Utility Tree are two different \ntechniques that are aimed at the same goal—eliciting and prioritizing the","metadata":{"id":209}}],["ebdece9c-d2bb-4e79-aa0b-f33531d49776",{"pageContent":"It should be noted that the QAW and the Utility Tree are two different \ntechniques that are aimed at the same goal—eliciting and prioritizing the \nmost important quality attribute requirements, which will be some of your \nmost critical architectural drivers. There is no reason, however, to choose \nbetween these techniques. Both are useful and valuable and, in our \nexperience, they have complementary strengths: The QAW tends to focus \nmore on the requirements of external stakeholders, whereas the Utility \nTree tends to excel at eliciting the requirements of internal stakeholders. \nMaking all of these stakeholders happy will go a long way toward ensuring \nthe success of your architecture. \nwww.EBooksWorld.ir\n2.4 Architectural Drivers 25\n2.4.3 Primary Functionality\nFunctionality  is  the  ability  of  the  system  to  do  the  work  for  which  it  was  in-\ntended. As opposed to quality attributes, the way the system is structured does not","metadata":{"id":210}}],["2dada2ad-e3cf-4b5a-a83c-b92e6620fb9f",{"pageContent":"Functionality  is  the  ability  of  the  system  to  do  the  work  for  which  it  was  in-\ntended. As opposed to quality attributes, the way the system is structured does not \nnormally influence functionality. You can have all of the functionality of a given \nsystem  coded  in  a  single  enormous  module,  or  you  can  have  it  neatly  distrib-\nuted  across  many  smaller,  highly  cohesive  modules.  Externally  the  system  will  \nlook  and  work  the  same  way  if  you  consider  only  functionality.  What  matters,  \nthough, is what happens when you want to make changes to such system. In the \nformer case, changes will be difficult and costly; in the latter case, they should be \nmuch easier and cheaper to perform. In terms of architectural design, allocation \nof functionality to elements, rather than the functionality per se, is what matters. \nA good architecture is one in which the most common changes are localized in a \nsingle or a few elements, and hence easy to make.","metadata":{"id":211}}],["8f37c5b2-66d4-4c9c-be5d-1cc3da24d455",{"pageContent":"A good architecture is one in which the most common changes are localized in a \nsingle or a few elements, and hence easy to make.\nWhen  designing  an  architecture,  you  need  to  consider  at  least  the  primary  \nfunctionality. Primary functionality is usually defined as functionality that is crit-\nical  to  achieve  the  business  goals  that  motivate  the  development  of  the  system.  \nOther  criteria  for  primary  functionality  might  be  that  it  implies  a  high  level  of  \ntechnical  difficulty  or  that  it  requires  the  interaction  of  many  architectural  ele-\nments.  As  a  rule  of  thumb,  approximately  10  percent  of  your  use  cases  or  user  \nstories are likely to be primary.\nThere  are  two  important  reasons  why  you  need  to  consider  primary  func-\ntionality when designing an architecture:\n1. You need to think how functionality will be allocated to elements (usually \nmodules) to promote modifiability or reusability, and also to plan work \nassignments.","metadata":{"id":212}}],["e63d5d82-627c-4bec-be01-dbed9633bf99",{"pageContent":"1. You need to think how functionality will be allocated to elements (usually \nmodules) to promote modifiability or reusability, and also to plan work \nassignments.\n2. Some quality attribute scenarios are directly connected to the primary func-\ntionality in the system. For example, in a movie streaming application, one of \nthe primary use cases is, of course, to watch a movie. This use case is asso-\nciated with a performance quality attribute scenario such as “Once the user \npresses play, the movie should begin streaming in no more than 5 seconds”. \nIn this case, the quality attribute scenario is directly associated with the pri-\nmary use case, so making decisions to support this scenario also requires \nmaking decisions about how its associated functionality will be supported. \nThis is not the case for all quality attributes. For example, an availability sce-\nnario can involve recovery from a system failure, and this failure may occur \nwhen any of the system’s use cases are being executed.","metadata":{"id":213}}],["94a3bf90-ba0f-4b5a-a09e-5c4615cf0f6c",{"pageContent":"nario can involve recovery from a system failure, and this failure may occur \nwhen any of the system’s use cases are being executed.\nDecisions  regarding  the  allocation  of  functionality  that  are  made  during  \narchitectural  design  establish  a  precedent  for  how  the  rest  of  the  functionality  \nshould be allocated to modules as development progresses. This is usually not the \nwork  of  the  architect;  instead,  this  activity  is  typically  performed  as  part  of  the  \nelement interaction design process described in Section 2.2.2.\nwww.EBooksWorld.ir\n26 Chapter 2—Architectural Design\nFinally, bad decisions that are made regarding the allocation of functional-\nity result in the accumulation of technical debt. (Of course, these decisions may \nreveal themselves to be bad only in hindsight.) This debt can be paid through the \nuse of refactoring, although this impacts the project’s rate of progress, or velocity \n(see the sidebar “Refactoring”).\nRefactoring","metadata":{"id":214}}],["f415d550-77d4-4e76-9420-494bf494842b",{"pageContent":"use of refactoring, although this impacts the project’s rate of progress, or velocity \n(see the sidebar “Refactoring”).\nRefactoring\nIf you refactor a software architecture (or part of one), what you are doing \nis maintaining the same functionality but changing some quality attribute \nthat you care about. Architects often choose to refactor because a portion \nof the system is difficult to understand, debug, and maintain. Alternatively, \nthey may refactor because part of the system is slow, or prone to failure, \nor insecure.\nThe goal of the refactoring in each case is not to change the func-\ntionality, but rather to change the quality attribute response. (Of course, \nadditions to functionality are sometimes lumped together with a refactor-\ning exercise, but that is not the core intent of the refactoring.) Clearly, if we \ncan maintain the same functionality but change the architecture to achieve \ndifferent quality attribute responses, these requirement types are orthogo-","metadata":{"id":215}}],["906b58e4-865e-463f-9ec5-64538343b700",{"pageContent":"can maintain the same functionality but change the architecture to achieve \ndifferent quality attribute responses, these requirement types are orthogo-\nnal to each other—that is, they can vary independently.\n2.4.4 Architectural Concerns\nArchitectural concerns encompass additional aspects that need to be considered \nas  part  of  architectural  design  but  that  are  not  expressed  as  traditional  require-\nments. There are several different types of concerns:\n§\tGeneral concerns. These are “broad” issues that one deals with in creating \nthe architecture, such as establishing an overall system structure, the allo-\ncation of functionality to modules, the allocation of modules to teams, or-\nganization of the code base, startup and shutdown, and supporting delivery, \ndeployment, and updates.\n§\tSpecific concerns. These are more detailed system-internal issues such as \nexception management, dependency management, configuration, logging,","metadata":{"id":216}}],["619bed69-3863-4bc7-8a41-b7cea87eb890",{"pageContent":"deployment, and updates.\n§\tSpecific concerns. These are more detailed system-internal issues such as \nexception management, dependency management, configuration, logging, \nauthentication, authorization, caching, and so forth that are common across \nlarge numbers of applications. Some specific concerns are addressed in refer-\nence architectures (see Section 2.5.1), but others will be unique to your sys-\ntem. Specific concerns also result from previous design decisions. For exam-\nple, you may need to address session management if you previously decided \nto use a reference architecture for the development of web applications.\nwww.EBooksWorld.ir\n2.4 Architectural Drivers 27\n§\tInternal requirements. These requirements are usually not specified ex-\nplicitly in traditional requirement documents, as customers usually seldom \nexpress them. Internal requirements may address aspects that facilitate de-\nvelopment, deployment, operation, or maintenance of the system. They are","metadata":{"id":217}}],["4c217705-da03-4d16-b8a9-d7a1fb688899",{"pageContent":"express them. Internal requirements may address aspects that facilitate de-\nvelopment, deployment, operation, or maintenance of the system. They are \nsometimes called “derived requirements”.\n§\tIssues. These result from analysis activities, such as a design review (see \nSection 8.6), so they may not be present initially. For instance, an architec-\ntural evaluation may uncover a risk that requires some changes to be per-\nformed in the current design.\nSome  of  the  decisions  surrounding  architectural  concerns  might  be  trivial  \nor obvious. For example, your deployment structure might be a single processor \nfor an embedded system, or a single cell phone for an app. Your reference archi-\ntecture might be constrained by company policy. Your authentication and autho-\nrization  policies  might  be  dictated  by  your  enterprise  architecture  and  realized  \nin a shared framework. In other cases, however, the decisions required to satisfy","metadata":{"id":218}}],["e90bcab4-4099-4556-bcda-1228d7764302",{"pageContent":"rization  policies  might  be  dictated  by  your  enterprise  architecture  and  realized  \nin a shared framework. In other cases, however, the decisions required to satisfy \nparticular concerns may be less obvious—for example, in exception management \nor input validation or structuring the code base.\nFrom their past experience, wise architects are usually aware of the concerns \nthat are associated with a particular type of system and the need to make design \ndecisions to address them. Inexperienced architects are usually less aware of such \nconcerns;  because  these  concerns  tend  to  be  tacit  rather  than  explicit,  they  may  \nnot consider them as part of the design process, which often results in problems \nlater on.\nArchitectural  concerns  frequently  result  in  the  introduction  of  new  quality  \nattribute  scenarios.  The  concern  of  “supporting  logging”,  for  example,  is  too  \nvague  and  needs  to  be  made  more  specific.  Like  the  quality  attribute  scenarios","metadata":{"id":219}}],["91a809de-734d-40b2-aff2-3d3c6f30958f",{"pageContent":"attribute  scenarios.  The  concern  of  “supporting  logging”,  for  example,  is  too  \nvague  and  needs  to  be  made  more  specific.  Like  the  quality  attribute  scenarios  \nthat  are  provided  by  the  customer,  these  scenarios  need  to  be  prioritized.  For  \nthese  scenarios,  however,  the  customer  is  the  development  team,  operations,  or  \nother  members  of  the  organization.  During  design,  the  architect  must  consider  \nboth the quality attribute scenarios that are provided by the customer and those \nscenarios that are derived from architectural concerns.\nOne of the goals of our revision of the ADD method was to elevate the impor-\ntance of architectural concerns as explicit inputs to the architecture design process, \nas will be highlighted in our examples and case studies in Chapters 4, 5, and 6.\n2.4.5    Constraints\nYou  need  to  catalog  the  constraints  on  development  as  part  of  the  architectural","metadata":{"id":220}}],["d744ffa9-5bd6-4513-87a2-658c98a56dfd",{"pageContent":"as will be highlighted in our examples and case studies in Chapters 4, 5, and 6.\n2.4.5    Constraints\nYou  need  to  catalog  the  constraints  on  development  as  part  of  the  architectural  \ndesign  process.  These  constraints  may  take  the  form  of  mandated  technologies,  \nother  systems  with  which  your  system  needs  to  interoperate  or  integrate,  laws  \nand  standards  that  must  be  complied  with,  the  abilities  and  availability  of  your  \ndevelopers, deadlines that are non-negotiable, backward compatibility with older \nwww.EBooksWorld.ir\n28 Chapter 2—Architectural Design\nversions of systems, and so on. An example of a technical constraint is the use of \nopen  source  technologies,  whereas  a  nontechnical  constraint  is  that  the  system  \nmust obey the Sarbanes-Oxley Act or that it must be delivered by December 15.\nA constraint is a decision over which you have little or no control as an ar-","metadata":{"id":221}}],["46615f78-6472-479b-a94b-a43660d82cde",{"pageContent":"must obey the Sarbanes-Oxley Act or that it must be delivered by December 15.\nA constraint is a decision over which you have little or no control as an ar-\nchitect. Your job is, as we mentioned in Chapter 1, to satisfice: to design the best \nsystem  that  you  can,  despite  the  constraints  you  face.  Sometimes  you  might  be  \nable to argue for loosening a constraint, but in most cases you have no choice but \nto design around the constraints.\n2.5 Design Concepts: The Building Blocks for Creating \nStructures\nDesign  is  not  random,  but  rather  is  planned,  intentional,  rational,  and  directed.  \nThe process of design may seem daunting at first. When facing the “blank page” \nat the beginning of any design activity, the space of possibilities might seem im-\npossibly huge and complex. However, there is some help here. The software ar-\nchitecture community has created and evolved, over the course of decades, a body","metadata":{"id":222}}],["a37f195e-c48d-4f85-9403-133d0f8568e6",{"pageContent":"possibly huge and complex. However, there is some help here. The software ar-\nchitecture community has created and evolved, over the course of decades, a body \nof  generally  accepted  design  principles  that  can  guide  us  to  create  high-quality  \ndesigns with predictable outcomes.\nFor example, some well-documented design principles are oriented toward \nthe achievement of specific quality attributes:\n§\tTo help achieve high modifiability, aim for good modularity, which means \nhigh cohesion and low coupling.\n§\tTo help achieve high availability, avoid having any single point of failure.\n§\tTo help achieve scalability, avoid having any hard-coded limits for critical \nresources.\n§\tTo help achieve security, limit the points of access to critical resources.\n§\tTo help achieve testability, externalize state.\n§\t. . . and so forth.\nIn  each  case,  these  principles  have  been  evolved  over  decades  of  dealing","metadata":{"id":223}}],["f0df9bcd-7a2a-4acf-877d-eb055d9916ac",{"pageContent":"§\tTo help achieve testability, externalize state.\n§\t. . . and so forth.\nIn  each  case,  these  principles  have  been  evolved  over  decades  of  dealing  \nwith  those  quality  attributes  in  practice.  In  addition,  we  have  evolved  reusable  \nrealizations  of  these  abstract  approaches  in  design  and,  eventually,  in  code.  We  \ncall these reusable realizations design concepts, and they are the building blocks \nfrom  which  the  structures  that  make  up  the  architecture  are  created.  Different  \ntypes of design concepts exist, and here we discuss some of the most commonly \nused,  including  reference  architectures,  deployment  patterns,  architectural  pat-\nterns, tactics, and externally developed components (such as frameworks). While \nthe first four are conceptual in nature, the last one is concrete.\nwww.EBooksWorld.ir\n2.5 Design Concepts: The Building Blocks for Creating Structures 29\n2.5.1 Reference Architectures","metadata":{"id":224}}],["2083fbcc-315a-4d9e-8731-299f980b2b0d",{"pageContent":"the first four are conceptual in nature, the last one is concrete.\nwww.EBooksWorld.ir\n2.5 Design Concepts: The Building Blocks for Creating Structures 29\n2.5.1 Reference Architectures\nReference  architectures  are  blueprints  that  provide  an  overall  logical  structure  \nfor particular types of applications. A reference architecture is a reference model \nmapped  onto  one  or  more  architectural  patterns.  It  has  been  proven  in  business  \nand technical contexts, and typically comes with a set of supporting artifacts that \neases its use.\nAn example of a reference architecture for the development of web applica-\ntions is shown in Figure 2.3 on the next page. This reference architecture estab-\nlishes  the  main  layers  for  this  type  of  application—presentation,  business,  and  \ndata—as  well  as  the  types  of  elements  that  occur  within  the  layers  and  the  re-\nsponsibilities  of  these  elements,  such  as  UI  components,  business  components,","metadata":{"id":225}}],["75eda82e-0192-4d67-a90b-5c4f1b06e911",{"pageContent":"data—as  well  as  the  types  of  elements  that  occur  within  the  layers  and  the  re-\nsponsibilities  of  these  elements,  such  as  UI  components,  business  components,  \ndata  access  components,  service  agents,  and  so  on.  Also,  this  reference  archi-\ntecture  introduces  cross-cutting  concerns,  such  as  security  and  communication,  \nthat  need  to  be  addressed.  As  this  example  shows,  when  you  select  a  reference  \narchitecture for your application, you also adopt a set of issues that you need to \naddress during design. You may not have an explicit requirement related to com-\nmunications or security, but the fact that these elements are part of the reference \narchitecture require you to make design decisions about them.\nReference architectures may be confused with architectural styles, but these \ntwo  concepts  are  different.  Architectural  styles  (such  as  “Pipe  and  Filter”  and","metadata":{"id":226}}],["b6fec3e6-13ea-411f-9892-7c71917b8638",{"pageContent":"Reference architectures may be confused with architectural styles, but these \ntwo  concepts  are  different.  Architectural  styles  (such  as  “Pipe  and  Filter”  and  \n“Client Server”) define types of components and connectors in a specified topol-\nogy  that  are  useful  for  structuring  an  application  either  logically  or  physically.  \nSuch  styles  are  technology  and  domain  agnostic.  Reference  architectures,  in  \ncontrast,  provide  a  structure  for  applications  in  specific  domains,  and  they  may  \nembody different styles. Also, while architectural styles tend to be popular in ac-\nademia, reference architectures seem to be preferred by practitioners—which is \nalso why we favor them in our list of design concepts.\nWhile there are many reference architectures, we are not aware of any cata-\nlog that contains an extensive list of them.\n2.5.2 Architectural Design Patterns\nDesign patterns are conceptual solutions to recurring design problems that exist","metadata":{"id":227}}],["c22dbb61-252e-48eb-bb17-d4ae3c3e585e",{"pageContent":"log that contains an extensive list of them.\n2.5.2 Architectural Design Patterns\nDesign patterns are conceptual solutions to recurring design problems that exist \nin a defined context. While design patterns originally focused on decisions at the \nobject  scale,  including  instantiation,  structuring,  and  behavior,  today  there  are  \ncatalogs  with  patterns  that  address  decisions  at  varying  levels  of  granularity.  In  \naddition, there are specific patterns to address quality attributes such as security \nor integration.\nWhile some people argue for the differentiation between what they consider \nto be architectural patterns and the more fine-grained design patterns, we believe \nthere is no principled difference that can be solely attributed to scale. We consider \na pattern to be architectural when its use directly and substantially influences the \nsatisfaction of some of the architectural drivers (see Section 2.2).\nwww.EBooksWorld.ir\n30 Chapter 2—Architectural Design","metadata":{"id":228}}],["9dd7fbdd-dbc1-4725-8915-ef915b5acb11",{"pageContent":"satisfaction of some of the architectural drivers (see Section 2.2).\nwww.EBooksWorld.ir\n30 Chapter 2—Architectural Design\nFIGURE 2.3 Example reference architecture for the development of web \napplications from the Microsoft Application Architecture Guide (Key: UML)\nFigure  2.4  shows  an  example  architectural  pattern  that  is  useful  for  struc-\nturing  the  system,  the  Layers  pattern.  When  you  choose  a  pattern  such  as  this  \nwww.EBooksWorld.ir\n2.5 Design Concepts: The Building Blocks for Creating Structures 31\none, you must decide how many layers you will need for your system. Figure 2.5 \nshows a pattern to support concurrency, which is useful to increase performance. \nThis pattern, too, needs to be instantiated—that is, it needs to be adapted to the \nspecific problem and design context. Instantiation is discussed in Chapter 3.\nAlthough reference architectures may be considered as a type of pattern, \nwe prefer to consider them separately because of the important role they play","metadata":{"id":229}}],["40c2cbc4-11db-4465-a120-874df31738eb",{"pageContent":"Although reference architectures may be considered as a type of pattern, \nwe prefer to consider them separately because of the important role they play \nin  structuring  an  application  and  because  they  are  more  directly  connected  to  \ntechnology  stacks.  Also,  a  reference  architecture  typically  incorporates  other  \npatterns and often constrains these patterns. For example, the reference archi-\ntecture  for  web  applications  shown  in  Figure  2.3  incorporates  the  Layers  pat-\ntern but also establishes how many layers need to be used. This reference archi-\ntecture also incorporates other patterns such as an Application Facade and Data \nAccess Components.\nFIGURE 2.4 The Layers pattern for structuring an application from Pattern-\nOriented Software Architecture\nwww.EBooksWorld.ir\n32 Chapter 2—Architectural Design\nFIGURE 2.5 The Half-Sync/Half-Async pattern to support concurrency from \nPattern-Oriented Software Architecture (Source: Softserve)\n2.5.3 Deployment Patterns","metadata":{"id":230}}],["2202e7d2-5503-4785-abff-5f03c3807511",{"pageContent":"32 Chapter 2—Architectural Design\nFIGURE 2.5 The Half-Sync/Half-Async pattern to support concurrency from \nPattern-Oriented Software Architecture (Source: Softserve)\n2.5.3 Deployment Patterns\nAnother type of pattern that we prefer to consider separately is deployment pat-\nterns. These patterns provide models on how to physically structure the system to \ndeploy it. Some deployment patterns, such as the one shown in Figure 2.6, are use-\nful to establish an initial physical structure of the system in terms of tiers (phys-\nical  nodes).  More  specialized  deployment  patterns,  such  as  the  Load-Balanced  \nCluster  in  Figure  2.7,  are  used  to  satisfy  quality  attributes  such  as  availability,  \nperformance, and security.\nwww.EBooksWorld.ir\n2.5 Design Concepts: The Building Blocks for Creating Structures 33\nFIGURE 2.6 Four-tier deployment pattern from the Microsoft Application \nArchitecture Guide (Key: UML)\nFIGURE 2.7 Load-Balanced Cluster deployment pattern for performance from the","metadata":{"id":231}}],["85cc797a-05a0-494a-9914-7b86d518da9e",{"pageContent":"FIGURE 2.6 Four-tier deployment pattern from the Microsoft Application \nArchitecture Guide (Key: UML)\nFIGURE 2.7 Load-Balanced Cluster deployment pattern for performance from the \nMicrosoft Application Architecture Guide (Key: UML)\nIn general, an initial structure for the system is obtained by mapping the log-\nical elements that are obtained from reference architectures (and other patterns) \ninto the physical elements defined by deployment patterns.\n2.5.4    Tactics\nArchitects  can  use  collections  of  fundamental  design  techniques  to  achieve  a  re-\nsponse for particular quality attributes. We call these architectural design primitives \ntactics. Tactics, like design patterns, are techniques that architects have been using \nfor years. We do not invent tactics, but simply capture what architects actually have \ndone in practice, over the decades, to manage quality attribute response goals.\nwww.EBooksWorld.ir\n34 Chapter 2—Architectural Design\nEvents\narrive\nResponse\ngenerated\nwithin time\nconstraints","metadata":{"id":232}}],["d35ca24f-405c-47a1-84f2-ce8ee745e277",{"pageContent":"done in practice, over the decades, to manage quality attribute response goals.\nwww.EBooksWorld.ir\n34 Chapter 2—Architectural Design\nEvents\narrive\nResponse\ngenerated\nwithin time\nconstraints\nTactics\nto control\nperformance\nFIGURE 2.8 Tactics mediate events and responses.\nTactics are design decisions that influence the control of a quality attribute \nresponse.  For  example,  if  you  want  to  design  a  system  to  have  low  latency  or  \nhigh throughput, you could make a set of design decisions that would mediate the \narrival  of  events  (requests  for  service),  resulting  in  responses  that  are  produced  \nwithin some time constraints, as shown in Figure 2.8.\nTactics are both simpler and more primitive than patterns. They focus on the \ncontrol of a single quality attribute response (although they may, of course, trade \noff  this  response  with  other  quality  attribute  goals).  Patterns,  in  contrast,  typi-\ncally focus on resolving and balancing multiple forces—that is, multiple quality","metadata":{"id":233}}],["2826d443-69e8-43ae-b6d6-2ba28bad0e5b",{"pageContent":"off  this  response  with  other  quality  attribute  goals).  Patterns,  in  contrast,  typi-\ncally focus on resolving and balancing multiple forces—that is, multiple quality \nattribute goals. By way of analogy, we can say that a tactic is an atom, whereas a \npattern is a molecule.\nTactics  provide  a  top-down  way  of  thinking  about  design.  A  tactics  cate-\ngorization begins with a set of design objectives related to the achievement of a \nquality  attribute,  and  presents  the  architect  with  a  set  of  options  from  which  to  \nchoose. These options then need to be further instantiated through some combi-\nnation of patterns, frameworks, and code.\nFor example, in Figure 2.9, the design objectives for performance are “Con-\ntrol  Resource  Demand”  and  “Manage  Resources”.  An  architect  who  wants  to  \ncreate a system with “good” performance needs to choose one or more of these \noptions.  That  is,  the  architect  needs  to  decide  if  controlling  resource  demand  is","metadata":{"id":234}}],["75df1105-f6f7-4801-89c0-882dc919c90c",{"pageContent":"create a system with “good” performance needs to choose one or more of these \noptions.  That  is,  the  architect  needs  to  decide  if  controlling  resource  demand  is  \nfeasible, and if managing resources is feasible. In some systems, the events arriv-\ning at the system can be managed, prioritized, or limited in some way. If this is \nnot possible, then the architect can manage resources only as part of an attempt \nto  generate  responses  within  acceptable  time  constraints.  Within  the  “Manage  \nResources” category, an architect might choose to increase resources, introduce \nconcurrency, maintain multiple copies of computations, maintain multiple copies \nof data, and so forth. These tactics then need to be instantiated. As an example, \nan architect might choose the Half-Sync/Half-Async pattern (see Figure 2.5) as \na way of introducing (and managing) concurrency, or the Load-Balanced Cluster \ndeployment pattern (see Figure 2.7) to maintain multiple copies of computations.","metadata":{"id":235}}],["2516c45d-6a11-40ca-b6c5-fa18f632e756",{"pageContent":"a way of introducing (and managing) concurrency, or the Load-Balanced Cluster \ndeployment pattern (see Figure 2.7) to maintain multiple copies of computations. \nAs we will see in Chapter 3, the choice, combination, and tailoring of tactics and \nwww.EBooksWorld.ir\n2.5 Design Concepts: The Building Blocks for Creating Structures 35\npatterns are some of the key steps of the ADD process. There are existing tactics \ncategorizations  for  the  quality  attributes  of  availability,  interoperability,  modifi-\nability, performance, security, testability, and usability.\n2.5.5 Externally Developed Components\nPatterns  and  tactics  are  abstract  in  nature.  However,  when  you  are  designing  \na  software  architecture,  you  need  to  make  these  design  concepts  concrete  and  \ncloser to the actual implementation. There are two ways to achieve this: You can \ncode the elements obtained from tactics and patterns or you can associate tech-","metadata":{"id":236}}],["c0ecffa9-6733-47d7-bc59-a28faa9082c7",{"pageContent":"closer to the actual implementation. There are two ways to achieve this: You can \ncode the elements obtained from tactics and patterns or you can associate tech-\nnologies  with  one  or  more  of  these  elements  in  the  architecture.  This  “buy  ver-\nsus  build”  choice  is  one  of  the  most  important  decisions  you  will  make  as  an  \narchitect.\nWe  consider  technologies  to  be  externally  developed  components,  because  \nthey  are  not  created  as  part  of  the  development  project.  Several  types  of  exter-\nnally developed components exist:\n§\tTechnology families. A technology family represents a group of spe-\ncific technologies with common functional purposes. It can serve as a \nPerformance Tactics\nControl Resource DemandManage Resources\nManage sampling rate\nEvents \nArrive\nResponse \nGenerated \nwithin \nTime \nConstraints\nLimit event response\nPrioritize events\nReduce overhead\nBound execution times\nIncrease resource \nefficiency\nIncrease resources\nIntroduce concurrency\nMaintain multiple","metadata":{"id":237}}],["a5a0d89c-96f5-4129-8a57-22e1f4192ba1",{"pageContent":"Response \nGenerated \nwithin \nTime \nConstraints\nLimit event response\nPrioritize events\nReduce overhead\nBound execution times\nIncrease resource \nefficiency\nIncrease resources\nIntroduce concurrency\nMaintain multiple \ncopies of computations\nMaintain multiple \ncopies of data\nBound queue sizes\nSchedule resources\nFIGURE 2.9 Performance tactics from Software Architecture in Practice\nwww.EBooksWorld.ir\n36 Chapter 2—Architectural Design\nplaceholder until a specific product or framework is selected. An example is \na relational database management system (RDBMS) or an object-oriented \nto relational mapper (ORM). Figure 2.10 shows different technology fami-\nlies in the Big Data domain (in regular text).\n§\tProducts. A product (or software package) refers to a self-contained func-\ntional piece of software that can be integrated into the system that is being \ndesigned and that requires only minor configuration or coding. An example \nis a relational database management system, such as Oracle or Microsoft","metadata":{"id":238}}],["8bc7fb3c-6499-48b7-b1b4-926a71db657a",{"pageContent":"designed and that requires only minor configuration or coding. An example \nis a relational database management system, such as Oracle or Microsoft \nSQL Server. Figure 2.10 shows different products in the Big Data domain \n(in italics).\n§\tApplication frameworks. An application framework (or just framework) is \na reusable software element, constructed out of patterns and tactics, that \nprovides generic functionality addressing recurring domain and quality \nattribute concerns across a broad range of applications. Frameworks, when \ncarefully chosen and properly implemented, increase the productivity of \nprogrammers. They do so by enabling programmers to focus on business \nlogic and end-user value, rather than underlying technologies and their im-\nplementations. As opposed to products, framework functions are generally \ninvoked from the application code or are “injected” using some type of \naspect-oriented approach. Frameworks usually require extensive configura-","metadata":{"id":239}}],["1b6eacc4-f23b-4191-b78c-db529845dbfe",{"pageContent":"invoked from the application code or are “injected” using some type of \naspect-oriented approach. Frameworks usually require extensive configura-\ntion, typically through XML files or other approaches such as annotations \nin Java. A framework example is Hibernate, which is used to perform ob-\nject-oriented to relational mapping in Java. Several types of frameworks \nare available: Full-stack frameworks, such as Spring, are usually associated \nwith reference architectures and address general concerns across the differ-\nent elements of the reference architecture, while non-full-stack frameworks, \nsuch as JSF, address specific functional or quality attribute concerns.\n§\tPlatforms. A platform provides a complete infrastructure upon which to \nbuild and execute applications. Examples of platforms include Java, .Net, or \nand Google Cloud.\nThe selection of externally developed components, which is a key aspect of \nthe design process, can be a challenging task because of their extensive number.","metadata":{"id":240}}],["d03f60ae-1fbc-47a6-a2c0-4d48ccc585f0",{"pageContent":"and Google Cloud.\nThe selection of externally developed components, which is a key aspect of \nthe design process, can be a challenging task because of their extensive number. \nHere are a few criteria you should consider when selecting externally developed \ncomponents:\n§\tProblem that it addresses. Is it something specific, such as a framework for \nobject-oriented to relational mapping or something more generic, such as a \nplatform?\n§\tCost. What is the cost of the license and, if it is free, what is the cost of sup-\nport and education?\n§\tType of license. Does it have a license that is compatible with the project \ngoals?\nwww.EBooksWorld.ir\n2.5 Design Concepts: The Building Blocks for Creating Structures 37\nBig Data Analytics Catalog\nIntegration\nMessaging\nData Collector\nApache Flume\nLogstash\nFluentd\nApache Kafka\nRabbitMQ\nAmazon SQS\nApache ActiveMQ\nHBase\nCassandra\nNeo4J\nOrientDB\nHP Vertica\nTeradata\nMS PDW\nAmazon Redshift\nStreamSets\nTalend\nInformatica\nMongoDB\nCouchDB\nRiak\nRedis\nBerkeley DB\nMS SQL Server\nQlikView\nMicrostrategy\nTableau","metadata":{"id":241}}],["8f55a075-7fe9-4a85-8c79-37e0881d501d",{"pageContent":"Amazon SQS\nApache ActiveMQ\nHBase\nCassandra\nNeo4J\nOrientDB\nHP Vertica\nTeradata\nMS PDW\nAmazon Redshift\nStreamSets\nTalend\nInformatica\nMongoDB\nCouchDB\nRiak\nRedis\nBerkeley DB\nMS SQL Server\nQlikView\nMicrostrategy\nTableau\nTibco JasperSoft\nPentaho\nOracle RDBMS\nIBM DB2\nSplunk\nSplunk\nKibana\nZoomdata\nD3.js\nGoJS\nHighcharts\nImpala\nApache Hive (Stinger)\nApache Solr\nElasticsearch\nHadoop MapReduce\nApache Tez\nApache Spark\nApache Storm\nSpark Streaming\nAmazon Kinesis\nApache Samza\nCascading\nApache Crunch\nAmazon Pig\nApache Hive\nSpark SQL\nHDFS\nCassandraFS\nDistributed Message Broker\nETL/Data Integration Engine\nDocument-Oriented\nKey-Value\nGraph-Oriented\nMPP Analytic RDBMS\nTraditional Analytic RDBMS\nBI Platform\nInteractive Dashboard\nInteractive Query Engine\nDistributed Search Engine\nDistributed Computing Engine\nEvent Stream Processor\nData Processing Framework\nGraphic Library\nColumn-Family\nETL/ELT\nDistributed File System\nNoSQL Database\nAnalytic RDBMS\nVisualization & Reporting\nSearch & Query\nProcessing\nData Storage\nProcessing and \nAnalytics\nStraight text  –  a technology family","metadata":{"id":242}}],["921eb4bf-8767-41ba-aafc-c8a471e2def7",{"pageContent":"Column-Family\nETL/ELT\nDistributed File System\nNoSQL Database\nAnalytic RDBMS\nVisualization & Reporting\nSearch & Query\nProcessing\nData Storage\nProcessing and \nAnalytics\nStraight text  –  a technology family\nItalic text  –  a specific technology \nLegend:\nFIGURE 2.10 A technology family tree for the Big Data application domain\nwww.EBooksWorld.ir\n38 Chapter 2—Architectural Design\n§\tSupport. Is it well supported? Is there extensive documentation about the \ntechnology? Is there an extensive user or developer community that you can \nturn to for advice?\n§\tLearning curve. How hard is it to learn this technology? Have others in \nyour organization already mastered it? Are there courses available?\n§\tMaturity. Is it a technology that has just appeared on the market, which may \nbe exciting but still relatively unstable or unsupported?\n§\tPopularity. Is it a relatively widespread technology? Are there positive testi-\nmonials or adoption by mature organizations? Will it be easy to hire people","metadata":{"id":243}}],["edbbbfd5-337c-4144-9ea5-d776acd0005e",{"pageContent":"§\tPopularity. Is it a relatively widespread technology? Are there positive testi-\nmonials or adoption by mature organizations? Will it be easy to hire people \nwho have deep knowledge of it? Is there an active developer community or \nuser group?\n§\tCompatibility and ease of integration. Is it compatible with other technolo-\ngies used in the project? Can it be integrated easily in the project?\n§\tSupport for critical quality attributes. Does it limit attributes such as per-\nformance? Is it secure and robust?\n§\tSize. Will the use of the technology have a negative impact on the size of \nthe application under development?\nUnfortunately,  the  answers  to  these  questions  are  not  always  easy  to  find  \nand the selection of a particular technology may require you do some research or, \neventually, to create prototypes that will help you in the selection process. These \ncriteria will have a significant effect on your total cost of ownership.\n2.6 Architecture Design Decisions","metadata":{"id":244}}],["97f55da1-2aa3-44ce-ba61-b4c8f10dbbe4",{"pageContent":"eventually, to create prototypes that will help you in the selection process. These \ncriteria will have a significant effect on your total cost of ownership.\n2.6 Architecture Design Decisions\nAs we said at the beginning of this chapter, design is the process of making de-\ncisions.  But  the  act  of  making  a  decision  is  a  process,  not  a  moment  in  time.  \nExperienced architects, when faced with a design challenge, typically entertain a \nset of “candidate” decisions (as shown in Figure 2.1); from this set, they choose a \nbest candidate and instantiate that. They might select this “best” candidate based \non experience, constraints, or some form of analysis such as prototyping or sim-\nulation.  The  reality  is  that  an  architect  will  often  make  a  choice  and  “ride  the  \nhorse  until  it  drops”—that  is,  commit  to  a  decision  and  revisit  it  only  if  it  ap-\npears to be compromising the success of the project. These decisions have serious \nconsequences!","metadata":{"id":245}}],["c6437200-820c-424a-8e44-05464ba0e7f6",{"pageContent":"horse  until  it  drops”—that  is,  commit  to  a  decision  and  revisit  it  only  if  it  ap-\npears to be compromising the success of the project. These decisions have serious \nconsequences!\nRecall  that,  in  the  early  stages  of  design,  decisions  focus  on  the  biggest,  \nmost critical choices that will have substantial downstream consequences: refer-\nence architectures, major technologies (such as frameworks), and patterns. Ref-\nerence architectures, deployment patterns, and other kinds of patterns have been \nwidely  discussed—there  are  many  books,  websites,  and  conferences  devoted  to  \nthe  creation  and  validation  of  patterns  and  pattern  languages.  Nevertheless,  the  \nwww.EBooksWorld.ir\n2.6 Architecture Design Decisions 39\noutput  of  these  activities  is  always  a  set  of  documented  patterns.  Interpreting  \nthe  patterns  from  a  pattern  catalog  is  a  critical  part  of  the  selection  activity  for","metadata":{"id":246}}],["cf141de9-e7bd-4ef0-a3d8-b022246e3de7",{"pageContent":"output  of  these  activities  is  always  a  set  of  documented  patterns.  Interpreting  \nthe  patterns  from  a  pattern  catalog  is  a  critical  part  of  the  selection  activity  for  \nan  architect.  Each  candidate  pattern  must  be  chosen  and  its  instantiation  must  \nbe analyzed. For example, if you chose the Layers pattern from Figure 2.4, you \nwould  still  have  many  decisions  to  make:  how  many  layers  there  will  be,  how  \nstrict the layering will be, which specific services will be placed into each layer, \nwhat  the  interfaces  between  these  functions  will  be,  and  so  forth.  If  you  chose  \nthe Load-Balanced Cluster deployment pattern from Figure 2.7, you would have \nto decide how many servers will be balanced, how many load balancers you will \nuse,  where  these  servers  and  load  balancers  will  physically  reside,  which  kinds  \nof networks will connect these servers, which form of encryption you will use on","metadata":{"id":247}}],["c911ca70-e17a-43c9-abc2-14b8c46bf1ce",{"pageContent":"use,  where  these  servers  and  load  balancers  will  physically  reside,  which  kinds  \nof networks will connect these servers, which form of encryption you will use on \nthose network connections, which form of health monitoring the load balancers \nwill employ, and so forth. These decisions are important and will affect the suc-\ncess of the instantiated pattern, so they need to be analyzed. In addition, the qual-\nity of the implementation of these decisions will affect the success of the pattern. \nAs we like to quip, the architecture giveth and the implementation taketh away.\nFurthermore, the many catalogs and web pages that present design concepts \nuse different conventions and notations. The focus of our book is on the design \nmethod  and  how  it  can  be  used  with  these  external  sources.  For  this  reason  we  \njust take examples from outside sources and show them here as they were origi-\nnally presented. This book is not intended to be another design patterns catalog—","metadata":{"id":248}}],["76ab1524-d5d2-4956-b9ca-f25038bf4b01",{"pageContent":"just take examples from outside sources and show them here as they were origi-\nnally presented. This book is not intended to be another design patterns catalog—\nwe want to alert you to the presence of these catalogs and show how they can be \nan  incredibly  useful  resource  for  an  architect,  but  they  must  be  interpreted  and  \nused with care! In fact, one of your many jobs as an architect is to understand and \ninterpret these catalogs, with their different notations and conventions. This is the \nreality that you will have to deal with.\nFinally, once a design decision has been made, you should think about how \nyou will document it. You could, of course, do no documentation. This is, in fact, \nwhat  is  most  common  in  practice.  Architectural  concepts  are  often  vague  and  \nconveyed  informally,  in  “tribal  knowledge”:  personal  communications,  emails,  \nnaming  conventions,  and  so  forth.  Alternatively,  you  could  create  and  maintain","metadata":{"id":249}}],["418df842-2e07-455f-b867-8ca2867e64fc",{"pageContent":"conveyed  informally,  in  “tribal  knowledge”:  personal  communications,  emails,  \nnaming  conventions,  and  so  forth.  Alternatively,  you  could  create  and  maintain  \nfull,  formal  documentation,  as  is  done  for  some  projects  with  demanding  qual-\nity attribute requirements, such as safety-critical or high-security systems. If you \nare designing flight-control software, you will probably end up at this end of the \nspectrum.  In  between  these  endpoints  is  a  broad  set  of  possibilities,  and  in  this  \nspace we see less formal (and less costly) forms of architecture documentation, \nsuch as sketches (as we will discuss in Section 3.7).\nThe decision of what, when, and how to document should be risk based. You \nshould ask yourself: What is the risk of not documenting this decision? Could it \nbe  misinterpreted  and  undermined  by  future  developers?  Could  it  contribute  to  \nnear-term or long-term problems in the system? For example, if the rationale for","metadata":{"id":250}}],["ddbfc286-6eb0-4e15-af52-6f5c242be6c6",{"pageContent":"be  misinterpreted  and  undermined  by  future  developers?  Could  it  contribute  to  \nnear-term or long-term problems in the system? For example, if the rationale for \nlayering  is  not  carefully  documented,  the  layering  will  inevitably  break  down,  \nlosing  coherence  and  tending  toward  increased  coupling.  Over  time,  this  trend  \nwww.EBooksWorld.ir\n40 Chapter 2—Architectural Design\nwill  increase  the  system’s  technical  debt,  making  it  harder  to  find  and  fix  bugs  \nor add new features. To take another example, if the rationale for allocation of a \ncritical  resource  is  not  documented,  that  resource  might  become  an  unintended  \ncontention area, resulting in bottlenecks and failures.\n2.7    Summary\nIn this chapter, we introduced the idea of design as a set of decisions to satisfy \nrequirements  and  constraints.  We  also  introduced  the  notion  of  “architectural”  \ndesign and showed that it does not differ from design in general, other than that it","metadata":{"id":251}}],["78572a90-6b51-48b0-ab3e-2c3a2cd68163",{"pageContent":"requirements  and  constraints.  We  also  introduced  the  notion  of  “architectural”  \ndesign and showed that it does not differ from design in general, other than that it \naddresses the satisfaction of architectural drivers: the purpose, primary function-\nality, quality attribute requirements, architectural concerns, and constraints. What \nmakes  a  decision  “architectural”?  A  decision  is  architectural  if  it  has  nonlocal  \nconsequences and those consequences matter to the achievement of an architec-\ntural driver.\nWe  also  discussed  why  architectural  design  is  so  important:  because  it  is  \nthe embodiment of early, far-reaching, hard-to-change decisions. These decisions \nwill help you meet your architectural drivers, will determine much of your proj-\nect’s work-breakdown structure, and will affect the tools, skills, and technologies \nneeded to realize the system. Thus architectural design decisions should be scru-","metadata":{"id":252}}],["a3fcfae6-4a45-489f-95b5-68902a79d51d",{"pageContent":"ect’s work-breakdown structure, and will affect the tools, skills, and technologies \nneeded to realize the system. Thus architectural design decisions should be scru-\ntinized well, as their consequences are profound. In addition, architecture is a key \nenabler of agility.\nArchitectural design is guided by certain principles. For example, to achieve \ngood modularity, high coupling, and low cohesion, the wise architect will prob-\nably include some form of layering in the architecture being designed. Similarly, \nto  achieve  high  availability,  an  architect  will  likely  choose  a  pattern  involving  \nsome form of redundancy and failover, such as active–passive redundancy, where \nan  active  server  sends  real-time  updates  to  a  passive  server,  so  that  the  passive  \nserver can replace the active server in case it fails, with no loss of state.\nDesign  concepts,  such  as  reference  architectures,  deployment  patterns,  ar-","metadata":{"id":253}}],["e8111173-d032-4ddf-b569-889844b8ec8d",{"pageContent":"server can replace the active server in case it fails, with no loss of state.\nDesign  concepts,  such  as  reference  architectures,  deployment  patterns,  ar-\nchitectural patterns, tactics, and externally developed components, are the build-\ning blocks of design, and they form the foundation for architectural design as it is \nperformed using ADD. As you will see in our step-by-step explanation of ADD in \nChapter 3, some of the most important design decisions that an architect makes \nare  how  design  concepts  are  selected,  how  they  are  instantiated,  and  how  they  \nare  combined.  Also,  in  Appendix  A,  we  present  a  design  concepts  catalog  that  \nincludes several instances of the design concepts presented here.\nFrom these foundations, an architecture can be confidently and predictably \nconstructed.\nwww.EBooksWorld.ir\n2.8 Further Reading 41\n2.8 Further Reading\nA more in-depth treatment of scenarios and architectural drivers can be found in","metadata":{"id":254}}],["52b2d6cf-a49b-4806-8acf-519aeab55cbd",{"pageContent":"constructed.\nwww.EBooksWorld.ir\n2.8 Further Reading 41\n2.8 Further Reading\nA more in-depth treatment of scenarios and architectural drivers can be found in \nL. Bass, P. Clements, and R. Kazman, Software Architecture in Practice, 3rd ed., \nAddison-Wesley, 2012. Also found in this book is an extensive discussion of ar-\nchitectural tactics, which are useful in guiding an architecture to achieve quality \nattribute goals. Likewise, this book contains an extensive discussion of QAW and \nUtility Trees.\nThe  Mission  Thread  Workshop  is  discussed  in  R.  Kazman,  M.  Gagliardi,  \nand  W.  Wood,  “Scaling  Up  Software  Architecture  Analysis”,  Journal  of  Sys-\ntems  and  Software,  85,  1511–1519,  2012;  and  in  M.  Gagliardi,  W.  Wood,  and  \nT. Morrow, Introduction to the Mission Thread Workshop, Software Engineering \nInstitute Technical Report CMU/SEI-2013-TR-003, 2013.\nAn  overview  of  discovery  prototyping,  JRP,  JAD,  and  accelerated  systems","metadata":{"id":255}}],["2bf2a25e-6cae-4e43-9871-6ebac0644881",{"pageContent":"Institute Technical Report CMU/SEI-2013-TR-003, 2013.\nAn  overview  of  discovery  prototyping,  JRP,  JAD,  and  accelerated  systems  \nanalysis  can  be  found  in  any  competent  book  on  systems  analysis  and  design,  \nsuch  as  J.  Whitten  and  L.  Bentley,  Systems  Analysis  and  Design  Methods,  7th \ned., McGraw-Hill, 2007. The combination of architectural approaches with Agile \nmethods will be discussed in Chapter 9.\nA catalog of reference architectures and deployment patterns appears in the \nbook by the Microsoft Patterns and Practices Team: Microsoft® Application Ar-\nchitecture Guide, 2nd ed., Microsoft Press, 2009. This book also provides an ex-\ntensive  list  of  architectural  concerns  associated  with  the  reference  architectures  \nthat are documented.\nAn extensive collection of architectural design patterns for the construction \nof distributed systems can be found in F. Buschmann, K. Henney, and D. Schmidt,","metadata":{"id":256}}],["8e40ee31-fcea-4e36-845b-2e0a30512e1b",{"pageContent":"that are documented.\nAn extensive collection of architectural design patterns for the construction \nof distributed systems can be found in F. Buschmann, K. Henney, and D. Schmidt, \nPattern-Oriented  Software  Architecture  Volume  4:  A  Pattern  Language  for  Dis-\ntributed  Computing,  Wiley,  2007.  Other  books  in  the  POSA  (Patterns  Of  Soft-\nware Architecture) series provide additional pattern catalogs. Many other pattern \ncatalogs specializing in particular application domains and technologies exist. A \nfew examples are listed here:\n§\tE. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns: Ele-\nments of Reusable Object-Oriented Software. Addison-Wesley, 1995.\n§\tM. Fowler. Patterns of Enterprise Application Architecture. Addi-\nson-Wesley, 2003.\n§\tE. Fernandez-Buglioni. Security Patterns in Practice: Designing Secure \nArchitectures Using Software Patterns. Wiley, 2013.\n§\tG. Hohpe and B. Woolf. Enterprise Integration Patterns: Designing, Build-","metadata":{"id":257}}],["bcaf3667-1934-4d9e-bd72-c1de479de55e",{"pageContent":"§\tE. Fernandez-Buglioni. Security Patterns in Practice: Designing Secure \nArchitectures Using Software Patterns. Wiley, 2013.\n§\tG. Hohpe and B. Woolf. Enterprise Integration Patterns: Designing, Build-\ning, and Deploying Messaging Solutions. Addison-Wesley, 2004.\nThe evaluation and selection of software packages is discussed in A. Jadhav \nand R. Sonar, “Evaluating and Selecting Software Packages: A Review”, Journal \nof Information and Software Technology, 51, 555–563, 2009.\nwww.EBooksWorld.ir\n42 Chapter 2—Architectural Design\nThe   “bible”   for   software   architecture   documentation   is   P.   Clements,   \nF.  Bachmann,  L.  Bass,  D.  Garlan,  J.  Ivers,  R.  Little,  P.  Merson,  R.  Nord,  and  \nJ.  Stafford,  Documenting  Software  Architectures:  Views  and  Beyond,  2nd  ed.,  \nAddison-Wesley, 2011.\nThe technology family tree for the Big Data application domain is based on the \nSmart  Decisions  Game  by  H.  Cervantes,  S.  Haziyev,  O.  Hrytsay,  and  R.  Kazman,","metadata":{"id":258}}],["26da12a4-2c68-4d4c-a2ad-5797ef655f74",{"pageContent":"Addison-Wesley, 2011.\nThe technology family tree for the Big Data application domain is based on the \nSmart  Decisions  Game  by  H.  Cervantes,  S.  Haziyev,  O.  Hrytsay,  and  R.  Kazman,  \nwhich can be found at http://smartdecisionsgame.com.\nwww.EBooksWorld.ir\n43\n3\nThe Architecture Design \nProcess\nIn  this  chapter  we  provide  a  detailed  discussion  of  ADD,  the  design  method  \nthat is the focus of this book. We begin with an overview of the method and of \neach  one  of  its  steps.  This  overview  is  followed  by  more  detailed  discussions  \nof  different  aspects  that  need  to  be  considered  when  performing  these  steps.  \nWe suggest different roadmaps that provide guidance on when different types \nof  design  concepts  can  be  used  depending  on  which  type  of  system  is  being  \ndesigned.  We  also  discuss  the  identification  and  selection  of  design  concepts,  \nthe production of structures from these design concepts, the definition of inter-","metadata":{"id":259}}],["4be4aaa3-b55c-4999-a3d1-4194bc3172e0",{"pageContent":"designed.  We  also  discuss  the  identification  and  selection  of  design  concepts,  \nthe production of structures from these design concepts, the definition of inter-\nfaces, the production of preliminary documentation, and, finally, a technique to \ntrack design progress.\n3.1 The Need for a Principled Method\nIn Chapter 2, we discussed the various concepts associated with design. The ques-\ntion is, how do you actually perform design? Performing design to ensure that the \ndrivers are satisfied requires a principled method. By “principled”, we refer to a \nmethod that takes into account all of the relevant aspects that are needed to pro-\nduce an adequate design. Such a method provides guidance that is necessary to \nguarantee that your drivers are satisfied. To achieve this goal in a cost-effective, \nwww.EBooksWorld.ir\n44 Chapter 3—The Architecture Design Process\nrepeatable way, you need a method that guides you in combining and incorporat-\ning reusable design concepts.","metadata":{"id":260}}],["b36114be-a3be-4377-b501-70d29a2b4bb2",{"pageContent":"www.EBooksWorld.ir\n44 Chapter 3—The Architecture Design Process\nrepeatable way, you need a method that guides you in combining and incorporat-\ning reusable design concepts.\nPerforming design adequately is important because architecture design de-\ncisions  have  significant  consequences  at  different  points  in  a  project’s  lifetime.  \nFor  example,  during  a  pre-sales  phase,  an  appropriate  design  will  allow  for  a  \nbetter  estimation  of  cost,  scope,  and  schedule.  During  development,  an  appro-\npriate design will be helpful to avoid later rework and facilitate development and \ndeployment. Finally, a clear understanding of what architectural design involves \nis necessary to better manage aspects of technical debt.\n3.2 Attribute-Driven Design 3.0\nArchitecture design is performed in a series of rounds across the development of a \nsoftware project. Each design round may take place within a project increment such","metadata":{"id":261}}],["1ded56ac-541c-4c9c-b122-4231dd38c27a",{"pageContent":"3.2 Attribute-Driven Design 3.0\nArchitecture design is performed in a series of rounds across the development of a \nsoftware project. Each design round may take place within a project increment such \nas a sprint. Within these rounds, a series of design iterations is performed. Perhaps \nthe  most  important  characteristic  of  the  ADD  method  is  that  it  provides  detailed,  \nstep-by-step guidance on the tasks that have to be performed inside the design it-\nerations (see Chapter 7 for a comparison with other design methods). When ADD \nappeared, it was the first method to focus specifically on quality attributes and their \nachievement  through  the  selection  of  different  types  of  structures  and  their  repre-\nsentation  through  views.  Another  important  contribution  of  ADD  was  that  it  rec-\nognized that analysis and documentation are an integral part of the design process. \nAlthough ADD was and is a major contribution in the field of software architecture,","metadata":{"id":262}}],["e3800aa3-d1ce-4d0d-8694-3682468552f5",{"pageContent":"ognized that analysis and documentation are an integral part of the design process. \nAlthough ADD was and is a major contribution in the field of software architecture, \nwe believe that its adoption within the practitioner community has been limited by \na number of inherent weaknesses, as discussed in Section 1.4.\nADD has been used successfully for more than 15 years. The world of soft-\nware  has  changed  dramatically  since  ADD’s  introduction,  however,  and  even  \nmore since version 2.0 was published in 2006. For this reason, and to address the \nweaknesses of version 2.0, we have decided to create ADD 3.0. Henceforth, we \nwill simply refer to this method as ADD. Figure 3.1 shows the steps and artifacts \nassociated with ADD and in the following subsections we provide an overview of \nthe activities in each of its steps.\n3.2.1 Step 1: Review Inputs\nBefore starting a design round, you need make sure that the inputs to the design","metadata":{"id":263}}],["c5cd7992-282a-4fa4-b0d5-228d89cf3b63",{"pageContent":"the activities in each of its steps.\n3.2.1 Step 1: Review Inputs\nBefore starting a design round, you need make sure that the inputs to the design \nprocess  are  available  and  correct.  First,  you  need  to  ensure  that  you  are  clear  \nabout the purpose for the design activities that will ensue. The purpose may be, \nfor example, to produce a design for early estimation, to refine an existing design \nto build a new increment of the system, or to design and generate a prototype to \nmitigate certain technical risks (see Section 2.4.1 for a discussion of the design \nwww.EBooksWorld.ir\n3.2 Attribute-Driven Design 3.0 45\npurpose). Also, you need to make sure that the other drivers needed for the design \nactivity are available. These include primary functional requirements, quality at-\ntribute scenarios, architectural constraints, and concerns. Finally, if this is not the \nfirst design round, or if this is not greenfield development, an additional input that","metadata":{"id":264}}],["e5c59b44-4b50-4d57-9595-b893dc1dc9a4",{"pageContent":"tribute scenarios, architectural constraints, and concerns. Finally, if this is not the \nfirst design round, or if this is not greenfield development, an additional input that \nyou need to consider is the existing architecture design.\nAt this point, we assume that primary functionality and quality attribute sce-\nnarios have been prioritized, ideally by your most important project stakeholders. \n(If  not,  there  are  techniques  that  you  can  employ  to  elicit  and  prioritize  them,  as  \ndiscussed in Sections 2.4.2 and 2.4.3.) You, as the architect, must now “own” these \ndrivers. You need to check, for example, whether any important stakeholders were \noverlooked in the original requirements elicitation process, or whether any business \nconditions have changed since the prioritization was performed. These drivers re-\nally do “drive” design, so getting them right and getting their priority right is cru-\ncial. We cannot stress this point strongly enough. Software architecture design, like","metadata":{"id":265}}],["0f600a97-e02a-41ff-8a8b-b9459881c42f",{"pageContent":"ally do “drive” design, so getting them right and getting their priority right is cru-\ncial. We cannot stress this point strongly enough. Software architecture design, like \nLegend:\nFIGURE 3.1 Steps and artifacts of ADD version 3.0\nwww.EBooksWorld.ir\n46 Chapter 3—The Architecture Design Process\nmost activities in software engineering, is a “garbage in, garbage out” process. The \nresults of ADD cannot be good if the inputs are poorly formed.\nAs a rule of thumb, you should be able to start designing if, besides the de-\nsign purpose, constraints, and initial architectural concerns, you have established \nthe  primary  use  cases  and  the  most  important  quality  attribute  scenarios.  This,  \nof course, does not mean you will make decisions only about these drivers: You \nstill need to address other quality attribute scenarios, use cases and architectural \nconcerns, but these can be treated later on.\nThe drivers become part of an architectural design backlog that you should","metadata":{"id":266}}],["c105f513-b857-4e9f-9fff-dcabb0a63bf1",{"pageContent":"concerns, but these can be treated later on.\nThe drivers become part of an architectural design backlog that you should \nuse to perform the different design iterations. We discuss this idea in more depth \nin Section 3.8.1.\n3.2.2 Step 2: Establish the Iteration Goal by Selecting Drivers\nA  design  round  represents  the  architecture  design  activities  performed  within  a  \ndevelopment cycle if an iterative development model is used, or the whole set of \narchitecture design activities if a waterfall model is used. Through one or more \nrounds, you produce an architecture that suits the established design purpose.\nA  design  round  is  generally  performed  in  a  series  of  design  iterations,  where  \neach iteration focuses on achieving a particular goal. Such a goal typically involves \ndesigning to satisfy a subset of the drivers. For example, an iteration goal could be to \ncreate structures from elements that will support a particular performance scenario,","metadata":{"id":267}}],["3d308067-dc07-4a4d-a388-fcdd6ff413c1",{"pageContent":"designing to satisfy a subset of the drivers. For example, an iteration goal could be to \ncreate structures from elements that will support a particular performance scenario, \nor that will enable a use case to be achieved. For this reason, when performing de-\nsign, you need to establish a goal before you start a particular design iteration.\nAs we will discuss in Section 3.3, depending on the type of system whose \narchitecture  is  being  designed,  there  may  be  a  “best”—or  at  least  strongly  sug-\ngested—ordering  of  the  iteration  goals  that  need  to  be  addressed.  For  example,  \nfor a greenfield system in a mature domain, your initial goal is typically to iden-\ntify an overall structure for the system by choosing a reference architecture.\n3.2.3 Step 3: Choose One or More Elements of the System to Refine\nSatisfying  drivers  requires  you  to  produce  one  or  more  architectural  structures.","metadata":{"id":268}}],["a440762b-7bcd-42ef-bfc0-41a0f0ba90a3",{"pageContent":"3.2.3 Step 3: Choose One or More Elements of the System to Refine\nSatisfying  drivers  requires  you  to  produce  one  or  more  architectural  structures.  \nThese  structures  are  composed  of  interrelated  elements,  and  those  elements  are  \ngenerally obtained by refining other elements that you previously identified in an \nearlier iteration. Refinement can mean decomposition into finer-grained elements \n(top-down  approach),  combination  of  elements  into  coarser-grained  elements  \n(bottom-up  approach),  or  improvement  of  previously  identified  elements.  For  \ngreenfield development, you can start by establishing the system context and then \nselecting  the  only  available  element—that  is,  the  system  itself—for  refinement  \nby  decomposition.  For  existing  systems  or  for  later  design  iterations  in  green-\nfield systems, you normally choose to refine elements that were identified in prior \niterations.\nwww.EBooksWorld.ir\n3.2 Attribute-Driven Design 3.0 47","metadata":{"id":269}}],["69154dd3-0e28-4b95-93f4-dd062ee60107",{"pageContent":"field systems, you normally choose to refine elements that were identified in prior \niterations.\nwww.EBooksWorld.ir\n3.2 Attribute-Driven Design 3.0 47\nThe  elements  that  you  will  select  are  the  ones  that  are  involved  in  the  sat-\nisfaction  of  specific  drivers.  For  this  reason,  when  design  is  performed  for  an  \nexisting system, you need to have a good understanding of the elements that are \npart of the as-built architecture of the system. This may involve some “detective \nwork”, reverse engineering, or discussions with developers.\nWe have presented steps 2 and 3 in the order they appear in the method. That \nis to say, step 2 precedes step 3. However, in some cases you may need to reverse \nthis order. For example, when designing a greenfield system or when fleshing out \ncertain types of reference architectures (as we will show in Chapter 5), you will, \nat least in the early stages of design, focus on elements of the system and start the","metadata":{"id":270}}],["e47e5b3a-14f9-4e07-92c4-498328725b17",{"pageContent":"certain types of reference architectures (as we will show in Chapter 5), you will, \nat least in the early stages of design, focus on elements of the system and start the \niteration by selecting a particular element and then consider the drivers that you \nwant to address.\n3.2.4 Step 4: Choose One or More Design Concepts That Satisfy \nthe Selected Drivers\nChoosing  the  design  concepts  is  probably  the  most  difficult  decision  you  will  \nface in the design process, because it requires you to identify alternatives among \ndesign  concepts  that  can  be  used  to  achieve  your  iteration  goal,  and  to  make  a  \nselection  from  these  alternatives.  As  we  saw  in  Section  2.5,  different  types  of  \ndesign  concepts  exist,  and,  for  each  type,  there  may  be  many  options.  This  can  \nresult in a considerable number of alternatives that need to be analyzed to make a \nchoice. In Section 3.4, we discuss the identification and selection of design con-\ncepts in more detail.","metadata":{"id":271}}],["c4a53bd3-a42a-451d-91c4-28c3a3d2bf40",{"pageContent":"result in a considerable number of alternatives that need to be analyzed to make a \nchoice. In Section 3.4, we discuss the identification and selection of design con-\ncepts in more detail.\n3.2.5 Step 5: Instantiate Architectural Elements, Allocate \nResponsibilities, and Define Interfaces\nOnce  you  have  selected  one  or  more  design  concepts,  you  must  make  another  \ndesign decision, which involves instantiating elements out of the design concepts \nthat  you  selected.  For  example,  if  you  selected  the  Layers  pattern  as  a  design  \nconcept, you must decide how many layers will be used, since the pattern itself \ndoes not prescribe a specific number. In this example, the layers are the elements \nthat  are  instantiated.  In  certain  cases,  instantiation  can  mean  configuration.  For  \nexample,  you  may  have  dedicated  an  iteration  to  selecting  technologies  and  as-\nsociating them with the elements in your design. In further iterations, you might","metadata":{"id":272}}],["1b637b66-ac7d-4271-ac85-daaf04929a71",{"pageContent":"example,  you  may  have  dedicated  an  iteration  to  selecting  technologies  and  as-\nsociating them with the elements in your design. In further iterations, you might \nrefine  these  elements  by  making  finer-grained  decisions  about  how  they  should  \nbe configured to support a particular driver, such as a quality attribute.\nAfter  instantiating  the  elements,  you  need  to  allocate  responsibilities  to  \neach  of  them.  For  example,  in  a  typical  web-based  enterprise  system,  at  least  \nthree  layers  are  usually  present:  the  presentation  layer,  the  business  layer,  and  \nthe data layer. The responsibilities of these layers differ: The responsibilities of \nwww.EBooksWorld.ir\n48 Chapter 3—The Architecture Design Process\nthe presentation layer include managing all of the user interactions, whereas the \nresponsibilities of the data layer include managing the persistence of data.\nInstantiating  elements  is  just  one  of  the  tasks  you  need  to  perform  to  cre-","metadata":{"id":273}}],["5529d5c4-fdf1-41d8-a621-4d40cbdbbe3f",{"pageContent":"responsibilities of the data layer include managing the persistence of data.\nInstantiating  elements  is  just  one  of  the  tasks  you  need  to  perform  to  cre-\nate  structures  that  satisfy  a  driver  or  a  concern.  The  elements  that  have  been  \ninstantiated  also  need  to  be  connected,  to  allow  them  to  collaborate  with  one  \nanother.  This  requires  the  existence  of  relationships  between  the  elements  and  \nthe  exchange  of  information  through  some  kind  of  interface.  The  interface  is  a  \ncontractual specification of how information should flow between the elements. \nSection 3.5 provides more details on how the different types of design concepts \nare  instantiated  and  how  structures  are  created,  and  Section  3.6  discusses  how  \ninterfaces can be defined.\n3.2.6 Step 6: Sketch Views and Record Design Decisions\nAt this point, you have finished performing the design activities for the iteration.","metadata":{"id":274}}],["03e5c761-520e-486a-9e9f-21ae41b4809d",{"pageContent":"interfaces can be defined.\n3.2.6 Step 6: Sketch Views and Record Design Decisions\nAt this point, you have finished performing the design activities for the iteration. \nNevertheless, you may not have taken any actions to ensure that the views—the \nrepresentations of the structures you created—are preserved. For instance, if you \nperformed the previous step in a conference room, you probably ended up with a \nseries of diagrams on a whiteboard. This information is essential, and you need to \ncapture it so that you can later analyze and communicate it to other stakeholders.\nThe  views  that  you  have  created  are  almost  certainly  incomplete,  so  these  \ndiagrams may need to be revisited and refined in a subsequent iteration. This is \ntypically  done  to  accommodate  elements  resulting  from  other  design  decisions  \nthat  you  will  make  to  support  additional  drivers.  This  factor  explains  why  we  \nspeak of “sketching” the views in ADD—that is, creating a preliminary type of","metadata":{"id":275}}],["ff7966be-bfb2-4f8a-8e6f-d33b01f3c8d8",{"pageContent":"that  you  will  make  to  support  additional  drivers.  This  factor  explains  why  we  \nspeak of “sketching” the views in ADD—that is, creating a preliminary type of \ndocumentation. The more formal, more fully fleshed-out documentation of these \nviews—should you choose to produce them—occurs only after a number of de-\nsign iterations have been finished (as part of the architectural documentation ac-\ntivity discussed in Section 1.2.2).\nIn addition to storing the sketches of the views, you should record the sig-\nnificant decisions that are made in the design iteration, and the reasons that led \nto these decisions (i.e., the rationale), to facilitate later analysis and understand-\ning of the decisions. For example, decisions about important tradeoffs might be \nrecorded at this time. During a design iteration, decisions are primarily made in \nsteps 4 and 5. Section 3.7 provides further information on how to create prelimi-","metadata":{"id":276}}],["2e188181-1cc0-498a-a77a-776f86178420",{"pageContent":"recorded at this time. During a design iteration, decisions are primarily made in \nsteps 4 and 5. Section 3.7 provides further information on how to create prelimi-\nnary documentation during design, including creating sketches, recording design \ndecisions and their rationale.\n3.2.7 Step 7: Perform Analysis of Current Design and Review \nIteration Goal and Achievement of Design Purpose\nBy  the  time  you  reach  step  7,  you  should  have  created  a  partial  design  that  ad-\ndresses the goal established for the iteration. Making sure that this is actually the \nwww.EBooksWorld.ir\n3.3 Following a Design Roadmap According to System Type  49\ncase  is  a  good  idea,  so  as  to  avoid  unhappy  stakeholders  and  later  rework.  You  \ncan  perform  the  analysis  yourself  by  reviewing  the  sketches  of  the  views  and  \ndesign  decisions  that  you  recorded,  but  an  even  better  idea  is  to  have  someone","metadata":{"id":277}}],["eb2b52c3-0b2c-4d07-bf34-19d93dc3653d",{"pageContent":"can  perform  the  analysis  yourself  by  reviewing  the  sketches  of  the  views  and  \ndesign  decisions  that  you  recorded,  but  an  even  better  idea  is  to  have  someone  \nelse  help  you  review  this  design.  We  do  this  for  the  same  reason  that  organiza-\ntions frequently have a separate testing/quality assurance group: Another person \nwill not share your assumptions, and will have a different experience base and a \ndifferent perspective. Pulling in someone with a different point of view can help \nyou find “bugs”, in both code and architecture. We discuss analysis in more depth \nin Chapter 8.\nOnce  the  design  performed  in  the  iteration  has  been  analyzed,  you  should  \nreview the state of your architecture in terms of the established design purpose. \nThis means considering if, at this point, you have performed enough design iter-\nations to satisfy the drivers that are associated with the design round as well as","metadata":{"id":278}}],["8ecfb66e-bfd0-4bd6-85a0-ba1b22f61c55",{"pageContent":"This means considering if, at this point, you have performed enough design iter-\nations to satisfy the drivers that are associated with the design round as well as \nconsidering  whether  the  design  purpose  has  been  achieved  or  if  additional  de-\nsign rounds are needed in future project increments. Section 3.8 describes simple \ntechniques that allow you to keep track of design progress.\n3.2.8 Iterate If Necessary\nIdeally, you should perform additional iterations and repeat steps 2 to 7 for every \ndriver that was considered as part of the input. More often than not, such itera-\ntions  are  not  possible  because  of  time  or  resource  constraints  that  force  you  to  \nstop  the  design  activities  and  move  on  to  the  next  activities  in  the  development  \nprocess—typically implementation.\nWhat are the criteria for evaluating if more design iterations are necessary? \nWe let risk be our guide. You should at least have addressed the drivers with the","metadata":{"id":279}}],["c1bfa47e-2687-4c12-9afe-7b0287176c4a",{"pageContent":"process—typically implementation.\nWhat are the criteria for evaluating if more design iterations are necessary? \nWe let risk be our guide. You should at least have addressed the drivers with the \nhighest priorities. Ideally, you should have assured that critical drivers are satis-\nfied or, at least, that the design is “good enough” to satisfy them. Finally, when \nperforming iterative development, you can choose to perform one design round \nin  every  project  iteration.  The  first  rounds  should  focus  on  addressing  the  driv-\ners, while subsequent rounds focus on making design decisions for other require-\nments that were not selected as drivers but that need to be addressed nonetheless.\n3.3 Following a Design Roadmap According  \nto  System Type\nWhen writing, you might have experienced the much-dreaded “fear of the blank \npage”.  Similarly,  when  you  start  designing  an  architecture,  you  may  face  a  sit-","metadata":{"id":280}}],["f455040a-8601-4f37-8ad3-f578abcfbaa0",{"pageContent":"to  System Type\nWhen writing, you might have experienced the much-dreaded “fear of the blank \npage”.  Similarly,  when  you  start  designing  an  architecture,  you  may  face  a  sit-\nuation  in  which  you  ask  yourself,  “How  do  I  begin  designing?”  To  answer  this  \nquestion, you need to consider which type of system you are designing.\nwww.EBooksWorld.ir\n50 Chapter 3—The Architecture Design Process\nDesign of software systems falls into three broad categories: (1) the design \nof a greenfield system for a mature (i.e., well-known) domain; (2) the design of a \ngreenfield system for a domain that is novel (i.e., a domain that has a less estab-\nlished infrastructure and knowledge base); and (3) the design for making changes \nto an existing system (brownfield). Each one of these categories involves a differ-\nent roadmap in terms of the sequence of goals that you should perform across the \ndesign iterations.\n3.3.1 Design of Greenfield Systems for Mature Domains","metadata":{"id":281}}],["6f33c2da-1193-413b-bb64-96a32e0863de",{"pageContent":"ent roadmap in terms of the sequence of goals that you should perform across the \ndesign iterations.\n3.3.1 Design of Greenfield Systems for Mature Domains\nThe design of a greenfield system for a mature domain occurs when you are de-\nsigning  an  architecture  for  a  system  that  is  built  from  “scratch”  and  when  this  \ntype  of  system  is  well  known  and  understood—that  is,  when  there  is  an  estab-\nlished  infrastructure  of  tools  and  technologies,  and  an  associated  knowledge  \nbase. Examples of mature domains include the following:\n§\tTraditional desktop applications\n§\tInteractive applications that run on a mobile device\n§\tEnterprise applications accessed from a web browser, which store informa-\ntion in a relational database, and which provide support for partially or fully \nautomating business processes\nSince these types of applications are relatively common, some general archi-\ntectural  concerns  associated  with  their  design  are  well  known,  well  supported,","metadata":{"id":282}}],["d0ee7ede-f87a-46f7-88ed-707421569260",{"pageContent":"automating business processes\nSince these types of applications are relatively common, some general archi-\ntectural  concerns  associated  with  their  design  are  well  known,  well  supported,  \nand well documented. If you are designing a new system that falls into this cate-\ngory, we recommend the following roadmap (shown in Figure 3.2).\nThe goal of your initial design iteration(s) should be to address the general \narchitectural  concern  of  establishing  an  initial  overall  system  structure.  Is  this  \nto  be  a  three-tier  client-server  application,  a  peer-to-peer  application,  a  mobile  \napp  connecting  to  a  Big  Data  back-end,  and  so  on?  Each  of  these  options  will  \nlead you to different architectural solutions, and these solutions will help you to \nachieve your drivers. To achieve this iteration goal, you will select some design \nconcepts. Specifically, you will typically choose one or more reference architec-","metadata":{"id":283}}],["0e68821b-511e-47a0-99c3-5a24b15cfc50",{"pageContent":"achieve your drivers. To achieve this iteration goal, you will select some design \nconcepts. Specifically, you will typically choose one or more reference architec-\ntures  and  deployment  patterns  (see  Sections  2.5.1  and  2.5.3).  You  may  also  se-\nlect  some  externally  developed  components,  such  as  frameworks.  The  types  of  \nframeworks  that  are  typically  chosen  in  early  iterations  are  either  “full-stack”  \nframeworks that are associated with the selected reference architectures, or more \nspecific  frameworks  that  are  associated  with  elements  established  by  the  refer-\nence architecture (see Section 2.5.5). In this first iteration, you should review all \nof  your  drivers  to  select  the  design  concepts,  but  you  will  probably  pay  more  \nattention  to  the  constraints  and  to  quality  attributes  that  are  not  associated  with  \nspecific functionalities and that favor particular reference architectures or require","metadata":{"id":284}}],["5dc63c36-8f62-4e5a-92ea-7ebb13f7c2c7",{"pageContent":"attention  to  the  constraints  and  to  quality  attributes  that  are  not  associated  with  \nspecific functionalities and that favor particular reference architectures or require \nparticular  deployment  configurations.  Consider  an  example:  If  you  select  a  ref-\nerence architecture for Big Data systems, you have presumably chosen a quality \nwww.EBooksWorld.ir\n3.3 Following a Design Roadmap According to System Type  51\nattribute  such  as  low  latency  with  high  data  volumes  as  your  most  important  \ndriver. Of course, you will make many subsequent decisions to flesh out this early \nchoice, but this driver has already exerted a great influence on your design such \nas the selection of a particular reference architecture.\nThe  goal  of  your  next  design  iteration(s)  should  be  to  identify  structures  \nthat  support  the  primary  functionality.  As  noted  in  Section  2.4.3,  allocation  of","metadata":{"id":285}}],["86c22122-4c7d-4f32-98bf-ffce9f2874af",{"pageContent":"The  goal  of  your  next  design  iteration(s)  should  be  to  identify  structures  \nthat  support  the  primary  functionality.  As  noted  in  Section  2.4.3,  allocation  of  \nfunctionality  (i.e.,  use  cases  or  user  stories)  to  elements  is  an  important  part  of  \narchitectural  design  because  it  has  critical  downstream  implications  for  modifi-\nability and allocation of work to teams. Furthermore, once functionality has been \nallocated, the elements that support it can be refined in later iterations to support \nthe  quality  attributes  associated  with  these  functionalities.  For  example,  a  per-\nformance  scenario  may  be  associated  with  a  particular  use  case.  Achieving  the  \nperformance goal may require making design decisions across all of the elements \nthat participate in the achievement of this use case. To allocate functionality, you \nusually refine the elements that are associated with the reference architecture by","metadata":{"id":286}}],["d8f6df6b-5a3b-4a62-8ac4-8f9a4681449e",{"pageContent":"that participate in the achievement of this use case. To allocate functionality, you \nusually refine the elements that are associated with the reference architecture by \ndecomposing them. A particular use case may require the identification of mul-\ntiple  elements.  For  example,  if  you  have  selected  a  web  application  reference  \narchitecture, supporting a use case will probably require you to identify modules \np\n2\n1\n3..n\nLegend:\nFIGURE 3.2 Design concept selection roadmap for greenfield systems\nwww.EBooksWorld.ir\n52 Chapter 3—The Architecture Design Process\nacross the different layers associated with this reference architecture. Finally, at \nthis point you should also be thinking about allocating functionality—associated \nwith modules—to (teams of) developers.\nThe goal of your subsequent design iterations should be to refine the struc-\ntures you have previously created to fully address the remaining drivers. Address-","metadata":{"id":287}}],["c7865ea7-8920-41b1-873c-1f0bb585fbda",{"pageContent":"with modules—to (teams of) developers.\nThe goal of your subsequent design iterations should be to refine the struc-\ntures you have previously created to fully address the remaining drivers. Address-\ning these drivers, and especially quality attributes, will likely require you to use \nthe  three  major  categories  of  design  concepts—tactics,  patterns,  and  externally  \ndeveloped components such as frameworks—as well as commonly accepted de-\nsign best practices such as modularity, low coupling, and high cohesion. For ex-\nample, to (partially) satisfy a performance requirement for the search use case in \na web application, you might select the “maintain multiple copies of data” tactic \nand implement this tactic by configuring a cache in a framework that is used in-\nside an element responsible for persisting data.\nThis  roadmap  is  appropriate  for  the  initial  project  iterations,  but  it  is  also  \nextremely useful for early project estimation activities (see the discussion about","metadata":{"id":288}}],["c544e971-a809-4311-8a00-c0770371860d",{"pageContent":"This  roadmap  is  appropriate  for  the  initial  project  iterations,  but  it  is  also  \nextremely useful for early project estimation activities (see the discussion about \nthe architecture design process during pre-sales in Section 9.1.1). Why have we \ncreated  such  a  roadmap?  First,  because  the  process  of  starting  an  architectural  \ndesign  is  always  complex.  Second,  because  many  of  the  steps  in  this  roadmap  \nare frequently overlooked or done in an intuitive and ad hoc way, rather than in \na  well-considered,  reflective  way.  Third,  because  different  types  of  design  con-\ncepts exist, and it is not always clear at which point in the design they should be \nused. This roadmap encapsulates best practices that we have observed in the most \ncompetent architecture organizations. Simply put, the use of a roadmap results in \nbetter architectures, particularly for less mature architects.\n3.3.2 Design of Greenfield Systems for Novel Domains","metadata":{"id":289}}],["33eeffe0-348f-4266-952a-4815bbd28898",{"pageContent":"competent architecture organizations. Simply put, the use of a roadmap results in \nbetter architectures, particularly for less mature architects.\n3.3.2 Design of Greenfield Systems for Novel Domains\nIn the case of novel domains, it is more challenging to establish a precise road-\nmap, because reference architectures may not exist and there may be few, if any, \nexternally  developed  components  that  you  can  use.  You  are,  more  than  likely,  \nworking from first principles and creating your own home-grown solutions. Even \nin  this  case,  however,  general-purpose  design  concepts  such  as  tactics  and  pat-\nterns  can  guide  you,  aided  by  strategic  prototyping.  In  essence,  your  iteration  \ngoals will mostly be to continuously refine previously created structures to fully \naddress the drivers.\nMany  times,  your  design  goal  will  focus  on  the  creation  of  prototypes  so  \nthat  you  can  explore  possible  solutions  to  the  challenge  that  you  are  facing.  In","metadata":{"id":290}}],["c4e90e8c-2902-46fd-b831-74fe6a494278",{"pageContent":"Many  times,  your  design  goal  will  focus  on  the  creation  of  prototypes  so  \nthat  you  can  explore  possible  solutions  to  the  challenge  that  you  are  facing.  In  \nparticular, you may need to focus on quality attributes and design challenges ori-\nented toward issues such as performance, scalability, or security. We discuss the \ncreation of prototypes in Section 3.4.2.\nOf  course,  the  notion  of  “novel”  is  fluid.  Mobile  application  development  \nwas a novel domain 10 or 15 years ago, but now it is a well-established field.\nwww.EBooksWorld.ir\n3.4 Identifying and Selecting Design Concepts 53\n3.3.3 Design for an Existing System (Brownfield)\nArchitecture design for an existing system may occur for different purposes. The \nmost  obvious  is  maintenance—that  is,  when  you  need  to  satisfy  new  require-\nments or correct issues, and doing so requires changes to the architecture of an \nexisting system. You may also be making architectural changes to an existing sys-","metadata":{"id":291}}],["0495fec6-da52-4e6f-8e12-490301f0df63",{"pageContent":"ments or correct issues, and doing so requires changes to the architecture of an \nexisting system. You may also be making architectural changes to an existing sys-\ntem for the purpose of refactoring. When refactoring, you change the architecture \nof an existing system, without altering its functions, to reduce technical debt, to \nintroduce technology updates, or to fix quality attribute problems (e.g., the sys-\ntem is too slow, or insecure, or frequently crashes).\nTo  be  able  to  choose  elements  to  decompose  as  part  of  the  design  process  \n(step  3  of  ADD),  you  need  to  first  identify  which  elements  are  present  in  the  \narchitecture of the existing system. In this sense, before starting the design itera-\ntions, your first goal should be to make sure that you have a clear understanding \nof the existing architecture of the system.\nOnce  you  understand  the  elements,  properties,  and  relationships  that  con-","metadata":{"id":292}}],["86771dc5-d341-42eb-acc3-2058ffaae144",{"pageContent":"of the existing architecture of the system.\nOnce  you  understand  the  elements,  properties,  and  relationships  that  con-\nstitute the architecture of the system, and the characteristics of the existing code \nbase, you can perform design similar to what is done for greenfield systems after \nthe initial design iteration. Your design iteration goals here will be to identify and \nrefine structures to satisfy architectural drivers, including new functionality and \nquality  attributes,  and  to  address  specific  architectural  concerns.  These  design  \niterations  will  typically  not  involve  establishing  a  new  overall  system  structure  \nunless you are dealing with a major refactoring.\nIt might seem that the preceding discussion of the different contexts of de-\nsign is rather abstract and perhaps even confusing. In the next three chapters we \nwill  be  presenting  examples  of  design  of  a  system  in  a  mature  domain  (Chap-","metadata":{"id":293}}],["58812188-fd9a-4879-89aa-3a2058450c11",{"pageContent":"sign is rather abstract and perhaps even confusing. In the next three chapters we \nwill  be  presenting  examples  of  design  of  a  system  in  a  mature  domain  (Chap-\nter 4), design for a system in a relatively novel domain (Chapter 5), and design to \nmodify an existing system (Chapter 6). These extended examples will make the \npreviously described concepts clearer and more concrete.\n3.4 Identifying and Selecting Design Concepts\nFreeman Dyson, the English physicist, once said the following: “A good scientist \nis  a  person  with  original  ideas.  A  good  engineer  is  a  person  who  makes  a  design  \nthat  works  with  as  few  original  ideas  as  possible”.  This  quotation  is  particularly  \nrelevant in the context of software architecture design: Most of the time you don’t \nneed to, and shouldn’t, reinvent the wheel. Rather, your major design activities are \nto  identify  and  select  design  concepts  to  address  the  challenges  and  drivers  that","metadata":{"id":294}}],["a0e16013-2ea9-4468-ad6b-d1ac9abc1e23",{"pageContent":"need to, and shouldn’t, reinvent the wheel. Rather, your major design activities are \nto  identify  and  select  design  concepts  to  address  the  challenges  and  drivers  that  \nyou encounter across the design iterations. Design is still an original and creative \nendeavor, but the creativity resides in the appropriate identification of these existing \nsolutions and then on combining and adapting them to the problem at hand.\nwww.EBooksWorld.ir\n54 Chapter 3—The Architecture Design Process\n3.4.1 Identification of Design Concepts\nThe identification of design concepts can appear to be daunting, because of the \nvast number of design concepts that exist. There are likely dozens of design pat-\nterns  and  externally  developed  components  that  you  could  use  to  address  any  \nparticular issue. To make things worse, these design concepts are scattered across \nmany different sources: in the popular press, in research literature, in books, and","metadata":{"id":295}}],["5a84d705-8653-4a2c-bad6-126e79eba5d4",{"pageContent":"particular issue. To make things worse, these design concepts are scattered across \nmany different sources: in the popular press, in research literature, in books, and \non  the  Internet.  Moreover,  in  many  cases,  there  is  no  canonical  definition  of  a  \nconcept. Different sites, for example, will define the Broker pattern in different, \nlargely  informal,  ways.  Finally,  once  you  have  identified  the  alternatives  that  \nmight potentially help you achieve the design goals of the iteration, you need to \nselect among them.\nTo identify which design concepts you need at a particular point, you should \nconsider what we previously discussed regarding the design roadmap. Different \npoints  in  the  design  process  usually  require  different  types  of  design  concepts.  \nFor  example,  when  you  are  designing  a  greenfield  system  in  a  mature  domain,  \nthe types of design concepts that will help you initially structure the system are","metadata":{"id":296}}],["955178a1-f8e2-48c7-b05e-d16645dbafb2",{"pageContent":"For  example,  when  you  are  designing  a  greenfield  system  in  a  mature  domain,  \nthe types of design concepts that will help you initially structure the system are \nreference  architectures  and  deployment  patterns.  As  you  progress  in  the  design  \nprocess, you will use all of the categories of design concepts: tactics, architecture \nand design patterns, and externally developed components. Keep in mind that to \naddress a specific design problem, you can and often will use and combine differ-\nent types of design concepts. For example, when addressing a security driver, you \nmay employ a security pattern, a security tactic, a security framework, or some \ncombination of these.\nOnce you have more clarity regarding the types of design concepts that you \nwish  to  use,  you  still  need  to  identify  alternatives—that  is,  design  candidates.  \nThere are several ways to do so, although you will probably use a combination of \nthese techniques rather than a single one:","metadata":{"id":297}}],["5ee4cd74-b2b8-4a7d-8008-df07846a37d1",{"pageContent":"There are several ways to do so, although you will probably use a combination of \nthese techniques rather than a single one:\n§\tLeverage existing best practices. You can identify alternatives for your \nrequired design concepts by making use of catalogs that are available in \nprinted or online form. Some design concepts, such as patterns, are exten-\nsively documented; others, such as externally developed components, are \ndocumented in a less thorough way. The benefits of this approach are that \nyou can identify many alternatives, and that you can leverage the consider-\nable knowledge and experience of others. The downsides are that searching \nfor and studying the information can require a considerable amount of time, \nthe quality of the documented knowledge is often unknown, and the as-\nsumptions and biases of the authors are unknown.\n§\tLeverage your own knowledge and experience. If the system you are de-\nsigning is similar to other systems you have designed in the past, you will","metadata":{"id":298}}],["895b9f15-813f-4933-948f-0478d5ee9c83",{"pageContent":"sumptions and biases of the authors are unknown.\n§\tLeverage your own knowledge and experience. If the system you are de-\nsigning is similar to other systems you have designed in the past, you will \nprobably want to begin with some of the design concepts that you have \nused before. The benefit of this approach is that the identification of al-\nternatives is performed rapidly and confidently. The downside is that you \nmay end up using the same ideas repeatedly, even if they are not the most \nwww.EBooksWorld.ir\n3.4 Identifying and Selecting Design Concepts 55\nappropriate for all the design problems that you are facing, and if they have \nbeen superseded by newer, better approaches. As the saying goes, “If you \ngive a small child a hammer, all the world looks like a nail”.\n§\tLeverage the knowledge and experience of others. As an architect, you have \nbackground and knowledge that you have gained through the years. This \nfoundation varies from person to person, especially if the types of design","metadata":{"id":299}}],["14a6783c-599e-410b-82f7-d7c4d30ff2f1",{"pageContent":"background and knowledge that you have gained through the years. This \nfoundation varies from person to person, especially if the types of design \nproblems they have addressed in the past differ. You can leverage this in-\nformation by performing the identification and selection of design concepts \nwith some of your peers through brainstorming.\n3.4.2 Selection of Design Concepts\nOnce you have identified a list of alternative design concepts, you need to select \nwhich one is the most appropriate to solve the design problem at hand. You can \nachieve this in a relatively simple way, by creating a table that lists the pros and \ncons associated with each alternative and selecting one of the alternatives based \non those criteria and your drivers. The table can also include other criteria, such \nas the cost associated with the use of the alternative. Table 3.1 shows an example \nof such a table used to support the selection of different reference architectures.","metadata":{"id":300}}],["c8f879ec-46af-4af1-9619-58b2db566703",{"pageContent":"as the cost associated with the use of the alternative. Table 3.1 shows an example \nof such a table used to support the selection of different reference architectures.\nYou may also need to perform a more in-depth analysis to select the alterna-\ntive. Methods such as CBAM (cost benefit analysis method) or SWOT (strengths, \nweaknesses, opportunities, threats) can help you to perform this analysis (see the \nsidebar “The Cost Benefit Analysis Method”).\nTABLE 3.1 Example of a Table to Support the Selection of Alternatives\nName of \nAlternativeProsConsCost\nWeb \napplication\nCan be accessed from a \nvariety of platforms using \na standard web browser\nFast page loading\nSimple deployment\nDoes not support “rich” \ninteraction\nLow\nRich Internet \napplication\nSupports “rich” user \ninteraction\nSimple deployment and \nupdating\nLonger page loading times\nRequires a runtime \nenvironment to be installed \non the client browser\nMedium\nMobile \napplication\nSupports “rich” user \ninteraction\nLess portability\nScreen limitations\nHigh\nwww.EBooksWorld.ir","metadata":{"id":301}}],["a27754a4-d9dc-4016-b829-9774178d95db",{"pageContent":"Requires a runtime \nenvironment to be installed \non the client browser\nMedium\nMobile \napplication\nSupports “rich” user \ninteraction\nLess portability\nScreen limitations\nHigh\nwww.EBooksWorld.ir\n56 Chapter 3—The Architecture Design Process\nThe Cost Benefit Analysis Method\nThe CBAM is a method that guides the selection of design alternatives \nusing a quantitative approach. This method considers that architectural \nstrategies (i.e., combinations of design concepts) affect quality attribute \nresponses, and that the level of each response in turn provides system \nstakeholders with some benefit called utility. Each architectural strategy \nprovides a different level of utility, but also has a cost and takes time to im-\nplement. The idea behind the CBAM is that by studying levels of utility and \ncosts of implementation, particular architectural strategies can be selected \nbased on their associated return on investment (ROI). The CBAM was \nconceived to be performed after an ATAM (architecture tradeoff analysis","metadata":{"id":302}}],["0a09c549-ebfd-4723-ade8-8a373add1b09",{"pageContent":"based on their associated return on investment (ROI). The CBAM was \nconceived to be performed after an ATAM (architecture tradeoff analysis \nmethod), but it is possible to use the CBAM during design—that is, prior to \nthe moment where the architectural evaluation is performed.\nThe CBAM takes as its input a collection of prioritized traditional quality \nattribute scenarios, which are then analyzed and refined with additional \ninformation. The addition is to consider several levels of response for each \nscenario:\n§\tThe worst-case scenario, which represents the minimum threshold at which \na system must perform (utility = 0)\n§\tThe best-case scenario, which represents the level after which stakehold-\ners foresee no further utility (utility = 100)\n§\tThe current scenario, which represents the level at which the system \nis already performing (the utility of the current scenario is estimated by \nstakeholders)\n§\tThe desired scenario, which represents the level of response that the","metadata":{"id":303}}],["888ec3b0-8363-4432-abf0-a6fde0841aa5",{"pageContent":"is already performing (the utility of the current scenario is estimated by \nstakeholders)\n§\tThe desired scenario, which represents the level of response that the \nstakeholders are hoping to achieve (the utility of the desired scenario is \nestimated by stakeholders)\nUsing these data points, we can draw a utility–response curve, as \nshown in the figure. After the utility–response curve is mapped for each \nof the different scenarios, a number of contemplated design alternatives \nmay be considered, and their expected response values can be estimated. \nFor example, if we are concerned about mean time to failure, we might \nconsider three different architectural strategies (i.e., redundancy options)—\nfor example, no redundancy, cold spare, and hot spare. For each of these \nstrategies, we could estimate their expected responses (i.e., their expected \nmean times to failure). In the graph shown here, the “e” represents one \nsuch option, placed on the curve based on its expected response measure.","metadata":{"id":304}}],["1d7bbd27-e05d-4e4f-ba1a-b93e8d5247b2",{"pageContent":"mean times to failure). In the graph shown here, the “e” represents one \nsuch option, placed on the curve based on its expected response measure.\nUsing these response estimates, the utility values of each architectural \nstrategy can now be determined via interpolation, which provides its ex-\npected benefit. The costs of each architectural strategy are also elicited—\none would expect hot spare to be the most costly, followed by cold spare \nand no redundancy.\nGiven all of this information, architectural strategies can now be selected \nbased on their expected value for cost.\nwww.EBooksWorld.ir\n3.4 Identifying and Selecting Design Concepts 57\nResponse\nUtility\nw\nc\ne\nd\nb\nb: best\nc: current\ne: expected\nd: desired\nw: worst\n1                                                     2                                                     3\n0\n100\nAlthough the CBAM may seem relatively complex and time-consuming \nat first, you need to consider that some design decisions can have enor-","metadata":{"id":305}}],["ee319ed2-ec65-46c9-8c01-f4d0479b2505",{"pageContent":"0\n100\nAlthough the CBAM may seem relatively complex and time-consuming \nat first, you need to consider that some design decisions can have enor-\nmous economic consequences—in terms of their costs, their benefits, and \ntheir effects on project schedule. You must decide if you are willing to take \nthe chance of making these decisions solely using a gut-feeling approach \nversus this more rational and systematic approach. \nIn  case  the  previous  analysis  techniques  do  not  guide  you  to  make  an  ap-\npropriate  selection,  you  may  need  to  create  throwaway  prototypes  and  collect  \nmeasurements from them. The creation of early throwaway prototypes is a useful \ntechnique to help in the selection of externally developed components. This type \nof prototype is usually created in a “quick and dirty” fashion without too much \nconsideration  for  maintainability  or  reuse.  For  these  reasons,  it  is  important  to","metadata":{"id":306}}],["dbdd448c-d43c-4b39-ac7a-a949688fda08",{"pageContent":"of prototype is usually created in a “quick and dirty” fashion without too much \nconsideration  for  maintainability  or  reuse.  For  these  reasons,  it  is  important  to  \nkeep in mind that throwaway prototypes should not be used as a basis for further \ndevelopment.\nAlthough the creation of prototypes can be costly compared to analysis (the \nratio of costs is between 10 and 5 to 1, according to our sources), certain scenar-\nios strongly motivate the creation of prototypes. Aspects that you should consider \nwhen deciding whether you will create a prototype include the following:\n§\tDoes the project incorporate emerging technologies?\n§\tIs the technology new in the company?\nwww.EBooksWorld.ir\n58 Chapter 3—The Architecture Design Process\n§\tAre there certain drivers, particularly quality attributes, whose satisfaction \nusing the selected technology presents risks (i.e., it is not understood if they \ncan be satisfied)?\n§\tIs there a lack of trusted information, internal or external, that provides","metadata":{"id":307}}],["0cc00c89-8f4b-4d49-ac1b-f63d00ebd32b",{"pageContent":"using the selected technology presents risks (i.e., it is not understood if they \ncan be satisfied)?\n§\tIs there a lack of trusted information, internal or external, that provides \nsome degree of certainty that the selected technology will be useful to sat-\nisfy the project drivers?\n§\tAre there configuration options associated with the technology that need to \nbe tested or understood?\n§\tIs it unclear whether the selected technology can be integrated with other \ntechnologies that are used in the project?\nIf  most  of  your  answers  to  these  questions  are  “yes”,  then  you  should  \nstrongly consider the creation of a throwaway prototype.\nWhen identifying and selecting design concepts, you need to keep in mind the \nconstraints that are part of the architectural drivers, because some constraints will \nrestrict you from selecting particular alternatives. For example, a constraint might \nrequire that all libraries and frameworks in the system do not use the GPL license;","metadata":{"id":308}}],["cfc18867-ccda-4329-8ac8-cc61402a9fff",{"pageContent":"restrict you from selecting particular alternatives. For example, a constraint might \nrequire that all libraries and frameworks in the system do not use the GPL license; \nthus, even if you have found a framework that could be useful for your needs, you \nmay need to discard it if it has a GPL license. Also, you need to keep in mind that \nthe decisions regarding the selection of design concepts that you have made in pre-\nvious  iterations  may  restrict  the  design  concepts  that  you  can  select  in  the  future  \nbecause  of  incompatibilities.  For  example,  if  you  selected  a  web  application  ref-\nerence architecture for use in an initial iteration, you cannot select a user interface \nframework intended for local applications in a subsequent iteration.\nFinally, you need to remember that even though ADD provides guidance on \nhow to perform the design process, it cannot ensure that you will make appropri-","metadata":{"id":309}}],["ce4481ec-d9d3-4341-b626-41a01d49f17c",{"pageContent":"Finally, you need to remember that even though ADD provides guidance on \nhow to perform the design process, it cannot ensure that you will make appropri-\nate  design  decisions.  Thorough  reasoning  and  considering  different  alternatives  \n(not  just  the  first  thing  that  comes  to  mind)  are  the  best  means  to  improve  the  \nodds  of  finding  a  good  solution.  We  discuss  doing  “analysis  in  the  design  pro-\ncess” in Chapter 8.\n3.5 Producing Structures\nDesign  concepts  per  se  won’t  help  you  satisfy  your  drivers  unless  you  produce  \nstructures;  that  is,  you  need  to  identify  and  connect  elements  that  are  derived  \nfrom  the  selected  design  concepts.  This  process  is  the  instantiation  of  architec-\ntural  elements  in  ADD:  creating  elements  and  relationships  between  them,  and  \nassociating responsibilities with these elements. It is important to remember that","metadata":{"id":310}}],["538194d8-c35c-4bb7-b10e-5a09bfb8469d",{"pageContent":"tural  elements  in  ADD:  creating  elements  and  relationships  between  them,  and  \nassociating responsibilities with these elements. It is important to remember that \nthe  architecture  of  a  software  system  is  composed  of  a  set  of  structures,  which  \ncan be grouped into three major categories:\nwww.EBooksWorld.ir\n3.5 Producing Structures 59\n§\tModule structures: composed of logical and static elements that exist at \ndevelopment time, such as files, modules, and classes\n§\tComponent and connector (C&C) structures: composed of dynamic ele-\nments that exist at runtime, such as processes and threads\n§\tAllocation structures: composed of both software elements (from a module \nor C&C structure) and non-software elements that may exist both at devel-\nopment time and at runtime, such as file systems, hardware, and develop-\nment teams\nWhen you instantiate a design concept, you may actually produce more than \none structure. For example, in a particular iteration you may instantiate the Lay-","metadata":{"id":311}}],["fc4bff26-e620-4a13-9ef8-4d34716f4b10",{"pageContent":"ment teams\nWhen you instantiate a design concept, you may actually produce more than \none structure. For example, in a particular iteration you may instantiate the Lay-\ners pattern, which will result in a Module structure. As part of instantiating this \npattern, you will need to choose the number of layers, their relationships, and the \nspecific responsibilities of each layer. As part of the iteration, you may also study \nhow a scenario is supported by the elements that you have just identified. For ex-\nample, you could create instances of the logical elements in a C&C structure and \nmodel how they exchange messages (see Section 3.6). Finally, you may want to \ndecide who will be responsible for implementing the modules inside each of the \nlayers, which is an allocation decision.\n3.5.1 Instantiating Elements\nThe instantiation of architectural elements depends on the type of design concept \nthat you are working with:\n§\tReference architectures. In the case of reference architectures, instantiation","metadata":{"id":312}}],["dc81d05c-bc89-4049-ae58-c7b67de2ce04",{"pageContent":"The instantiation of architectural elements depends on the type of design concept \nthat you are working with:\n§\tReference architectures. In the case of reference architectures, instantiation \ntypically means that you perform some sort of customization. As part of \nthis work, you will add or remove elements that are part of the structure that \nis defined by the reference architecture. For example, if you are designing a \nweb application that needs to communicate with an external application to \nhandle payments, you will probably need an integration layer in addition to \nthe traditional presentation, business, and data layers.\n§\tArchitectural and design patterns. These patterns provide a generic structure \ncomposed of elements, their relationships and their responsibilities. As this \nstructure is generic, you will need to adapt it to your specific problem. In-\nstantiation usually involves transforming the generic structure defined by the","metadata":{"id":313}}],["3ecdf993-1fd9-403f-8d43-d854f92c515e",{"pageContent":"structure is generic, you will need to adapt it to your specific problem. In-\nstantiation usually involves transforming the generic structure defined by the \npattern into a specific one that is adapted to the needs of the problem that you \nare solving. For example, consider the Pipe and Filters architectural pattern. \nIt establishes the basic elements of computation—filters—and their relation-\nships—pipes—but does not specify how many filters you should use for your \nproblem or what their relationships should be. You will instantiate this pattern \nby defining how many pipes and filters are needed to solve your problem, by \nestablishing the specific responsibilities of each of the filters, and by defining \ntheir topology.\nwww.EBooksWorld.ir\n60 Chapter 3—The Architecture Design Process\n§\tDeployment patterns. Similar to the case with architectural and design pat-\nterns, the instantiation of deployment patterns generally involves the iden-","metadata":{"id":314}}],["b402574f-8619-4b19-90e0-e280a9e36732",{"pageContent":"60 Chapter 3—The Architecture Design Process\n§\tDeployment patterns. Similar to the case with architectural and design pat-\nterns, the instantiation of deployment patterns generally involves the iden-\ntification and specification of physical elements. If, for example, you are \nusing a Load-Balanced Cluster pattern, instantiation may involve identify-\ning the number of replicas to be included in the cluster, the load-balancing \nalgorithm, and the physical location of the replicas.\n§\tTactics. This design concept does not prescribe a particular structure, so \nyou will need to use other design concepts to instantiate a tactic. For ex-\nample, you may select a security tactic of authenticating actors and instan-\ntiate it by creating a custom-coded ad hoc solution, or by using a security \npattern, or by using an externally developed component such as a security \nframework.\n§\tExternally developed components. The instantiation of these components","metadata":{"id":315}}],["aeca68bb-b935-469a-982b-093f43da040b",{"pageContent":"pattern, or by using an externally developed component such as a security \nframework.\n§\tExternally developed components. The instantiation of these components \nmay or may not imply the creation of new elements. For example, in \nthe case of object-oriented frameworks, instantiation may require you \nto create specific classes that inherit from the base classes defined in the \nframework. This will result in new elements. Other approaches, which \ndo not involve the creation of new elements, might include choosing a \nspecific technology from a technology family that was identified in a pre-\nvious iteration, associating a particular framework to elements that were \nidentified in a previous iteration, or specifying configuration options for \nan element associated with a particular technology (such as a number of \nthreads in a thread pool).\n3.5.2 Associating Responsibilities and Identifying Properties\nWhen  you  are  creating  elements  by  instantiating  design  concepts,  you  need  to","metadata":{"id":316}}],["5ec1012a-c53b-41e2-abd0-14120c3b0185",{"pageContent":"threads in a thread pool).\n3.5.2 Associating Responsibilities and Identifying Properties\nWhen  you  are  creating  elements  by  instantiating  design  concepts,  you  need  to  \nconsider  the  responsibilities  that  are  allocated  to  these  elements.  For  example,  \nif you instantiate the Layers pattern and decide to use the traditional three-layer \nstructure, you might decide that one of the layers will be responsible for manag-\ning  the  interactions  with  the  users  (typically  known  as  the  presentation  layer).  \nWhen  instantiating  elements  and  allocating  responsibilities,  you  should  keep  in  \nmind  the  high  cohesion/low  coupling  design  principle:  Elements  should  have  \nhigh  cohesion  (internally),  defined  by  a  narrow  set  of  responsibilities,  and  low  \ncoupling (externally), defined by a lack of knowledge of the implementation de-\ntails of other elements.\nOne  additional  aspect  that  you  need  to  consider  when  instantiating  design","metadata":{"id":317}}],["4ce4149f-9c09-400d-8e7e-cf6f13c1bc89",{"pageContent":"coupling (externally), defined by a lack of knowledge of the implementation de-\ntails of other elements.\nOne  additional  aspect  that  you  need  to  consider  when  instantiating  design  \nconcepts is the properties of the elements. This may involve aspects such as the \nconfiguration options, statefulness, resource management, priority, or even hard-\nware characteristics (if the elements that you created are physical nodes) of the \nchosen technologies. Identifying these properties supports analysis and the docu-\nmentation of the design rationale.\nwww.EBooksWorld.ir\n3.6 Defining Interfaces 61\n3.5.3 Establishing Relationships Between the Elements\nThe  creation  of  structures  also  requires  making  decisions  with  respect  to  the  \nrelationships  that  exist  between  the  elements  and  their  properties.  Once  again,  \nconsider  the  Layers  pattern.  You  may  decide  that  two  layers  are  connected,  but","metadata":{"id":318}}],["0cb62757-73c1-4a78-b085-33f2c1f9c935",{"pageContent":"relationships  that  exist  between  the  elements  and  their  properties.  Once  again,  \nconsider  the  Layers  pattern.  You  may  decide  that  two  layers  are  connected,  but  \nthese layers will eventually be allocated to components that are, in turn, allocated \nto  hardware.  In  such  a  case,  you  need  to  decide  how  communication  will  take  \nplace  between  these  layers,  as  they  have  been  allocated  to  components:  Is  the  \ncommunication synchronous or asynchronous? Does it involve some type of net-\nwork communication? Which type of protocol is used? How much information is \ntransferred and at what rate? These design decisions can have a significant impact \nwith respect to achieving certain quality attributes such as performance.\n3.6 Defining Interfaces\nInterfaces  are  the  externally  visible  properties  of  elements  that  establish  a  con-\ntractual specification that allows elements to collaborate and exchange informa-","metadata":{"id":319}}],["dffb6859-eac8-42dc-b352-7cf753c65d92",{"pageContent":"3.6 Defining Interfaces\nInterfaces  are  the  externally  visible  properties  of  elements  that  establish  a  con-\ntractual specification that allows elements to collaborate and exchange informa-\ntion. There are two categories of interfaces: external and internal.\n3.6.1 External Interfaces\nExternal interfaces include interfaces from other systems that are required by the \nsystem that you are developing and interfaces that are provided by your system \nto other systems. Required interfaces are part of the constraints for your system, \nas you usually cannot influence their specification. Provided interfaces need to be \nformally  defined,  which  can  be  performed  in  a  similar  way  to  defining  internal  \ninterfaces—that is, by considering interactions between the external systems and \nyour system and seeing them as elements of a bigger structure.\nEstablishing a system context at the beginning of the design process is use-","metadata":{"id":320}}],["9a22b3ec-6347-45d6-8387-22c6ddc6767d",{"pageContent":"your system and seeing them as elements of a bigger structure.\nEstablishing a system context at the beginning of the design process is use-\nful to identify external interfaces. This context can be represented using a system \ncontext diagram, as shown in Figure 3.3. Given that external entities and the sys-\ntem under development interact via interfaces, there should be at least one exter-\nnal interface per external system (each relationship in the figure).\n3.6.2 Internal Interfaces\nInternal  interfaces  are  interfaces  between  the  elements  that  result  from  the  in-\nstantiation of design concepts. To identify the relationships and the interface de-\ntails,  you  generally  need  to  understand  how  the  elements  exchange  information  \nat  runtime.  You  can  achieve  this  with  the  help  of  modeling  tools  such  as  UML  \nsequence diagrams (Figure 3.4), which allow you to model the information that \nwww.EBooksWorld.ir\n62 Chapter 3—The Architecture Design Process","metadata":{"id":321}}],["b15c7697-d7b8-46e4-84ad-7a4dc3b64363",{"pageContent":"sequence diagrams (Figure 3.4), which allow you to model the information that \nwww.EBooksWorld.ir\n62 Chapter 3—The Architecture Design Process\nis exchanged between elements during execution to support use cases or quality \nattribute  scenarios.  This  type  of  analysis  is  also  useful  for  identifying  relation-\nships between elements: If two elements need to exchange information directly, \nthen  a  relationship  between  these  elements  must  exist.  The  information  that  is  \nexchanged becomes part of the specification of the interface. Interfaces typically \nconsist of a set of operations (such as methods) with specified parameters, return \nvalues,  and  possibly,  exceptions  and  pre  and  post  conditions.  Some  interfaces,  \nhowever, may involve other information exchange mechanisms, such as a compo-\nnent that writes information to a file or database and another component that then \naccesses this information. Interfaces may also establish quality of service agree-","metadata":{"id":322}}],["134d8ace-516f-43f1-9f12-2bc4254333d3",{"pageContent":"nent that writes information to a file or database and another component that then \naccesses this information. Interfaces may also establish quality of service agree-\nments. For example, the execution of an operation specified in the interface may \nbe time-constrained to satisfy a performance quality attribute scenario.\nThe  identification  of  interfaces  is  usually  not  performed  equally  across  all  \ndesign  iterations.  When  you  are  starting  the  design  of  a  greenfield  system,  for  \nexample,  your  first  iterations  will  produce  only  abstract  elements  such  as  lay-\ners,  with  these  elements  then  being  refined  in  later  iterations.  The  interfaces  of  \nabstract elements such as layers are typically underspecified. For example, in an \nearly iteration you might simply specify that the UI layer sends “commands” to \nthe business logic layer, with the business logic layer sending “results” back. As","metadata":{"id":323}}],["41cc5190-3ac9-44c3-bee5-931f9ad468e7",{"pageContent":"early iteration you might simply specify that the UI layer sends “commands” to \nthe business logic layer, with the business logic layer sending “results” back. As \nyou advance in the design process and particularly when you create structures to \naddress specific use cases and quality attribute scenarios, you will need to refine \nthe interfaces of the specific elements that participate in the interaction.\nIn  some  special  cases,  identification  of  interfaces  is  greatly  simplified.  For  \nexample,  in  the  Big  Data  case  study  we  present  in  Chapter  5,  interfaces  are  al-\nready defined by the technologies that are selected. The specification of interfaces \nthen becomes a relatively trivial task, as the chosen technologies are designed to \n(continues on p. 64)\nTime server\nLegend:\nFIGURE 3.3 A system context diagram\nwww.EBooksWorld.ir\n3.6 Defining Interfaces 63\nThe following is an initial sequence diagram for Use Case UC-2 (Detect Fault)\n1\n from the","metadata":{"id":324}}],["12e14e91-b7ed-40cc-b4a0-6cecc3c9d3bf",{"pageContent":"Time server\nLegend:\nFIGURE 3.3 A system context diagram\nwww.EBooksWorld.ir\n3.6 Defining Interfaces 63\nThe following is an initial sequence diagram for Use Case UC-2 (Detect Fault)\n1\n from the \nFCAPS case study in Chapter 4. This diagram shows the interactions between an actor \nand the five components that participate in UC-2. In creating this diagram, we identify \nthe information that is exchanged, the methods that are invoked, and the values that \nare passed and returned.\nT ime Server\n:T imeServerConnector:T imeServerConfigurationController:T imeServerDataMapper:T ime Server:T opologyController\naddEventListener(this)\ntrap()\neventReceived(event)\npublish(event)\nretrieve(id) :TimeServer\n:TimeServer\naddEvent()\nupdate(TimeServer)\n:true\nKey: UML\nFrom this interaction, initial methods for the interfaces of the interacting elements can \nbe identified:\nName: TimeServerConnector\nMethod nameDescription\nboolean addEventListener(:EventListener)\nThis method allows \ncomponents from the \nbusiness logic to register","metadata":{"id":325}}],["997f65e5-7819-4b31-bc4c-783982414acf",{"pageContent":"be identified:\nName: TimeServerConnector\nMethod nameDescription\nboolean addEventListener(:EventListener)\nThis method allows \ncomponents from the \nbusiness logic to register \nthemselves as listeners to \nevents that are received \nfrom the TimeServers.\nFIGURE 3.4 A sequence diagram used to identify interfaces\n1. More detail about this example is presented in Chapter 4.\nwww.EBooksWorld.ir\n64 Chapter 3—The Architecture Design Process\ninteroperate and hence have already “baked in” many interface assumptions and \ndecisions.\nFinally,  you  need  to  consider  that  not  all  of  the  internal  interfaces  of  the  \nsystem  element  will  be  identified  as  part  of  the  design  process  (see  the  sidebar  \n“Identifying Interfaces in Element Interaction Design”).\nIdentifying Interfaces in Element Interaction Design\nAlthough defining interfaces is an essential part of the architecture design \nprocess, it is important to recognize that not all of the internal interfaces","metadata":{"id":326}}],["2ea73b55-5559-4007-b0d4-6d0176d1e883",{"pageContent":"Although defining interfaces is an essential part of the architecture design \nprocess, it is important to recognize that not all of the internal interfaces \nare identified during architectural design. As part of the architecture design \nprocess, you typically consider the primary use cases as part of the archi-\ntectural drivers, and you identify elements (usually modules) that support \nthis primary functionality along with the other drivers. This process will, \nhowever, not uncover all of the elements and interfaces for the system that \nare required to support the entire set of use cases. This lack of specificity is \nintended: Architecture is about abstraction, so necessarily some information \nis less important, particularly in the earliest stages of design.\nIdentifying the modules that support the nonprimary use cases is often \nnecessary for estimation or work-assignment purposes. Identifying their \ninterfaces is also necessary to support the individual development and","metadata":{"id":327}}],["5b51795f-a79b-4fb8-bb59-782b0e456326",{"pageContent":"necessary for estimation or work-assignment purposes. Identifying their \ninterfaces is also necessary to support the individual development and \nintegration of the modules and to perform unit testing. This identification of \nmodules may be done early in the project life cycle, but it must not be con-\nfused with a big design up front (BDUF) approach. This, at most, is a BDUF \nthat, in certain contexts such as early estimation or iteration planning, is \nhard to avoid.\nAs an architect, you may identify the set of modules that supports the \ncomplete set of use cases for the system or for a particular release of the \nsystem, but the identification of the interfaces associated with the modules \nthat support the nonprimary use cases is typically not your responsibility, \nas it would require a significant amount of your time and does not usually \nhave a major architectural impact. This task, which we call element inter-\naction design (see Section 2.2.2), is usually performed after architectural","metadata":{"id":328}}],["d961d732-ccf9-405a-8e4f-b3197a6bb05c",{"pageContent":"have a major architectural impact. This task, which we call element inter-\naction design (see Section 2.2.2), is usually performed after architectural \ndesign ends but before the development of (most of) the modules begins. \nAlthough this task should be performed by other members in the develop-\nment team, you play a critical role in it, since these interfaces must adhere \nto the architectural design that you established. You, as the architect, must \ncommunicate the architecture to the engineers who are responsible for \nidentifying the interfaces and ensure that they understand the rationale for \nthe existing design decisions.\nA good way to achieve this communication is to use the active reviews \nfor intermediate design (ARID) method. In this method, the architecture \ndesign (or part of it) is presented to a group of reviewers—in this case, the \nengineers who will make use of this design. After the design presentation, \na set of scenarios is selected by the participants. The selected scenarios","metadata":{"id":329}}],["3096c62f-fb2e-4ad1-abcf-b472250f0559",{"pageContent":"engineers who will make use of this design. After the design presentation, \na set of scenarios is selected by the participants. The selected scenarios \n(continued from p. 62)\nwww.EBooksWorld.ir\n3.7 Creating Preliminary Documentation During Design 65\nare used for the core of the exercise, where the reviewers use the elements \npresent in the architecture to satisfy them. In standard ARID, the review-\ners are asked to write code or pseudo-code for the purpose of identifying \ninterfaces. Alternatively, the architect can present the architecture, select \na nonprimary functional scenario and ask the participants to identify the \ninterfaces of the components that support the scenario using sequence \ndiagrams or a similar method.\nAside from the fact that the architectural design is reviewed in this exer-\ncise, there are additional benefits to this approach. Specifically, in a single \nmeeting, the architecture design or part of it is presented to the entire","metadata":{"id":330}}],["875dd2e4-de54-4609-93b4-b2c95c7e3129",{"pageContent":"cise, there are additional benefits to this approach. Specifically, in a single \nmeeting, the architecture design or part of it is presented to the entire \nteam, and agreements can be reached with respect to how the interfaces \nshould be defined (e.g., the level of detail or aspects such as parameter \npassing, data types, or exception management).\n3.7 Creating Preliminary Documentation During Design\nA software architecture is typically documented as a set of views, which represent \nthe different structures that compose the architecture. The formal documentation \nof these views is not part of the design process. Structures, however, are produced \nas part of design. Capturing them, even in an informal manner (i.e., as sketches), \nalong  with  the  design  decisions  that  led  you  to  create  these  structures,  is  a  task  \nthat should be performed as part of normal design activities.\n3.7.1 Recording Sketches of the Views","metadata":{"id":331}}],["e4e52e95-8449-4d27-95ee-60512cedd604",{"pageContent":"along  with  the  design  decisions  that  led  you  to  create  these  structures,  is  a  task  \nthat should be performed as part of normal design activities.\n3.7.1 Recording Sketches of the Views\nWhen you produce structures by instantiating the design concepts that you have \nselected  to  address  a  particular  design  problem,  you  will  typically  not  produce  \nthese structures in your mind, but rather will create some sketches of them. In the \nsimplest  case,  you  will  produce  these  sketches  on  a  whiteboard,  a  flip-chart,  or  \neven a piece of paper. Otherwise, you may use a modeling tool in which you will \ndraw the structures. The sketches that you produce are the initial documentation \nfor your architecture that you should capture and may flesh out later, if necessary. \nWhen you create sketches, you don’t need to always use a more formal language \nsuch as UML. If you use some informal notation, you should at least be careful in","metadata":{"id":332}}],["e78c209b-feda-4567-a7d0-46a113e2f241",{"pageContent":"When you create sketches, you don’t need to always use a more formal language \nsuch as UML. If you use some informal notation, you should at least be careful in \nmaintaining consistency in the use of symbols. Eventually, you will need to add a \nlegend to your diagrams to provide clarity and avoid ambiguity.\nYou  should  develop  discipline  in  writing  down  the  responsibilities  that  you  \nallocate to the elements as you create the structures. The reasons for this are sim-\nple: As you identify an element, you are determining some responsibilities for that \nelement in your mind. Writing it down at that moment ensures that you won’t have \nwww.EBooksWorld.ir\n66 Chapter 3—The Architecture Design Process\nto remember it later. Also, it is easier to write down the responsibilities associated \nwith your elements gradually, rather than compiling all of them at a later time.\nCreating this preliminary documentation as you design requires some disci-","metadata":{"id":333}}],["5eb29b59-a31c-4a9e-9851-a8cc3ec3efcb",{"pageContent":"with your elements gradually, rather than compiling all of them at a later time.\nCreating this preliminary documentation as you design requires some disci-\npline. But the benefits are worth the effort—you will be able to produce the more \ndetailed architecture documentation relatively easily and quickly at a later point. \nOne simple way that you can document responsibilities if you are using a white-\nboard, a flip-chart, or a PowerPoint slide is to take a photo of the sketch that you \nhave produced and paste it in a document, along with a table that summarizes the \nresponsibilities of every element depicted in the diagram (Figure 3.5 provides an \nexample). If you are using a computer-aided software engineering (CASE) tool, \nyou can select an element to create and use the text area that usually appears in \nthe properties sheet of the element to document its responsibilities, and then gen-\nerate the documentation automatically.","metadata":{"id":334}}],["6a94ba15-533c-4cf6-af1a-902a37dd6b02",{"pageContent":"the properties sheet of the element to document its responsibilities, and then gen-\nerate the documentation automatically.\nThis diagram presents a sketch of a module view depicting the overall system structure \nfrom the case study in Chapter 5.\nData\nStream\nData\nSources\nRaw Data \nStorage\nCorporate \nBI Tool\nDashboard/\nVisualization\nTo o l\nReal-Time\nViews\nBATCH LayerSERVING Layer\nSPEED Layer\nAd Hoc Views\nPrecomputing\nAd Hoc \nBatch Views\nStatic Views\nPrecomputing\nStatic Batch\nViews\nLayer \nBoundary\nData Flow \n(with direction indicated)\nQuery Results Flow \nLegend:\nElement \nBoundary\nThe diagram is complemented with a table that describes the element’s responsibilities:\nElementResponsibility\nData \nstream\nThis element collects data from all data sources in real time \nand dispatches it to both the batch layer and the speed layer for \nprocessing.\nBatch layerThis layer is responsible for storing raw data and precomputing the \nbatch views to be stored in the serving layer.\n......\nFIGURE 3.5 Sample preliminary documentation\nwww.EBooksWorld.ir","metadata":{"id":335}}],["0947ba52-aec8-4990-8c13-0a7e33931892",{"pageContent":"Batch layerThis layer is responsible for storing raw data and precomputing the \nbatch views to be stored in the serving layer.\n......\nFIGURE 3.5 Sample preliminary documentation\nwww.EBooksWorld.ir\n3.7 Creating Preliminary Documentation During Design 67\nOf  course,  it  is  not  necessary  to  document  everything.  The  three  purposes  \nof documentation are analysis, construction, and education. At the moment you \nare designing, you should choose a documentation purpose and then document to \nfulfill that purpose, based on your risk mitigation concerns. For example, if you \nhave  a  critical  quality  attribute  scenario  that  your  architecture  design  needs  to  \nsatisfy, and if you will need to prove this requirement is met in an analysis, then \nyou must take care to document the information that is relevant for the analysis to \nbe satisfactory. Alternatively, if you anticipate having to train new team members,","metadata":{"id":336}}],["3d3dd3fe-0679-4295-8919-96dccc55b520",{"pageContent":"you must take care to document the information that is relevant for the analysis to \nbe satisfactory. Alternatively, if you anticipate having to train new team members, \nthen  you  should  make  a  sketch  of  a  C&C  view  of  the  system,  showing  how  it  \noperates and how the elements interact at runtime, and perhaps construct a crude \nmodule view of the system, showing at least the major layers or subsystems.\nFinally, it is a good idea to remember, as you are documenting, that your design \nmay eventually be analyzed. Consequently, you need to think about which informa-\ntion should be documented to support this analysis (see the sidebar “Scenario-Based \nDocumentation”).\nScenario-Based Documentation\nAn analysis of an architecture design is based on your most important use \ncases and quality attribute scenarios. Simply put, a scenario is selected \nand you must explain to reviewers how the architecture supports the sce-","metadata":{"id":337}}],["c05870b3-a4fd-4a3e-9641-61830644d5f3",{"pageContent":"cases and quality attribute scenarios. Simply put, a scenario is selected \nand you must explain to reviewers how the architecture supports the sce-\nnario, and justify your decisions. To start preparing for the analysis while \nyou design, it is useful to produce and document structures that contain \nthe elements that are involved in the satisfaction of a scenario. This should \ncome naturally given that the design process is guided by scenarios, but \nkeeping this point firmly in mind is always helpful.\nDuring the design process, you should at least try to capture the follow-\ning elements in a single document:\n§\tThe primary presentation: the diagram that represents the structure that \nyou produced\n§\tThe element responsibilities table: it will help you record the responsibilities \nof the elements that are present in the structure\n§\tThe relevant design decisions, and their rationales (see Section 3.7.2)\nYou might also capture two other pieces of information:","metadata":{"id":338}}],["64013eb2-928f-4dab-bf98-c5b137eed7ff",{"pageContent":"of the elements that are present in the structure\n§\tThe relevant design decisions, and their rationales (see Section 3.7.2)\nYou might also capture two other pieces of information:\n§\tA runtime representation of the element’s interaction—for example, a se-\nquence diagram\n§\tThe initial interface specifications (which can also be captured in a sepa-\nrate document)\nAs you can see, all of this information needs to be produced as part of \nthe design process. One way or another, you need to decide which ele-\nments are present in the system and how they interact. The only question \nwww.EBooksWorld.ir\n68 Chapter 3—The Architecture Design Process\nis whether you bother to write this information down, or whether its sole \nrepresentation is in the code.\nIf you follow the approach that we advocate here, at the end of the \ndesign you will have a set of preliminary views documented, in which each \nof the views is associated with a particular scenario, and you will have this","metadata":{"id":339}}],["e758585c-ddca-4a52-8a3b-2ccf47533548",{"pageContent":"design you will have a set of preliminary views documented, in which each \nof the views is associated with a particular scenario, and you will have this \ndocumentation at little cost. This preliminary documentation can be used \n“as is” to analyze the design, and particularly through scenario-based \nevaluations. \n3.7.2 Recording Design Decisions\nIn each design iteration, you make important design decisions to achieve your it-\neration goal. As we saw previously, these design decisions include the following:\n§\tSelecting a design concept from several alternatives\n§\tCreating structures by instantiating the selected design concept\n§\tEstablishing relationships between elements and defining interfaces\n§\tAllocating resources (e.g., people, hardware, computation)\n§\tOthers\nWhen you study a diagram that represents an architecture, you see the end \nproduct of a thought process, but it may not be easy to understand the decisions \nthat were made to achieve this result. Recording design decisions beyond the rep-","metadata":{"id":340}}],["71d4cc4c-3878-429e-952e-3d436bb6119d",{"pageContent":"product of a thought process, but it may not be easy to understand the decisions \nthat were made to achieve this result. Recording design decisions beyond the rep-\nresentation of the chosen elements, relationships, and properties is fundamental \nto help in understanding how you arrived at the result: the design rationale.\nWhen your iteration goal involves satisfying a specific quality attribute sce-\nnario,  some  of  the  decisions  that  you  make  will  play  significant  roles  in  your  \nability to achieve the scenario response measure. These are, therefore, the deci-\nsions that you should take the greatest care in recording. You should record these \ndecisions  because  they  are  essential  to  facilitate  analysis  of  the  design  you  cre-\nated; then to facilitate implementation; and, still later, to aid in understanding of \nthe architecture (e.g., during maintenance). Also every design decision is “good \nenough” but seldom optimal, so you need to justify the decisions made, and pos-","metadata":{"id":341}}],["03a98132-0f8c-4fca-ae03-ad6130fdb27b",{"pageContent":"the architecture (e.g., during maintenance). Also every design decision is “good \nenough” but seldom optimal, so you need to justify the decisions made, and pos-\nsibly revisit the remaining risks later.\nYou might think that recording design decisions is a tedious task. In reality, \ndepending  on  the  criticality  of  the  system  being  developed,  you  can  adjust  the  \namount  of  information  that  is  recorded.  For  example,  to  record  a  minimum  of  \ninformation, you can use a simple table such as the one shown in Table 3.2. If you \ndecide  to  record  more  than  this  minimum,  the  following  information  can  prove  \nuseful:\n§\tWhat evidence was produced to justify decisions?\n§\tWho did what?\n§\tWhy were shortcuts taken?\nwww.EBooksWorld.ir\n3.8 Tracking Design Progress 69\n§\tWhy were tradeoffs made?\n§\tWhat assumptions did you make?\nAnd,  in  the  same  way  that  we  suggest  you  record  responsibilities  as  you","metadata":{"id":342}}],["436875f6-a1a7-4d30-9584-3dc5b655de6d",{"pageContent":"www.EBooksWorld.ir\n3.8 Tracking Design Progress 69\n§\tWhy were tradeoffs made?\n§\tWhat assumptions did you make?\nAnd,  in  the  same  way  that  we  suggest  you  record  responsibilities  as  you  \nidentify elements, you should record the design decisions as you make them. The \nreason for this is simple: If you leave it until later, you may not remember why \nyou did things.\n3.8 Tracking Design Progress\nEven though ADD provides clear guidelines to perform design systematically, it \ndoes not provide a mechanism to track design progress. When you are perform-\ning design, however, there are several questions that you want to answer:\n§\tHow much design do we need to do?\n§\tHow much design has been done so far?\n§\tAre we finished?\nAgile practices such as the use of backlogs and Kanban boards can help you \ntrack  the  design  progress  and  answer  these  questions.  These  techniques  are  not  \nlimited to Agile methods, of course. Any development project using any method-\nology should track progress.","metadata":{"id":343}}],["51979f93-f133-47e9-824a-4e5da696f303",{"pageContent":"track  the  design  progress  and  answer  these  questions.  These  techniques  are  not  \nlimited to Agile methods, of course. Any development project using any method-\nology should track progress.\n3.8.1 Use of an Architectural Backlog\nThe  concept  of  an  architecture  (or  design)  backlog  has  been  proposed  by  several  \nauthors  (see  Section  7.1).  This  is  similar  to  what  is  found  in  Agile  development  \nmethods such as Scrum. The basic idea is that you need to create a list of the pend-\ning actions that still need to be performed as part of the architecture design process.\nTABLE 3.2 Example of a Table to Document Design Decisions\nDriverDesign Decisions and LocationRationale and Assumptions\nQ A-1Introduce concurrency (tactic) \nin the TimeServerConnector \nand FaultDetectionService\nConcurrency should be introduced to \nbe able to receive and process several \nevents (traps) simultaneously.\nQA-2Use of a messaging pattern \nthrough the introduction of \na message queue in the","metadata":{"id":344}}],["e457f912-6cf8-4714-87d8-6fd1708eeab4",{"pageContent":"Concurrency should be introduced to \nbe able to receive and process several \nevents (traps) simultaneously.\nQA-2Use of a messaging pattern \nthrough the introduction of \na message queue in the \ncommunications layer\nAlthough the use of a message \nqueue may seem to go against the \nperformance imposed by the scenario, \na message queue was chosen \nbecause some implementations have \nhigh performance and, furthermore, \nthis will be helpful to support QA-3.\n.........\nwww.EBooksWorld.ir\n70 Chapter 3—The Architecture Design Process\nInitially, you should populate the design backlog with your drivers, but other \nactivities  that  support  the  design  of  the  architecture  can  also  be  included.  For  \nexample:\n§\tCreation of a prototype to test a particular technology or to address a spe-\ncific quality attribute risk\n§\tExploration and understanding of existing assets (possibly requiring reverse \nengineering)\n§\tIssues uncovered in a review of the design","metadata":{"id":345}}],["81bd07ee-4b61-4468-854c-326d453fdd32",{"pageContent":"cific quality attribute risk\n§\tExploration and understanding of existing assets (possibly requiring reverse \nengineering)\n§\tIssues uncovered in a review of the design\n§\tReview of a partial design that was performed on a previous iteration\nFor example, when using Scrum, the sprint backlog and the design back-\nlog  are  not  independent:  Some  features  in  the  sprint  backlog  may  require  ar-\nchitecture design to be performed, so they will generate items that go into the \narchitectural  design  backlog.  These  two  backlogs  can  be  managed  separately,  \nhowever.  The  design  backlog  may  even  be  managed  internally,  as  it  contains  \nseveral items that are typically not discussed or prioritized by the customer (or \nproduct owner).\nAlso, additional architectural concerns may arise as decisions are made. For \nexample,  if  you  choose  a  reference  architecture,  you  will  probably  need  to  add  \nspecific architectural concerns, or quality attribute scenarios derived from them,","metadata":{"id":346}}],["d93e8667-873c-4e37-bfa2-6b78b643898c",{"pageContent":"example,  if  you  choose  a  reference  architecture,  you  will  probably  need  to  add  \nspecific architectural concerns, or quality attribute scenarios derived from them, \nto the architectural design backlog. An example of such a concern is the manage-\nment of sessions for a web application reference architecture.\n3.8.2 Use of a Design Kanban Board\nAs design is performed in rounds and as a series of iterations within these rounds, \nyou need to have a way of tracking the design’s degree of advancement. You must \nalso  decide  whether  you  need  to  continue  making  more  design  decisions  (i.e.,  \nperforming additional iterations). One tool that can be used to facilitate this task \nis a Kanban board, such as the one shown in Figure 3.6\nAt the beginning of a design round, the inputs to the design process become \nentries in the backlog. Initially, that activity occurs in step 1 of ADD; the differ-\nent entries in your backlog for this design round should be added to the “Not Yet","metadata":{"id":347}}],["a7f34b9d-00a9-42c5-8f7b-156f5e59ca8e",{"pageContent":"entries in the backlog. Initially, that activity occurs in step 1 of ADD; the differ-\nent entries in your backlog for this design round should be added to the “Not Yet \nAddressed” column of the board (except if you have some entries that were not \nconcluded  in  previous  design  rounds  that  you  wish  to  address  here).  When  you  \nbegin  a  design  iteration,  in  step  2  of  ADD,  the  backlog  entries  that  correspond  \nto the drivers that you plan to address as part of the design iteration goal should \nbe moved to the “Partially Addressed” column. Finally, once you finish an itera-\ntion and the analysis of your design decisions reveals that a particular driver has \nbeen addressed (step 7 of ADD), the entry should be moved to the “Completely \nAddressed”  column  of  the  board.  It  is  important  to  establish  clear  criteria  that  \nwill allow a driver to be moved to the “Completely Addressed” column (think of","metadata":{"id":348}}],["ccdab1a3-b2a3-4dd3-892e-5b472049c6de",{"pageContent":"Addressed”  column  of  the  board.  It  is  important  to  establish  clear  criteria  that  \nwill allow a driver to be moved to the “Completely Addressed” column (think of \nthis as the “Definition of Addressed” criteria, similar to the “Definition of Done” \nwww.EBooksWorld.ir\n3.8 Tracking Design Progress 71\ncriteria used in Scrum). A criterion may be, for example, that the driver has been \nanalyzed or that it has been implemented in a prototype. Also, drivers that are se-\nlected for a particular iteration may not be completely addressed in that particular \niteration, in which case they should remain in the “Partially Addressed” column \nand, in preparation for subsequent iterations, you should consider how they can \nbe allocated to the elements that exist at this point.\nIt can be useful to select a technique that will allow you to differentiate the \nentries in the board according to their priority. For example, you might use differ-\nent colors of Post-it notes depending on the priority.","metadata":{"id":349}}],["77f068d2-79de-47a6-9c7f-d94be5920490",{"pageContent":"entries in the board according to their priority. For example, you might use differ-\nent colors of Post-it notes depending on the priority.\nWith  such  a  board,  it  is  easy  to  visually  track  the  advancement  of  design,  \nas  you  can  quickly  see  how  many  of  the  (most  important)  drivers  are  being  or  \nhave  been  addressed  in  the  design  round.  This  technique  also  helps  you  decide  \nwhether you need to perform additional iterations as, ideally, the design round is \nterminated when a majority of your drivers (or at least the ones with the highest \npriority) are located under the “Completely Addressed” column.\nNot Yet Addressed 6Partially Addressed 7Completely Addressed 1Discarded\nHigh Priority\nHigh Priority\nMedium Priority\nMedium Priority\nMedium Priority\nLow Priority\nHigh Priority\nHigh Priority\nHigh Priority\nHigh Priority\nHigh Priority\nQA-8 Test code coverage should be\nat least 85% for each CI\nQA-3 External user credentials are\nverified against user registry","metadata":{"id":350}}],["3cdd2a92-9c5b-4006-a438-2bbc7ab9a1ce",{"pageContent":"Low Priority\nHigh Priority\nHigh Priority\nHigh Priority\nHigh Priority\nHigh Priority\nQA-8 Test code coverage should be\nat least 85% for each CI\nQA-3 External user credentials are\nverified against user registry\nCT-1 MVP release of the solution to\nthe selected consultants, customers,\nand prospective licensees in 9\nmonths, release in 1.5 years\nQA-5 Data center infrastructure has\nuptime 99.95%\nQA-4 User facing parts are available\n99.9% - 4 hours in\nmonths (maintenance window)\nQA-1 User credentials are verified\nagainst corporate AD\nUC4 - As sales person, prepare\nproposal plan\nCT-8 Infrastructure team is not able\nto support large-scale SaaS setup\nCN-2 Choose architecture style\nQAScenario\nQAScenario\nQAScenario\nQAScenario\nQAScenario\nConstraint\nConstraint\nUseCase\nConcern\nCN-1 Codebase (reuse legacy code if\npossible\nFIGURE 3.6 A Kanban board used to track design progress\nwww.EBooksWorld.ir\n72 Chapter 3—The Architecture Design Process\n3.9    Summary\nIn this chapter, we presented a detailed walk-through of the Attribute-Driven De-","metadata":{"id":351}}],["9f22a095-2fa8-47e4-bc64-ea2df0422f43",{"pageContent":"www.EBooksWorld.ir\n72 Chapter 3—The Architecture Design Process\n3.9    Summary\nIn this chapter, we presented a detailed walk-through of the Attribute-Driven De-\nsign method, version 3.0. We also discussed several important aspects that need \nto  be  considered  in  the  various  steps  of  the  design  process.  These  aspects  in-\nclude the use of a backlog, the various possible design roadmaps (for greenfield, \nbrownfield,  and  novel  contexts),  the  identification  and  selection  of  design  con-\ncepts  and  their  use  in  producing  structures,  the  definition  of  interfaces,  and  the  \nproduction of preliminary documentation.\nEven though the overall architecture development life cycle includes docu-\nmenting and analyzing architecture as activities that are separate from design, we \nhave argued that a clean separation of these activities is artificial and harmful. We \nstress that preliminary documentation and analysis activities need to be regularly","metadata":{"id":352}}],["cb47c4ac-793a-4d66-ab2b-791d598f472c",{"pageContent":"have argued that a clean separation of these activities is artificial and harmful. We \nstress that preliminary documentation and analysis activities need to be regularly \nperformed as integral parts of the design process.\nIn Chapters 4, 5, and 6, we will instantiate ADD 3.0 in several extended ex-\namples, showing how the method works in the real world, in both greenfield and \nbrownfield contexts.\n3.10 Further Reading\nSome  of  the  concepts  of  ADD  3.0  were  first  introduced  in  an  IEEE  Software  \narticle:  H.  Cervantes,  P.  Velasco,  and  R.  Kazman,  “A  Principled  Way  of  Us-\ning  Frameworks  in  Architectural  Design”,  IEEE  Software,  46–53,  March/April  \n2013.  Version  2.0  of  ADD  was  first  documented  in  the  SEI  Technical  Report:  \nR. Wojcik, F. Bachmann, L. Bass, P. Clements, P. Merson, R. Nord, and B. Wood, \n“Attribute-Driven  Design  (ADD),  Version  2.0”,  SEI/CMU  Technical  Report  \nCMU/SEI-2006-TR-023,  2006.  An  extended  example  of  using  ADD  2.0  was","metadata":{"id":353}}],["60940a34-e4ad-400e-ac3b-56507a52d6d5",{"pageContent":"“Attribute-Driven  Design  (ADD),  Version  2.0”,  SEI/CMU  Technical  Report  \nCMU/SEI-2006-TR-023,  2006.  An  extended  example  of  using  ADD  2.0  was  \ndocumented in W. Wood, “A Practical Example of Applying Attribute-Driven De-\nsign (ADD), Version 2.0”, SEI/CMU Technical Report: CMU/SEI-2007-TR-005.\nSeveral alternative methods exist to support the design of software architec-\ntures. These are discussed in more detail and referenced in Chapter 7.\nThe  concept  of  an  architecture  backlog  is  discussed  in  C.  Hofmeister,  \nP. Kruchten, R. Nord, H. Obbink, A. Ran, and P. America, “A General Model of \nSoftware Architecture Design Derived from Five Industrial Approaches”, Journal \nof Systems and Software, 80:106–126, 2007.\nThe  ARID  method  is  discussed  in  P.  Clements,  R.  Kazman,  and  M.  Klein,  \nEvaluating Software Architectures: Methods and Case Studies, Addison-Wesley, \n2002.\nThe  CBAM  method  is  presented  in  L.  Bass,  P.  Clements,  and  R.  Kazman,","metadata":{"id":354}}],["f1a4c99f-97e7-454b-af63-5097efc64b0f",{"pageContent":"Evaluating Software Architectures: Methods and Case Studies, Addison-Wesley, \n2002.\nThe  CBAM  method  is  presented  in  L.  Bass,  P.  Clements,  and  R.  Kazman,  \nSoftware Architecture in Practice, 3rd ed., Addison-Wesley, 2013.\nwww.EBooksWorld.ir\n3.10 Further Reading 73\nThe  ways  in  which  an  architecture  can  be  documented  are  covered  exten-\nsively in P. Clements et al. Documenting Software Architectures: Views and Be-\nyond,  2nd  ed.,  Addison-Wesley,  2011.  More  Agile  approaches  to  documenting  \nare discussed in books such as S. Brown, Software Architecture for Developers. \nLean Publishing, 2015.\nThe importance and challenges of capturing design rationale are discussed \nin A. Tang, M. Ali Babar, I. Gorton, and J. Han, “A Survey of Architecture Design \nRationale”, Journal of Systems and Software, 79(12):1792–1804, 2007. A mini-\nmalistic  technique  for  capturing  rationale  is  discussed  in  U.  Zdun,  R.  Capilla,","metadata":{"id":355}}],["808c5783-f9ab-4c13-9f14-3740db9a72f8",{"pageContent":"Rationale”, Journal of Systems and Software, 79(12):1792–1804, 2007. A mini-\nmalistic  technique  for  capturing  rationale  is  discussed  in  U.  Zdun,  R.  Capilla,   \nH.  Tran,  and  O.  Zimmermann,  “Sustainable  Architectural  Design  Decisions”,  \nIEEE Software, 30(6):46–53, 2013.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n75\n4\nCase Study: FCAPS \nSystem\nWe now present a case study of using ADD 3.0 for a greenfield system in a ma-\nture  domain.  This  case  study  details  an  initial  design  round  composed  of  three  \niterations and is based on a real-world example. We first present the business con-\ntext,  and  then  we  summarize  the  requirements  for  the  system.  This  is  followed  \nby a step-by-step summary of the activities that are performed during the ADD \niterations.\n4.1 Business Case\nIn  2006,  a  large  telecommunications  company  wanted  to  expand  its  Internet","metadata":{"id":356}}],["52210afa-1bca-4f55-9d03-b1473a9f8e89",{"pageContent":"by a step-by-step summary of the activities that are performed during the ADD \niterations.\n4.1 Business Case\nIn  2006,  a  large  telecommunications  company  wanted  to  expand  its  Internet  \nProtocol  (IP)  network  to  support  “carrier-class  services”,  and  more  specifically  \nhigh-quality voice over IP (VOIP) systems. One important aspect to achieve this \ngoal  was  synchronization  of  the  VOIP  servers  and  other  equipment.  Poor  syn-\nchronization results in low quality of service (QoS), degraded performance, and \nunhappy  customers.  To  achieve  the  required  level  of  synchronization,  the  com-\npany wanted to deploy a network of time servers that support the Network Time \nProtocol  (NTP).  Time  servers  are  formed  into  groups  that  typically  correspond  \nto  geographical  regions.  Within  these  regions,  time  servers  are  organized  hier-\narchically in levels or strata, where time servers placed in the upper level of the \nwww.EBooksWorld.ir","metadata":{"id":357}}],["c503077b-4633-4b85-99df-c460b554dafc",{"pageContent":"to  geographical  regions.  Within  these  regions,  time  servers  are  organized  hier-\narchically in levels or strata, where time servers placed in the upper level of the \nwww.EBooksWorld.ir\n76 Chapter 4—Case Study: FCAPS System\nhierarchy (stratum 1) are equipped with hardware (e.g., Cesium Oscillator, GPS \nsignal) that provides precise time. Time servers that are lower in the hierarchy use \nNTP to request time from servers in the upper levels or from their peers.\nMany pieces of equipment depend on the time provided by time servers in \nthe  network,  so  one  priority  for  the  company  was  to  correct  any  problems  that  \noccur  on  the  time  servers.  Such  problems  may  require  dispatching  a  technician  \nto perform physical maintenance on the time servers, such as rebooting. Another \npriority for the company was to collect data from the time servers to monitor the \nperformance of the synchronization framework.","metadata":{"id":358}}],["4c7526fd-5743-4ad7-aea2-a3ebcbdb0784",{"pageContent":"priority for the company was to collect data from the time servers to monitor the \nperformance of the synchronization framework.\nIn the initial deployment plans, the company wanted to field 100 time serv-\ners of a particular model. Besides NTP, time servers support the Simple Network \nManagement Protocol (SNMP), which provides three basic operations:\n§\tset() operations: change configuration variables (e.g., connected peers)\n§\tget() operations: retrieve configuration variables or performance data\n§\ttrap() operations: notifications of exceptional events such as the loss or \nrestoration of the GPS signal or changes in the time reference\nTo achieve the company’s goals, a management system for the time servers \nneeded  to  be  developed.  This  system  needed  to  conform  to  the  FCAPS  model,  \nwhich is a standard model for network management. The letters in the acronym \nstand for:\n§\tFault management. The goal of fault management is to recognize, isolate,","metadata":{"id":359}}],["531a3f6d-1b88-470b-8b94-174a08cfaf1e",{"pageContent":"which is a standard model for network management. The letters in the acronym \nstand for:\n§\tFault management. The goal of fault management is to recognize, isolate, \ncorrect, and log faults that occur in the network. In this case, these faults cor-\nrespond to traps generated by time servers or other problems such as loss of \ncommunication between the management system and the time servers.\n§\tConfiguration management. This includes gathering and storing config-\nurations from network devices, thereby simplifying the configuration of \ndevices and tracking changes that are made to device configurations. In this \nsystem, besides changing individual configuration variables, it is necessary \nto be able to deploy a specific configuration to several time servers.\n§\tAccounting. The goal here is to gather device information. In this context, \nthis includes tracking device hardware and firmware versions, hardware \nequipment, and other components of the system.","metadata":{"id":360}}],["22d76678-398e-488f-9cf4-662d0dc50d7c",{"pageContent":"§\tAccounting. The goal here is to gather device information. In this context, \nthis includes tracking device hardware and firmware versions, hardware \nequipment, and other components of the system.\n§\tPerformance management. This category focuses on determining the ef-\nficiency of the current network. By collecting and analyzing performance \ndata, the network health can be monitored. In this case, delay, offset, and \njitter measures are collected from the time servers.\n§\tSecurity management. This is the process of controlling access to assets in \nthe network. In this case, there are two important types of users: technicians \nand administrators. Technicians can visualize trap information and config-\nurations but cannot make changes; administrators are technicians who can \nvisualize the same information but can also make changes to configura-\ntions, including adding and removing time servers from the network.\nwww.EBooksWorld.ir\n4.2 System Requirements 77","metadata":{"id":361}}],["6a78a90b-1341-4b1e-886d-08485daa5b19",{"pageContent":"visualize the same information but can also make changes to configura-\ntions, including adding and removing time servers from the network.\nwww.EBooksWorld.ir\n4.2 System Requirements 77\nOnce the initial network was deployed, the company planned to extend it by \nadding  time  servers  from  newer  models  that  might  potentially  support  manage-\nment protocols other than SNMP.\nThe  remainder  of  this  chapter  describes  a  design  for  this  system,  created  \nusing ADD 3.0.\n4.2 System Requirements\nRequirement elicitation activities had been previously performed, and the follow-\ning is a summary of the most relevant requirements collected.\n4.2.1 Use Case Model\nThe use case model in Figure 4.1 presents the most relevant use cases that sup-\nport the FCAPS model in the system. Other use cases are not shown.\nFIGURE 4.1 Use case model for the FCAPS system\nwww.EBooksWorld.ir\n78 Chapter 4—Case Study: FCAPS System\nEach of these use cases is described in the following table:\nUse CaseDescription\nUC-1: Monitor","metadata":{"id":362}}],["7c8046a6-abce-49ec-a777-9a7a0df54131",{"pageContent":"FIGURE 4.1 Use case model for the FCAPS system\nwww.EBooksWorld.ir\n78 Chapter 4—Case Study: FCAPS System\nEach of these use cases is described in the following table:\nUse CaseDescription\nUC-1: Monitor \nnetwork status \n \nA user monitors the time servers in a hierarchical representation \nof the whole network. Problematic devices are highlighted, \nalong with the logical regions where they are grouped. The \nuser can expand and collapse the network representation. This \nrepresentation is updated continuously as faults are detected or \nrepaired.\nUC-2: Detect \nfault\nPeriodically the management system contacts the time servers \nto see if they are “alive”. If a time server does not respond, or \nif a trap that signals a problem or a return to a normal state \nof operation is received, the event is stored and the network \nrepresentation observed by the users is updated accordingly.\nUC-3: Display \nevent history\nStored events associated with a particular time server or group","metadata":{"id":363}}],["00182622-55ef-431a-a797-01c763e8c689",{"pageContent":"representation observed by the users is updated accordingly.\nUC-3: Display \nevent history\nStored events associated with a particular time server or group \nof time servers are displayed. These can be filtered by various \ncriteria such as type or severity.\nUC-4: Manage \ntime servers\nThe administrator adds a time server to, or removes a time server \nfrom, the network. \nUC-5: Configure \ntime server\nAn administrator changes configuration parameters associated \nwith a particular time server. The parameters are sent to the \ndevice and are also stored locally.\nUC-6: Restore \nconfiguration\nA locally stored configuration is sent to one or more time servers.\nUC-7: Collect \nperformance \ndata\nNetwork performance data (delay, offset, and jitter) is collected \nperiodically from the time servers.\nUC-8: Display \ninformation\nThe user displays stored information about the time server—\nconfiguration values and other parameters such as the server \nname.\nUC-9: Visualize \nperformance \ndata","metadata":{"id":364}}],["6eea6fa9-f7cc-4ea3-a64d-616d4e1a4b38",{"pageContent":"UC-8: Display \ninformation\nThe user displays stored information about the time server—\nconfiguration values and other parameters such as the server \nname.\nUC-9: Visualize \nperformance \ndata\nThe user displays network performance measures (delay, \noffset, jitter) in a graphical way to view and analyze network \nperformance.\nUC-10: Log inA user logs into the system through a login/password screen. \nUpon successful login, the user is presented with different \noptions according to their role.\nU-11: Manage \nusers\nThe administrator adds or removes a user or modifies user \npermissions.\n4.2.2 Quality Attribute Scenarios\nIn addition to these use cases, a number of quality attribute scenarios were elic-\nited and documented. The six most relevant ones are presented in the following \ntable. For each scenario, we also identify the use case that it is associated with. \nwww.EBooksWorld.ir\n4.2 System Requirements 79\nID\nQuality \nAttributeScenario\nAssociated \nUse Case\nQ A-1PerformanceSeveral time servers send traps to the","metadata":{"id":365}}],["77109908-a66e-44f9-9c08-fcb2d383c40f",{"pageContent":"www.EBooksWorld.ir\n4.2 System Requirements 79\nID\nQuality \nAttributeScenario\nAssociated \nUse Case\nQ A-1PerformanceSeveral time servers send traps to the \nmanagement system at peak load; 100% of \nthe traps are successfully processed and \nstored.\nUC-2\nQA-2ModifiabilityA new time server management protocol \nis introduced to the system as part of an \nupdate. The protocol is added successfully \nwithout any changes to the core \ncomponents of the system.\nUC-5\nQA-3AvailabilityA failure occurs in the management system \nduring normal operation. The management \nsystem resumes operation in less than 30 \nseconds.\nAll\nQA-4PerformanceThe management system collects \nperformance data from a time server \nduring peak load. The management system \ncollects all performance data within 5 \nminutes, while processing all user requests, \nto ensure no loss of data due to CON-5.\nUC-7\nQA-5Performance, \nusability\nA user displays the event history of a \nparticular time server during normal \noperation. The list of events from the last","metadata":{"id":366}}],["dde0bbd2-c408-45f6-a18c-571084319059",{"pageContent":"to ensure no loss of data due to CON-5.\nUC-7\nQA-5Performance, \nusability\nA user displays the event history of a \nparticular time server during normal \noperation. The list of events from the last \n24 hours is displayed within 1 second.\nUC-3\nQA-6SecurityA user performs a change in the system \nduring normal operation. It is possible to \nknow who performed the operation and \nwhen it was performed 100% of the time.\nAll\n4.2.3    Constraints\nFinally, a set of constraints on the system and its implementation were collected. \nThese are presented in the following table.\nIDConstraint\nCON -1A minimum of 50 simultaneous users must be supported.\nCON-2The system must be accessed through a web browser (Chrome V3.0+, \nFirefox V4+, IE8+) in different platforms: Windows, OSX, and Linux.\nCON-3An existing relational database server must be used. This server cannot be \nused for other purposes than hosting the database.\nCON-4The network connection to user workstations can have low bandwidth but \nis generally reliable.","metadata":{"id":367}}],["5162125e-9fb3-4806-9d1f-c4af5bf0c228",{"pageContent":"used for other purposes than hosting the database.\nCON-4The network connection to user workstations can have low bandwidth but \nis generally reliable.\nCON-5Performance data needs to be collected in intervals of no more than 5 \nminutes, as higher intervals result in time servers discarding data.\nCON-6Events from the last 30 days must be stored.\nwww.EBooksWorld.ir\n80 Chapter 4—Case Study: FCAPS System\n4.2.4 Architectural Concerns\nGiven  that  this  is  greenfield  development,  only  a  few  general  architectural  con-\ncerns are identified initially, as shown in the following table.\nIDConcern\nCRN -1Establishing an overall initial system structure.\nCRN-2Leverage the team’s knowledge about Java technologies, including \nSpring, JSF, Swing, Hibernate, Java Web Start and JMS frameworks, and \nthe Java language.\nCRN-3Allocate work to members of the development team.\nGiven these sets of inputs, we are now ready to proceed to describe the de-","metadata":{"id":368}}],["965bbe4a-eb4d-4dbf-bd4c-fa45fb9fc811",{"pageContent":"the Java language.\nCRN-3Allocate work to members of the development team.\nGiven these sets of inputs, we are now ready to proceed to describe the de-\nsign process, as described in Section 3.2. In this chapter, we present only the final \nresults of the requirements collection process. The job of collecting these require-\nments is nontrivial, but is beyond the scope of this chapter.\n4.3 The Design Process\nWe  now  ready  to  make  the  leap  from  the  world  of  requirements  and  business  \nconcerns  to  the  world  of  design.  This  is  perhaps  the  most  important  job  for  an  \narchitect—translating requirements into design decisions. Of course, many other \ndecisions and duties are important, but this is the core of what it means to be an \narchitect: making design decisions with far-reaching consequences.\n4.3.1 ADD Step 1: Review Inputs\nThe first step of the ADD method involves reviewing the inputs and identifying","metadata":{"id":369}}],["ce00a1da-ba97-4080-ba73-5772fe613155",{"pageContent":"architect: making design decisions with far-reaching consequences.\n4.3.1 ADD Step 1: Review Inputs\nThe first step of the ADD method involves reviewing the inputs and identifying \nwhich requirements will be considered as drivers (i.e., which will be included in \nthe design backlog). The inputs are summarized in the following table.\nCategoryDetails\nDesign purposeThis is a greenfield system from a mature domain. The purpose \nis to produce a sufficiently detailed design to support the \nconstruction of the system.\nPrimary functional \nrequirements\nFrom the use cases presented in Section 4.2.1, the primary \nones were determined to be:\nUC-1: Because it directly supports the core business\nUC-2: Because it directly supports the core business\nUC-7: Because of the technical issues associated with it  \n(see QA-4)\nwww.EBooksWorld.ir\n4.3 The Design Process 81\nQuality attribute \nscenarios\nThe scenarios were described in Section 4.2.2. They have now \nbeen prioritized (as discussed in Section 2.4.2) as follows:\nScenario \nID","metadata":{"id":370}}],["ae84cc16-9cf4-4963-904f-e3a879451846",{"pageContent":"4.3 The Design Process 81\nQuality attribute \nscenarios\nThe scenarios were described in Section 4.2.2. They have now \nbeen prioritized (as discussed in Section 2.4.2) as follows:\nScenario \nID\nImportance to \nthe Customer\nDifficulty of Implementation \nAccording to the Architect\nQ A-1HighHigh\nQA-2HighMedium\nQA-3HighHigh\nQA-4HighHigh\nQA-5MediumMedium\nQA-6MediumLow\nFrom this list, only QA-1, QA-2, QA-3, and QA-4 are selected as \ndrivers.\nConstraintsAll of the constraints discussed in Section 4.2.3 are included as \ndrivers.\nArchitectural \nconcerns\nAll of the architectural concerns discussed in Section 4.2.4 are \nincluded as drivers.\n4.3.2 Iteration 1: Establishing an Overall System Structure\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD in the first iteration of the design process.\n4.3.2.1 Step 2: Establish Iteration Goal by Selecting Drivers\nThis is the first iteration in the design of a greenfield system, so the iteration goal","metadata":{"id":371}}],["0c67ec06-bae0-4c58-abd5-987c86bf929a",{"pageContent":"4.3.2.1 Step 2: Establish Iteration Goal by Selecting Drivers\nThis is the first iteration in the design of a greenfield system, so the iteration goal \nis to achieve the architectural concern CNR-1 of establishing an overall system \nstructure (see Section 3.3.1).\nAlthough this iteration is driven by a general architectural concern, the ar-\nchitect must keep in mind all of the drivers that may influence the general struc-\nture of the system. In particular, the architect must be mindful of the following:\n§\tQA-1: Performance\n§\tQA-2: Modifiability\n§\tQA-3: Availability\n§\tQA-4: Performance\n§\tCON-2: System must be accessed through a web browser in different \nplatforms—Windows, OSX, and Linux\n§\tCON-3: A relational database server must be used\n§\tCON-4: Network connection to users workstations can have low bandwidth \nand be unreliable\n§\tCRN-2: Leverage team’s knowledge about Java technologies\nwww.EBooksWorld.ir\n82 Chapter 4—Case Study: FCAPS System\nTime server\nLegend:\nFIGURE 4.2 Context diagram for the FCAPS system","metadata":{"id":372}}],["ae017e96-a7cf-4a62-bfd3-076fee9d1f64",{"pageContent":"and be unreliable\n§\tCRN-2: Leverage team’s knowledge about Java technologies\nwww.EBooksWorld.ir\n82 Chapter 4—Case Study: FCAPS System\nTime server\nLegend:\nFIGURE 4.2 Context diagram for the FCAPS system \n4.3.2.2 Step 3: Choose One or More Elements of the System to Refine\nThis is a greenfield development effort, so in this case the element to refine is the \nentire  FCAPS  system,  which  is  shown  in  Figure  4.2.  In  this  case,  refinement  is  \nperformed through decomposition.\n4.3.2.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nIn  this  initial  iteration,  given  the  goal  of  structuring  the  entire  system,  design  \nconcepts  are  selected  according  to  the  roadmap  presented  in  Section  3.3.1.  The  \nfollowing table summarizes the selection of design decisions. Note that all of the \ndesign concepts used in this case study are also described in Appendix A.\nDesign Decisions \nand LocationRationale\nLogically structure \nthe client part of the","metadata":{"id":373}}],["d79b29cf-3290-49be-aa15-2f6013a22c85",{"pageContent":"design concepts used in this case study are also described in Appendix A.\nDesign Decisions \nand LocationRationale\nLogically structure \nthe client part of the \nsystem using the Rich \nClient Application \nreference architecture\nThe Rich Client Application (RCA) reference architecture \n(see Section A.1.2) supports the development of applica-\ntions that are installed in the users’ PC. These applications \nsupport rich user interface capabilities that are needed for \ndisplaying the network topology and performance graphs \n(UC-1). These capabilities are also helpful in achieving \nQA-5, even if this design decision is not a driver. Although \nthese types of applications do not run in a web browser \n(CON-2), they can be installed from a web browser using a \ntechnology such as Java Web Start.\nwww.EBooksWorld.ir\n4.3 The Design Process 83\nDesign Decisions \nand LocationRationale\nDiscarded alternatives:\nAlternativeReason for Discarding\nRich Internet \napplications \n(RIA)\nThis reference architecture (see Section","metadata":{"id":374}}],["8a805f20-3c8c-4e7e-979b-bf5a30ca71ad",{"pageContent":"4.3 The Design Process 83\nDesign Decisions \nand LocationRationale\nDiscarded alternatives:\nAlternativeReason for Discarding\nRich Internet \napplications \n(RIA)\nThis reference architecture (see Section \nA.1.3) is oriented toward the develop-\nment of applications with a rich user \ninterface that runs inside a web browser.\nAlthough this type of application supports \na rich user interface and can be up-\ngraded easily, this option was discarded \nbecause it was believed that plugins for \nexecuting RIA were less broadly available \nthan the Java Virtual Machine.\nWeb \napplications\nThis reference architecture (see Section \nA.1.1) is oriented toward the development \nof applications that are accessed from \na web browser. Although this reference \narchitecture facilitates deployment and \nupdating, it was discarded because it is \ndifficult to provide a rich user interface \nexperience.\nMobile \napplications\nThis reference architecture (see \nSection A.1.4) is oriented toward the \ndevelopment of applications that are","metadata":{"id":375}}],["889731ae-1bca-4e2e-9ec2-07cd5f5bfd09",{"pageContent":"difficult to provide a rich user interface \nexperience.\nMobile \napplications\nThis reference architecture (see \nSection A.1.4) is oriented toward the \ndevelopment of applications that are \ndeployed in handheld devices. This \nalternative was discarded because this \ntype of device was not considered for \naccessing the system.\nLogically structure \nthe server part of \nthe system using the \nService Application \nreference architecture\nService applications (see Section A.1.5) do not provide a \nuser interface but rather expose services that are consumed \nby other applications.\nNo other alternatives were considered and discarded, as the \narchitect was familiar with this reference architecture and \nconsidered it fully adequate to meet the requirements.\nPhysically structure \nthe application \nusing the three-tier \ndeployment pattern\nSince the system must be accessed from a web browser \n(CON-2) and an existing database server must also be \nused (CON-3), a three-tier deployment is appropriate (see \nSection A.2.2).","metadata":{"id":376}}],["571e52ca-569d-4432-9bf8-3225bcea1903",{"pageContent":"deployment pattern\nSince the system must be accessed from a web browser \n(CON-2) and an existing database server must also be \nused (CON-3), a three-tier deployment is appropriate (see \nSection A.2.2).\nAt this point, it is clear that some type of replication will be \nneeded on both the web/app tier and the database tier to \nsupport QA-3, but this will be addressed later (in iteration 3).\nDiscarded alternatives include other n-tier patterns with \nn != 3. The two-tier alternative is discarded because an \nexisting legacy database server needs to be incorporated \ninto the system and this cannot be used for any other \npurpose, according to CON-3. All n > 3 alternatives are \ndiscarded because at this point no other servers are \nnecessary for the solution.\n(\ncontinues)\nwww.EBooksWorld.ir\n84 Chapter 4—Case Study: FCAPS System\nDesign Decisions \nand LocationRationale\nBuild the user \ninterface of the client \napplication using \nthe Swing Java \nframework and other \nJava technologies","metadata":{"id":377}}],["f0f80029-c278-49be-a60a-0c585a970319",{"pageContent":"84 Chapter 4—Case Study: FCAPS System\nDesign Decisions \nand LocationRationale\nBuild the user \ninterface of the client \napplication using \nthe Swing Java \nframework and other \nJava technologies\nThe standard framework for building Java Rich Clients \nensures portability (CON-2) and it is what the developers \nwere already familiar with (CRN-3).\nDiscarded alternatives: The Eclipse SWT (Standard Widget \nToolkit) framework was considered, but the developers were \nnot as familiar with it. \nDeploy the application \nusing the Java Web \nStart technology\nAccess to the application is obtained via a web browser, \nwhich launches the installer (CON-2).\nThis technology also facilitates updating because client \ncode is reloaded only when a new version is available. \nAs updates are not expected to occur frequently, this is \nbeneficial for low-bandwidth situations (CON-4).\nThe alternative would be the use of applets, but they need \nto be reloaded every time the web page is loaded, which \nincreases the bandwidth requirements.","metadata":{"id":378}}],["8e18b3ce-f6ae-46b5-838c-35c8408010f0",{"pageContent":"beneficial for low-bandwidth situations (CON-4).\nThe alternative would be the use of applets, but they need \nto be reloaded every time the web page is loaded, which \nincreases the bandwidth requirements.\n4.3.2.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nThe  instantiation  design  decisions  considered  and  made  are  summarized  in  the  \nfollowing table:\nDesign Decision and \nLocationRationale\nRemove local data sources \nin the rich client application\nIt is believed that there is no need to store data locally, \nas the network connection is generally reliable.\nAlso, communication with the server is handled in \nthe data layer. Internal communication between \ncomponents in the client is managed through local \nmethod calls and does not need particular support.\nCreate a module dedicated \nto accessing the time \nservers in the data layer \nof the Service Application \nreference architecture\nThe service agents component from the reference","metadata":{"id":379}}],["309d137e-4a59-475a-8a03-0451ceb939db",{"pageContent":"Create a module dedicated \nto accessing the time \nservers in the data layer \nof the Service Application \nreference architecture\nThe service agents component from the reference \narchitecture is adapted to abstract the access to the \ntime servers. This will further facilitate the achievement \nof QA-2 and will play a critical role in the achievement \nof UC-2 and UC-7.\nThe results of these instantiation decisions are recorded in the next step. In \nthis initial iteration, it is typically too early to precisely define functionality and \ninterfaces.  In  the  next  iteration,  which  is  dedicated  to  defining  functionality  in  \nmore detail, interfaces will begin to be defined.\n4.3.2.5 Step 6: Sketch Views and Record Design Decisions\nThe diagram in Figure 4.3 shows the sketch of a module view of the two refer-\nence architectures that were selected for the client and server applications. These \nhave now been adapted according to the design decisions we have made.\nwww.EBooksWorld.ir\n4.3 The Design Process 85","metadata":{"id":380}}],["46309698-c18b-4a40-b362-ffda4c0d8e53",{"pageContent":"ence architectures that were selected for the client and server applications. These \nhave now been adapted according to the design decisions we have made.\nwww.EBooksWorld.ir\n4.3 The Design Process 85\n«Layer»\nPresentation CS\n«Layer»\nBusiness logic CS\n«Layer»\nData CS\n«Swing»\nUI Modules\nUI Process Modules\nClient Side\nServer Side\n«Layer»\nCross-cutting CS\nBusiness Modules CS\nBusiness Entities CS\n«Module»\nCommunication Modules\nSecurity Module CS\nOp. Mgmt. Module CS\n«Layer»\nServices SS\nService Interfaces\n«Layer»\nBusiness Logic SS\nBusiness Modules SS\nBusiness Entities SS\n«Layer»\nData SS\nDB Access Module\nTime Server Access Module\n«Layer»\nCross-cutting SS\nSecurity Module SS\nOp. Mgmt. Module SS\nCommunication Module SS\nFIGURE 4.3 Modules obtained from the selected reference architectures (Key: UML)\nwww.EBooksWorld.ir\n86 Chapter 4—Case Study: FCAPS System\nThis sketch was created using a CASE tool. In the tool, each element is selected \nand a short description of its responsibilities is captured. Note that the descriptions","metadata":{"id":381}}],["2facd5ed-7351-409a-8a9d-0ee1055d162f",{"pageContent":"This sketch was created using a CASE tool. In the tool, each element is selected \nand a short description of its responsibilities is captured. Note that the descriptions \nat this point are quite crude, just indicating major functional responsibilities, with no \ndetails. The following table summarizes the information that is captured:\nElementResponsibility\nPresentation client \nside (CS)\nThis layer contains modules that control user interaction and \nuse case control flow.\nBusiness logic CSThis layer contains modules that perform business logic \noperations that can be executed locally on the client side.\nData CSThis layer contains modules that are responsible for \ncommunication with the server.\nCross-cutting CSThis “layer” includes modules with functionality that goes \nacross different layers, such as security, logging, and I/O. \nThis is helpful in achieving QA-6, even if it is not one of the \ndrivers.\nUI modulesThese modules render the user interface and receive user \ninputs.","metadata":{"id":382}}],["616db2a1-5036-486e-a5fb-97794c96b85e",{"pageContent":"This is helpful in achieving QA-6, even if it is not one of the \ndrivers.\nUI modulesThese modules render the user interface and receive user \ninputs.\nUI process modulesThese modules are responsible for control flow of all the \nsystem use cases (including navigation between screens).\nBusiness modules \nCS\nThese modules either implement business operations that \ncan be performed locally or expose business functionality \nfrom the server side.\nBusiness entities CSThese entities make up the domain model. They may be less \ndetailed than those on the server side.\nCommunication \nmodules CS\nThese modules consume the services provided by the \napplication running on the server side.\nServices server side \n(SS)\nThis layer contains modules that expose services that are \nconsumed by the clients.\nBusiness Logic SSThis layer contains modules that perform business logic \noperations that require processing on the server side.\nData SSThis layer contains modules that are responsible for data","metadata":{"id":383}}],["60c04830-3227-4bc8-aa46-e8c7c95e469d",{"pageContent":"Business Logic SSThis layer contains modules that perform business logic \noperations that require processing on the server side.\nData SSThis layer contains modules that are responsible for data \npersistence and for communication with the time servers.\nCross-cutting SSThese modules have functionality that goes across different \nlayers, such as security, logging, and I/O.\nService interfaces \nSS\nThese modules expose services that are consumed by the \nclients.\nBusiness modules \nSS\nThese modules implement business operations.\nBusiness entities SS    These entities make up the domain model. \nDB access moduleThis module is responsible for persistence of business \nentities (objects) into the relational database. It performs \nobject-oriented to relational mapping and shields the rest of \nthe application from persistence details.\nwww.EBooksWorld.ir\n4.3 The Design Process 87\nElementResponsibility\nTime server access \nmodule\nThis module is responsible for communication with the time","metadata":{"id":384}}],["8b74d2a6-633b-47fc-8ad2-67c1c09a1aee",{"pageContent":"the application from persistence details.\nwww.EBooksWorld.ir\n4.3 The Design Process 87\nElementResponsibility\nTime server access \nmodule\nThis module is responsible for communication with the time \nservers. It isolates and abstracts operations with the time \nservers to support communication with different types of \ntime servers (see QA-2).\nThe deployment diagram in Figure 4.4 sketches an allocation view that illus-\ntrates where the components associated with the modules in the previous diagram \nwill be deployed.\nThe responsibilities of the elements are summarized here:\nElementResponsibility\nUser workstationThe user’s PC, which hosts the client side logic of the \napplication\nApplication serverThe server that hosts server side logic of the application and \nalso serves web pages\nDatabase serverThe server that hosts the legacy relational database\nTime serverThe set of (external) time servers\nAlso,  information  about  relationships  between  some  elements  in  the  dia-","metadata":{"id":385}}],["d0e6f40e-1126-4abc-9ed8-1e618824eeac",{"pageContent":"Database serverThe server that hosts the legacy relational database\nTime serverThe set of (external) time servers\nAlso,  information  about  relationships  between  some  elements  in  the  dia-\ngram that is worth recording is summarized in the following table:\nRelationshipDescription\nBetween web/app server and \ndatabase server\nCommunication with the database will be \ndone using the JDBC protocol.\nBetween web/app server and time \nserver\nThe SNMP protocol is used (at least initially).\npc :User Workstation\n«replicated»\n:Application Server\n«replicated»\ndatabase :Database Server\n:Time Server\nServer-Side Application\n«Java Web Start»\nClient-Side \nApplication\n«SNMP»\n«JDBC»\nFIGURE 4.4 Initial deployment diagram for the FCAPS system (Key: UML)\nwww.EBooksWorld.ir\n88 Chapter 4—Case Study: FCAPS System\n4.3.2.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  following  table  summarizes  the  design  progress  using  the  Kanban  board","metadata":{"id":386}}],["b0e2ef98-b9e4-4be5-a2d6-ab51f4c8d1ca",{"pageContent":"4.3.2.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  following  table  summarizes  the  design  progress  using  the  Kanban  board  \ntechnique discussed in Section 3.8.2.\nNot \nAddressed\nPartially \nAddressed \nCompletely\nAddressed\nDesign Decisions Made During \nthe Iteration\nUC -1Selected reference architecture \nestablishes the modules that will \nsupport this functionality.\nUC-2Selected reference architecture \nestablishes the modules that will \nsupport this functionality.\nUC-7Selected reference architecture \nestablishes the modules that will \nsupport this functionality.\nQ A-1No relevant decisions made, as it is \nnecessary to identify the elements \nthat participate in the use case that \nis associated with the scenario.\nQA-2Introduction of a time server access \nmodule in the data layer on the \nserver application that encapsulates \ncommunication with the time serv-\ners. The details of this component \nand its interfaces have not been \ndefined yet.","metadata":{"id":387}}],["bb9f8604-3fd9-4954-979f-724fa5fa2dbe",{"pageContent":"module in the data layer on the \nserver application that encapsulates \ncommunication with the time serv-\ners. The details of this component \nand its interfaces have not been \ndefined yet.\nQA-3Identification of the elements \nderived from the deployment pattern \nthat will need to be replicated.\nQA-4No relevant decisions made, as it is \nnecessary to identify the elements \nthat participate in the use case that \nis associated with the scenario.\nCON -1Structuring the system using 3 tiers \nwill allow multiple clients to connect \nto the application server. Decisions \nregarding concurrent access have \nnot been made yet.\nCON-2Use of Java Web Start technology \nallows access through a web \nbrowser to download the Rich \nClient. Since the Rich Client is being \nprogrammed in Java, this supports \nexecution under Windows, OSX, \nand Linux.\nwww.EBooksWorld.ir\n4.3 The Design Process 89\nNot \nAddressed\nPartially \nAddressed \nCompletely\nAddressed\nDesign Decisions Made During \nthe Iteration\nCON-3Physically structure the application","metadata":{"id":388}}],["102bc43a-8ecb-42b2-b688-32dd0988b285",{"pageContent":"and Linux.\nwww.EBooksWorld.ir\n4.3 The Design Process 89\nNot \nAddressed\nPartially \nAddressed \nCompletely\nAddressed\nDesign Decisions Made During \nthe Iteration\nCON-3Physically structure the application \nusing the 3-tier deployment \npattern, and isolate the database \nby providing database access \ncomponents in the data layer of the \napplication server.\nCON-4Use of Java Web Start technology \nrequires the client to be downloaded \nonly the first time, and then when \nupgrades occur. This is helpful \nto support limited-bandwidth \nconnections. More decisions \nneed to be made regarding the \ncommunication between the \npresentation and the business logic \nlayers.\nCON-5No relevant decisions made.\nCON-6No relevant decisions made.\nCRN -1 Selection of reference architectures \nand deployment pattern.\nCRN-2Technologies that have been \nconsidered up to this point take \ninto account the knowledge of the \ndevelopers. Other technologies \nstill need to be selected (e.g., \ncommunication with the time \nservers).\nCRN-3No relevant decisions made.","metadata":{"id":389}}],["e5bbe8eb-3fee-46b7-8774-d27eb66581e4",{"pageContent":"considered up to this point take \ninto account the knowledge of the \ndevelopers. Other technologies \nstill need to be selected (e.g., \ncommunication with the time \nservers).\nCRN-3No relevant decisions made.\n4.3.3 Iteration 2: Identifying Structures to Support \nPrimary Functionality\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD in the second iteration of the design process for the FCAPS system. \nIn  this  iteration,  we  move  from  the  generic  and  coarse-grained  descriptions  of  \nfunctionality used in iteration 1 to more detailed decisions that will drive imple-\nmentation and hence the formation of development teams.\nThis movement from the generic to the specific is intentional, and built into \nthe  ADD  method.  We  cannot  design  everything  up  front,  so  we  need  to  be  dis-\nciplined  about  which  decisions  we  make,  and  when,  to  ensure  that  the  design","metadata":{"id":390}}],["514d93e9-013f-4841-bab8-60668a3680eb",{"pageContent":"the  ADD  method.  We  cannot  design  everything  up  front,  so  we  need  to  be  dis-\nciplined  about  which  decisions  we  make,  and  when,  to  ensure  that  the  design  \nis  done  in  a  systematic  way,  addressing  the  biggest  risks  first  and  moving  from  \nthere to ever finer details. Our goal for the first iteration was to establish an over-\nall system structure. Now that this goal has been met, our new goal for this sec-\nond  iteration  is  to  reason  about  the  units  of  implementation,  which  affect  team  \nwww.EBooksWorld.ir\n90 Chapter 4—Case Study: FCAPS System\nformation, interfaces, and the means by which development tasks may be distrib-\nuted, outsourced, and implemented in sprints.\n4.3.3.1 Step 2: Establish Iteration Goal by Selecting Drivers\nThe goal of this iteration is to address the general architectural concern of identify-\ning structures to support primary functionality. Identifying these elements is useful","metadata":{"id":391}}],["b7b01bd3-f6bc-44ff-be38-c21fe3f34d19",{"pageContent":"The goal of this iteration is to address the general architectural concern of identify-\ning structures to support primary functionality. Identifying these elements is useful \nnot only for understanding how functionality is supported, but also for addressing \nCRN-3—that is, the allocation of work to members of the development team.\nIn this second iteration, besides CRN-3, the architect considers the system’s \nprimary use cases:\n§\tUC-1\n§\tUC-2\n§\tUC-7\n4.3.3.2 Step 3: Choose One or More Elements of the System to Refine\nThe elements that will be refined in this iteration are the modules located in the \ndifferent  layers  defined  by  the  two  reference  architectures  from  the  previous  \niteration.  In  general,  the  support  of  functionality  in  this  system  requires  the  \ncollaboration  of  components  associated  with  modules  that  are  located  in  the  \ndifferent layers.\n4.3.3.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers","metadata":{"id":392}}],["43557074-5679-44dd-a06f-a368b81eb0de",{"pageContent":"collaboration  of  components  associated  with  modules  that  are  located  in  the  \ndifferent layers.\n4.3.3.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nIn  this  iteration,  several  design  concepts—in  this  case,  architectural  design  pat-\nterns—are  selected  from  the  book  Pattern  Oriented  Software  Architecture,  Vol-\nume 4. The following table summarizes the design decisions. The words in bold \nin  the  following  table  refer  to  architectural  patterns  from  this  book,  and  can  be  \nfound in Appendix A.\nDesign Decisions \nand LocationRationale and Assumptions\nCreate a Domain \nModel for the \napplication\nBefore starting a functional decomposition, it is necessary to \ncreate an initial domain model for the system, identifying the \nmajor entities in the domain, along with their relationships.\nThere are no good alternatives. A domain model must \neventually be created, or it will emerge in a suboptimal","metadata":{"id":393}}],["e6700e1a-4c20-4913-bc59-b83d3cb4efc3",{"pageContent":"major entities in the domain, along with their relationships.\nThere are no good alternatives. A domain model must \neventually be created, or it will emerge in a suboptimal \nfashion, leading to an ad hoc architecture that is hard to \nunderstand and maintain.\nIdentify Domain \nObjects that \nmap to functional \nrequirements\nEach distinct functional element of the application needs \nto be encapsulated in a self-contained building block—a \ndomain object.\nOne possible alternative is to not consider domain objects \nand instead directly decompose layers into modules, but this \nincreases the risk of not considering a requirement.\nwww.EBooksWorld.ir\n4.3 The Design Process 91\nDesign Decisions \nand LocationRationale and Assumptions\nDecompose Domain \nObjects into general \nand specialized \nComponents \nDomain objects represent complete sets of functionality, \nbut this functionality is supported by finer-grained elements \nlocated within the layers. The “components” in this pattern \nare what we have referred to as modules.","metadata":{"id":394}}],["ea35897e-41a4-4c79-8235-3add50c5ce13",{"pageContent":"but this functionality is supported by finer-grained elements \nlocated within the layers. The “components” in this pattern \nare what we have referred to as modules.\nSpecialization of modules is associated with the layers where \nthey are located (e.g., UI modules).\nThere are no good alternatives to decomposing the layers \ninto modules to support functionality.\nUse Spring \nframework and \nHibernate\nSpring is a widely used framework to support enterprise \napplication development. Hibernate is an object to relational \nmapping (ORM) framework that integrates well with Spring.\nAn alternative that was considered for application develop-\nment is JEE. Spring was eventually selected because it was \nconsidered more “lightweight” and the development team \nwas already familiar with it, resulting in greater and earlier \nproductivity.\nOther ORM frameworks were not considered, as the \ndevelopment team already was familiar with, and happy with \nthe performance of, Hibernate.","metadata":{"id":395}}],["85c2819a-b539-499d-8a3f-f03dc104184b",{"pageContent":"productivity.\nOther ORM frameworks were not considered, as the \ndevelopment team already was familiar with, and happy with \nthe performance of, Hibernate.\n4.3.3.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nThe  instantiation  design  decisions  made  in  this  iteration  are  summarized  in  the  \nfollowing table:\nDesign Decisions \nand LocationRationale\nCreate only an initial \ndomain model\nThe entities that participate in the primary use cases need to \nbe identified and modeled but only an initial domain model is \ncreated, to accelerate this phase of design.\nMap the system use \ncases to domain \nobjects\nAn initial identification of domain objects can be made by an-\nalyzing the system’s use cases. To address CRN-3, domain \nobjects are identified for all of the use cases in Section 4.2.1.\nDecompose the \ndomain objects \nacross the layers to \nidentify layer-specific \nmodules with an \nexplicit interface\nThis technique ensures that modules that support all of the","metadata":{"id":396}}],["c5b002a6-473b-4801-9ea8-ea5409baa9f1",{"pageContent":"Decompose the \ndomain objects \nacross the layers to \nidentify layer-specific \nmodules with an \nexplicit interface\nThis technique ensures that modules that support all of the \nfunctionalities are identified.\nThe architect will perform this task just for the primary use \ncases. This allows another team member to identify the rest of \nthe modules, thereby allocating work among team members.\nHaving established the set of modules, the architect realizes \nthe need to test these modules, so a new architectural \nconcern is identified here:\nCRN-4: A majority of modules shall be unit tested.\nOnly “a majority of modules” are covered by this concern \nbecause the modules that implement user interface \nfunctionality are difficult to test independently.\n(\ncontinues)\nwww.EBooksWorld.ir\n92 Chapter 4—Case Study: FCAPS System\nDesign Decisions \nand LocationRationale\nConnect components \nassociated with \nmodules using \nSpring\nThis framework uses an inversion of control approach that","metadata":{"id":397}}],["e984f2e5-1c16-450d-b67f-a6b86e348bdd",{"pageContent":"92 Chapter 4—Case Study: FCAPS System\nDesign Decisions \nand LocationRationale\nConnect components \nassociated with \nmodules using \nSpring\nThis framework uses an inversion of control approach that \nallows different aspects to be supported and the modules to \nbe unit-tested (CRN-4).\nAssociate \nframeworks with a \nmodule in the data \nlayer\nORM mapping is encapsulated in the modules that are \ncontained in the data layer. The Hibernate framework \npreviously selected is associated with these modules.\nWhile the structures and interfaces are identified in this step of the method, \nthey are captured in the next step.\n4.3.3.5 Step 6: Sketch Views and Record Design Decisions\nAs a result of the decisions made in step 5, several diagrams are created. \n§\tFigure 4.5 shows an initial domain model for the system.\n§\tFigure 4.6 shows the domain objects that are instantiated for the use case \nmodel in Section 4.2.1.\n§\tFigure 4.7 shows a sketch of a module view with modules that are derived","metadata":{"id":398}}],["29d44826-5341-452a-96da-7ff6ebb703b8",{"pageContent":"§\tFigure 4.6 shows the domain objects that are instantiated for the use case \nmodel in Section 4.2.1.\n§\tFigure 4.7 shows a sketch of a module view with modules that are derived \nfrom the business objects and associated with the primary use cases. Note \nthat explicit interfaces are not shown but their existence is assumed.\nThe responsibilities for the elements identified in Figure 4.7 are summarized \nin the table that begins on page 95.\nwww.EBooksWorld.ir\n4.3 The Design Process 93\nTime Server\n- deviceName\n- ipAddress\n- model\nEvent\n- date\n- payload\n- severity\n- type\nRegion\n- name\nConfiguration\n- configurationParameters\nPerformance Data\n- delay:  DataSet\n- jitter:  DataSet\n- offset:  DataSet\nUser\n- login\n- password\n- permissions\n- type\n0..*\n-parent\n0..*\n1\n1\ngenerates\n0..*\n1..*\n1\nacknowledges\nFIGURE 4.5 Initial domain model (Key: UML)\n«domain object»\nNetwork Status Monitoring\nresponsibilities\nUC-1\n«domain object»\nFault Detection\nresponsibilities\nUC-2\n«domain object»\nEvent history\nresponsibilities\nUC-3\n«domain object»\nTime Server Management","metadata":{"id":399}}],["155671f6-7751-4e8f-9096-2a2d3433b138",{"pageContent":"«domain object»\nNetwork Status Monitoring\nresponsibilities\nUC-1\n«domain object»\nFault Detection\nresponsibilities\nUC-2\n«domain object»\nEvent history\nresponsibilities\nUC-3\n«domain object»\nTime Server Management\nresponsibilities\nUC-4\n«domain object»\nTime Server Configuration\nresponsibilities\nUC-5\nUC-6\n«domain object»\nSystem Access\nresponsibilities\nUC-10\n«domain object»\nPerformance Data and Information Display\nresponsibilities\nUC-8\nUC-9\n«domain object»\nPerformance and Data Collection\nresponsibilities\nUC-7\n«domain object»\nUser Management\nresponsibilities\nUC-11\nFIGURE 4.6 Domain objects associated with the use case model (Key: UML)\nwww.EBooksWorld.ir\n94 Chapter 4—Case Study: FCAPS System\nServer Side\nClient Side\n«Layer»\nPresentation CS\n«Layer»\nBusiness logic CS\n«Layer»\nData CS\n«Layer»\nServices SS\n«Layer»\nBusiness Logic SS\n«Layer»\nData SS\nNetworkStatusMonitoringView\nNetworkStatusMonitoringController\nRequestManager\n«facade»\nRequestService\nTopologyController\nDomainEntities\nRegionDataMapper\nTimeServerDataMapper\nEventDataMapper\nTimeServerConnector","metadata":{"id":400}}],["c55a5da9-1ce1-4d4e-8237-26bb717f7ccd",{"pageContent":"NetworkStatusMonitoringView\nNetworkStatusMonitoringController\nRequestManager\n«facade»\nRequestService\nTopologyController\nDomainEntities\nRegionDataMapper\nTimeServerDataMapper\nEventDataMapper\nTimeServerConnector\nTimeServerEventsController\nDataCollectionController\nFIGURE 4.7 Modules that support the primary use cases (Key: UML)\nwww.EBooksWorld.ir\n4.3 The Design Process 95\nElementResponsibility\nNetworkStatusMonitoringView\nDisplays the network representation and \nupdates it when events are received. \nThis component embodies both UI com-\nponents and UI process components \nfrom the reference architecture.\nNetworkStatusMonitoringController\nResponsible for providing the necessary \ninformation to the presentation layer for \ndisplaying the network representation.\nRequestManager\nResponsible for communication with the \nserver-side logic.\nRequestService\nProvides a facade that receives \nrequests from the clients.\nTopologyController\nContains business logic related to the \ntopological information.\nDomainEntities","metadata":{"id":401}}],["dd281049-4974-4c49-b437-58b420e7df70",{"pageContent":"server-side logic.\nRequestService\nProvides a facade that receives \nrequests from the clients.\nTopologyController\nContains business logic related to the \ntopological information.\nDomainEntities\nContains the entities from the domain \nmodel (server side).\nTimeServerEventsController\nContains business logic related to the \nmanagement of events.\nDataCollectionController\nContains logic to perform data \ncollection and storage.\nRegionDataMapper\nResponsible for persistence operations \n(CRUD) related to the regions.\nTimeServerDataMapper\nResponsible for persistence operations \n(CRUD) related to the time servers.\nEventDataMapper\nResponsible for persistence operations \n(CRUD) related to the events.\nTimeServerConnector\nResponsible for communication with the \ntime servers. It isolates and abstracts \noperations with the time servers to \nsupport communication with different \ntypes of time servers (see QA-2).\nwww.EBooksWorld.ir\n96 Chapter 4—Case Study: FCAPS System","metadata":{"id":402}}],["81b4bf60-23c5-42d9-ab5c-601299eaeb69",{"pageContent":"operations with the time servers to \nsupport communication with different \ntypes of time servers (see QA-2).\nwww.EBooksWorld.ir\n96 Chapter 4—Case Study: FCAPS System\nThe following sequence diagrams for UC-1 and UC-2 were created in the pre-\nvious step of the method to define interfaces (as discussed in Section 3.6). A similar \ndiagram was also created for UC-7 but is not shown here due to space limitations.\nUC-1: Monitor Network Status\nFigure 4.8 shows an initial sequence diagram for UC-1 (monitor network status). It \nshows how the user representation of the topology is displayed on startup (after the \nuser has successfully logged into the system). Upon launch, the topology is requested \nfrom the TopologyController on the server. This element retrieves the root re-\ngion  through  the  RegionDataMapper  and  returns  it  to  the  client.  The  client  can  \nthen populate the view by traversing the relationships within the Region class.\nServerClient\nTechnician","metadata":{"id":403}}],["d6e034a7-edda-4bab-8cea-6b3b4a010d30",{"pageContent":"gion  through  the  RegionDataMapper  and  returns  it  to  the  client.  The  client  can  \nthen populate the view by traversing the relationships within the Region class.\nServerClient\nTechnician\n:NetworkStatusMonitoringView:NetworkStatusMonitoringController:RequestManager:RequestService:TopologyController:RegionDataMapper\nlaunch()\ninitialize()\nrequestTopology()\nsendRequest(Request)\nrequestTopology()\nretrieve(id) :Region\n:Region\n:Region\n:Response\n:Region\n:boolean\ngetRootRegion() :Region\npopulateView()\ninteract()\nFIGURE 4.8 Sequence diagram for use case UC-1 (Key: UML)\nFrom the interactions identified in the sequence diagram, initial methods for \nthe interfaces of the interacting elements can be identified:\nwww.EBooksWorld.ir\n4.3 The Design Process 97\nMethod NameDescription\nElement: NetworkStatusMonitoringContoller\nboolean initialize()\nOpens up the network representation so that \nusers can interact with it.\nRegion getRootRegion()\nReturns a reference to the root region and the","metadata":{"id":404}}],["fb9fd3d3-49ad-4644-82ee-f20df28649fb",{"pageContent":"boolean initialize()\nOpens up the network representation so that \nusers can interact with it.\nRegion getRootRegion()\nReturns a reference to the root region and the \nneighbors of this object (excluding traps).\nElement: RequestManager\nRegion requestTopology()\nRequests the topology. This method returns a ref-\nerence to the root region from which it is possible \nto navigate through the complete topology.\nElement: RequestService\nResponse \nsendRequest(Request req)\nThis method receives a request. Only this method \nis exposed in the service interface. This simplifies \nthe addition of other functionality in the future with-\nout having to modify the existing service interface.\nElement: TopologyController\nRegion requestTopology()\nRequests the topology. This method returns a ref-\nerence to the root region from which it is possible \nto navigate through the complete topology.\nElement: RegionDataMapper\nRegion retrieve(int id)\nReturns a Region from its id.\nwww.EBooksWorld.ir\n98 Chapter 4—Case Study: FCAPS System\nT ime Server","metadata":{"id":405}}],["27e91803-830c-4e7c-8312-cfac3eb8bf9f",{"pageContent":"to navigate through the complete topology.\nElement: RegionDataMapper\nRegion retrieve(int id)\nReturns a Region from its id.\nwww.EBooksWorld.ir\n98 Chapter 4—Case Study: FCAPS System\nT ime Server\n:T imeServerConnector:T imeServerConfigurationController:T imeServerDataMapper:T ime Server:T opologyController\naddEventListener(this)\ntrap()\neventReceived(event)\npublish(event)\nretrieve(id) :TimeServer\n:TimeServer\naddEvent()\nupdate(TimeServer)\n:true\nFIGURE 4.9 Sequence diagram for use case UC-2 (Key: UML)\nUC-2: Detect Fault\nFigure    4.9    shows    an    initial    sequence    diagram    for    UC-2    (detect    \nfault)    shows    only    the    components    on    the    server    side.    The    interac-\ntion  starts  with  a  TimeServer  sending  a  trap,  which  is  received  by  the  \nTimeServerConnector. The trap is transformed into an Event and sent to \nthe TimeServerConfigurationController.  The  Event  is  sent  asyn-\nchronously to the TopologyController for publication to the clients and is","metadata":{"id":406}}],["34171c50-1b37-478a-b6d6-2cd9a2d1f7ac",{"pageContent":"the TimeServerConfigurationController.  The  Event  is  sent  asyn-\nchronously to the TopologyController for publication to the clients and is \nthen persisted.\nFrom  this  interaction,  initial  methods  for  the  interfaces  of  the  interacting  \nelements can be identified:\nwww.EBooksWorld.ir\n4.3 The Design Process 99\nMethod NameDescription\nElement: TimeServerConnector\nboolean addEventListener \n(EventListener el)\nThis method allows components from the \nbusiness logic to register themselves as \nlisteners to events that are received from the \ntime servers.\nElement: TimeServerConfigurationController\nboolean eventReceived(Event \nevt)\nThis callback method is invoked when an \nevent is received.\nElement: TopologyController\npublish(Event evt)\nThis method notifies the clients that a new \nevent has occurred.\nElement: TimeServerDataMapper\nTimeServer retrieve(int id)\nRetrieves a TimeServer identified by its id.\nboolean update(TimeServer \nts)\nPersists changes in a TimeServer.","metadata":{"id":407}}],["6619980d-9a87-4443-a8c8-aaac9a5770b3",{"pageContent":"event has occurred.\nElement: TimeServerDataMapper\nTimeServer retrieve(int id)\nRetrieves a TimeServer identified by its id.\nboolean update(TimeServer \nts)\nPersists changes in a TimeServer.\n4.3.3.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  decisions  made  in  this  iteration  provided  an  initial  understanding  of  how  \nfunctionality  is  supported  in  the  system.  The  modules  associated  with  the  pri-\nmary use cases were identified by the architect, and the modules associated with \nthe  rest  of  the  functionality  were  identified  by  another  team  member.  From  the  \ncomplete list of modules, a work assignment table was created (not shown here) \nto address CRN-3.\nAlso, as part of module identification, a new architectural concern was iden-\ntified and added to the Kanban board. Drivers that were completely addressed in \nthe previous iteration are removed from the table.\nwww.EBooksWorld.ir","metadata":{"id":408}}],["083f0346-25f7-4993-b964-822a0d38774c",{"pageContent":"tified and added to the Kanban board. Drivers that were completely addressed in \nthe previous iteration are removed from the table.\nwww.EBooksWorld.ir\n100 Chapter 4—Case Study: FCAPS System\nNot \nAddressed\nPartially \nAddressed \nCompletely\nAddressed\nDesign Decisions Made During the \nIteration\nUC -1Modules across the layers and \npreliminary interfaces to support this use \ncase have been identified.\nUC-2Modules across the layers and \npreliminary interfaces to support this use \ncase have been identified.\nUC-7Modules across the layers and \npreliminary interfaces to support this use \ncase have been identified.\nQ A-1The elements that support the \nassociated use case (UC-2) have been \nidentified.\nQA-2The elements that support the \nassociated use case (UC-5) have been \nidentified.\nQA-3No relevant decisions made.\nQA-4The elements that support the \nassociated use case (UC-7) have been \nidentified.\nCON -1No relevant decisions made.\nCON-4No relevant decisions made.\nCON-5Modules responsible for collecting data \nhave been identified.","metadata":{"id":409}}],["9cbecbf1-3fab-414a-80a0-2b05acc92ab7",{"pageContent":"associated use case (UC-7) have been \nidentified.\nCON -1No relevant decisions made.\nCON-4No relevant decisions made.\nCON-5Modules responsible for collecting data \nhave been identified.\nCON-6Modules responsible for collecting data \nstorage been identified.\nCRN-2Additional technologies were identified \nand selected considering the team’s \nknowledge.\nCRN-3Modules associated with all of the use \ncases have been identified and a work \nassignment matrix has been created (not \nshown).\nCRN-4The architectural concern of unit-testing \nmodules, which was introduced in \nthis new iteration, is partially solved \nthrough the use of an inversion of control \napproach to connect the components \nassociated with the modules. \nwww.EBooksWorld.ir\n4.3 The Design Process 101\n4.3.4 Iteration 3: Addressing Quality Attribute Scenario \nDriver (QA-3)\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD in the third iteration of the design process. Building on the funda-","metadata":{"id":410}}],["ab976c43-e2ce-42db-9306-1f5d9c13eb43",{"pageContent":"Driver (QA-3)\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD in the third iteration of the design process. Building on the funda-\nmental structural decisions made in iterations 1 and 2, we can now start to reason \nabout the fulfillment of some of the more important quality attributes. This itera-\ntion focuses on just one of these quality attribute scenarios.\n4.3.4.1 Step 2: Establish Iteration Goal by Selecting Drivers\nFor  this  iteration,  the  architect  focuses  on  the  QA-3  quality  attribute  scenario:  \nA  failure  occurs  in  the  management  system  during  operation.  The  management  \nsystem resumes operation in less than 30 seconds.\n4.3.4.2 Step 3: Choose One or More Elements of the System to Refine\nFor  this  availability  scenario,  the  elements  that  will  be  refined  are  the  physical  \nnodes that were identified during the first iteration:\n§\tApplication server\n§\tDatabase server","metadata":{"id":411}}],["b5e1336d-d0aa-4286-9a50-7569113f2ccc",{"pageContent":"For  this  availability  scenario,  the  elements  that  will  be  refined  are  the  physical  \nnodes that were identified during the first iteration:\n§\tApplication server\n§\tDatabase server\n4.3.4.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nThe design concepts used in this iteration are the following:\nDesign Decisions and LocationRationale and Assumptions\nIntroduce the active redundancy \ntactic by replicating the application \nserver and other critical compo-\nnents such as the database\nBy replicating the critical elements, the system \ncan withstand the failure of one of the replicated \nelements without affecting functionality.\nIntroduce an element from the \nmessage queue technology \nfamily\nTraps received from the time servers are placed \nin the message queue and then retrieved by \nthe application. Use of a queue will guarantee \nthat traps are processed and delivered in order \n(QA-1). \n4.3.4.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities,","metadata":{"id":412}}],["8abc368d-9167-4ff9-98ba-ecba379b7765",{"pageContent":"the application. Use of a queue will guarantee \nthat traps are processed and delivered in order \n(QA-1). \n4.3.4.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nThe instantiation design decisions are summarized in the following table:\nwww.EBooksWorld.ir\n102 Chapter 4—Case Study: FCAPS System\nDesign Decisions \nand LocationRationale\nDeploy message \nqueue on a separate \nnode\nDeploying the message queue on a separate node will \nguarantee that no traps are lost in case of application \nfailure. This node is replicated using the tactic of active \nredundancy, but only one copy receives and treats events \ncoming from the network devices.\nUse active \nredundancy and \nload balancing in the \napplication server\nBecause two replicas of the application server are active \nat any time, it makes sense to distribute and balance the \nload among the replicas. This tactic can be achieved \nthrough the use of the Load-Balanced Cluster pattern (see \nSection A.2.3).","metadata":{"id":413}}],["d3c42095-21b3-41d7-bb50-55f4c689d5ef",{"pageContent":"at any time, it makes sense to distribute and balance the \nload among the replicas. This tactic can be achieved \nthrough the use of the Load-Balanced Cluster pattern (see \nSection A.2.3).\nThis introduces a new architectural concern, CRN-5: \nManage state in replicas.\nImplement load \nbalancing and \nredundancy using \ntechnology support\nMany technological options for load balancing and \nredundancy can be implemented without having to develop \nan ad hoc solution that would be less mature and harder to \nsupport.\nThe results of these instantiation decisions are recorded in the next step.\n4.3.4.5 Step 6: Sketch Views and Record Design Decisions\nFigure 4.10 shows a refined deployment diagram that includes the introduction of \nredundancy in the system.\nServer1 :ApplicationServer \npc :UserWorkstation \nServer2 :ApplicationServer \n«replicated»\n:Database Server\ndevice1 :TimeServer\nRelocatable IP address\n«replicated»\n:TrapReceiver\n«replicated»\n:LoadBalancer\n«JDBC»\n«HTTP»\n«JDBC»\n«SNMP»","metadata":{"id":414}}],["c1124401-dd44-45c5-81bf-378d91655757",{"pageContent":"pc :UserWorkstation \nServer2 :ApplicationServer \n«replicated»\n:Database Server\ndevice1 :TimeServer\nRelocatable IP address\n«replicated»\n:TrapReceiver\n«replicated»\n:LoadBalancer\n«JDBC»\n«HTTP»\n«JDBC»\n«SNMP»\nFIGURE 4.10 Refined deployment diagram (Key: UML)\nwww.EBooksWorld.ir\n4.3 The Design Process 103\nThe  following  table  describes  responsibilities  for  elements  that  have  not  \nbeen listed previously (in iteration 1):\nElementResponsibility\nLoadBalancer\nDispatches (and balances the load of) requests coming from \nclients to the application servers. The load balancer also \npresents a unique IP address to the clients.\nTrapReceiver\nReceives traps from network devices, converts them into events, \nand puts these events into a persistent message queue.\nThe  UML  sequence  diagram  shown  in  figure  4.11  illustrates  how  the  \nTrapReceiver that was introduced in this iteration exchanges messages with \nother elements shown in the deployment diagram to support UC-2 (detect fault),","metadata":{"id":415}}],["f0625b33-c06e-4d88-8fd0-2b648b68760f",{"pageContent":"TrapReceiver that was introduced in this iteration exchanges messages with \nother elements shown in the deployment diagram to support UC-2 (detect fault), \nwhich is associated with both QA-3 (availability) and QA-1 (performance). \nAs the purpose of this diagram is to illustrate the communication that occurs \nbetween the physical nodes, the names of the methods are only preliminary; they \nwill be refined in further iterations.\n:ApplicationServerpc :UserWorkstation\ntrap()\ntransformAndEnqueue(Event)\nconsume()\nevent()\npublish(Event)\nupdateView()\n:NetworkDevice\n:TrapReceiver\nFIGURE 4.11 Sequence diagram illustrating the messages exchanged between \nthe physical nodes to support UC-2 (Key: UML)\nwww.EBooksWorld.ir\n104 Chapter 4—Case Study: FCAPS System\n4.3.4.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nIn  this  iteration,  important  design  decisions  have  been  made  to  address  QA-3,","metadata":{"id":416}}],["1f8da440-5128-4afb-91f4-5f20188e9623",{"pageContent":"4.3.4.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nIn  this  iteration,  important  design  decisions  have  been  made  to  address  QA-3,  \nwhich also impacted QA-1. The following table summarizes the status of the differ-\nent drivers and the decisions that were made during the iteration. Drivers that were \ncompletely addressed in the previous iteration have been removed from the table.\nNot \nAddressed\nPartially \nAddressed \nCompletely\nAddressed\nDesign Decisions Made During the \nIteration\nQ A-1The introduction of a separate replicated \ntrap receiver node can help ensure \n100% of the traps are processed, even \nin the case of a failure of the application \nserver. Furthermore, because trap \nreception is performed in a separate \nnode, this approach reduces application \nserver processing load, thereby helping \nperformance.\nBecause specific technologies have not \nbeen chosen, this driver is marked as \n“partially addressed”.\nQA-2No relevant decisions made.","metadata":{"id":417}}],["5860e41f-666c-4e6c-9e11-356669b367e6",{"pageContent":"server processing load, thereby helping \nperformance.\nBecause specific technologies have not \nbeen chosen, this driver is marked as \n“partially addressed”.\nQA-2No relevant decisions made.\nQA-3By making the application server \nredundant, we reduce the probability of \nfailure of the system. Furthermore, if the \nload balancer fails, a passive replica is \nactivated within the required time period.\nBecause specific technologies have not \nbeen chosen (message queue), this \ndriver is marked as “partially addressed”.\nQA-4No relevant decisions made.\nCON -1Replication of the application server and \nthe use of a load balancer will help in \nsupporting multiple user requests.\nCON-4No relevant decisions made.\nCON-5No relevant decisions made.\nCON-6No relevant decisions made.\nCRN-2No relevant decisions made.\nCRN-4No relevant decisions made.\nCRN-5This new architectural concern is \nintroduced in this iteration: manage state \nin replicas. At this point, no relevant \ndecisions have been made.\nwww.EBooksWorld.ir","metadata":{"id":418}}],["9952d410-86d3-4cc6-8119-7d4fcb127dbb",{"pageContent":"CRN-4No relevant decisions made.\nCRN-5This new architectural concern is \nintroduced in this iteration: manage state \nin replicas. At this point, no relevant \ndecisions have been made.\nwww.EBooksWorld.ir\n4.5 Further Reading 105\n4.4    Summary\nIn  this  chapter,  we  presented  an  example  of  using  ADD  to  design  a  greenfield  \nsystem  in  a  mature  domain.  We  illustrated  three  iterations  with  different  foci:  \naddressing  a  general  concern,  addressing  functionality,  and  addressing  one  key  \nquality attribute scenario.\nThe  example  followed  the  roadmap  discussed  in  Section  3.3.1.  It  is  inter-\nesting  to  observe  that  in  the  first  iteration,  two  different  reference  architectures  \nwere  used  to  structure  the  system.  Also,  the  selection  of  externally  developed  \ncomponents—in this case, frameworks—was carried out across the different iter-\nations. Finally, the example illustrates how new architectural concerns appear as \nthe design progresses.","metadata":{"id":419}}],["de506eca-0858-4f1f-b821-7fda7b3f7f8e",{"pageContent":"components—in this case, frameworks—was carried out across the different iter-\nations. Finally, the example illustrates how new architectural concerns appear as \nthe design progresses.\nThis  example  demonstrates  how  architectural  concerns,  primary  use  cases,  \nand quality attribute scenarios can be addressed as part of architectural design. In \na real system, more iterations would be necessary to create a complete architec-\nture design by addressing other scenarios with high priority.\nIn this example, we assumed that the architect is using a CASE tool during \ndesign, so diagrams were produced using UML. This is certainly not mandatory, \nas we will see in the case study presented in Chapter 5. Also, note that it is rela-\ntively simple to generate preliminary view sketches by using the information that \nis generated as part of the design process.\n4.5 Further Reading\nAppendix  A  provides  descriptions  and  bibliographical  references  of  all  the  de-\nsign concepts used in this case study.","metadata":{"id":420}}],["1c0d7e55-2dbb-4912-a724-42ab6d892a06",{"pageContent":"is generated as part of the design process.\n4.5 Further Reading\nAppendix  A  provides  descriptions  and  bibliographical  references  of  all  the  de-\nsign concepts used in this case study.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n107\n5\nCase Study:  \nBig Data System\nWith Serge Haziyev and Olha Hrytsay\nWe  now  present  an  extended  design  example  of  using  ADD  3.0  in  a  greenfield  \nsystem  for  a  challenging  domain—that  of  Big  Data.  As  of  the  time  of  writing,  \nthis domain was still relatively new and rapidly evolving. As such, the architects \ncould  not  solely  rely  on  past  experience  to  guide  them.  They  instead  comple-\nmented  the  design  process  with  periodic  analyses  and  strategic  prototyping,  as  \nwe will now describe.\n5.1 Business Case\nThis case study involves an Internet company that provides popular content and \nonline  services  to  millions  of  web  users.  Besides  providing  information  exter-","metadata":{"id":421}}],["2932fe51-be85-40a0-8886-4b164148b93b",{"pageContent":"5.1 Business Case\nThis case study involves an Internet company that provides popular content and \nonline  services  to  millions  of  web  users.  Besides  providing  information  exter-\nnally, the company collects and analyzes massive logs of data that are generated \nfrom  its  infrastructure  (e.g.,  application  and  server  logs,  system  metrics).  Such  \nan approach of dealing with computer-generated log messages is also called log \nmanagement (http://en.wikipedia.org/wiki/Log_management_and_intelligence).\nBecause of very fast infrastructure growth, the company’s IT department re-\nalizes that the existing in-house systems can no longer process the required log \ndata volume and velocity. Moreover, requests for a new system are coming from \nother company stakeholders, including product managers and data scientists, who \nwould like to leverage the various kinds of data that can be collected from multi-\nple data sources, not just logs.","metadata":{"id":422}}],["15016022-b090-4c7c-a69e-891de2c6cb23",{"pageContent":"other company stakeholders, including product managers and data scientists, who \nwould like to leverage the various kinds of data that can be collected from multi-\nple data sources, not just logs.\nThe marketecture  diagram  (informal  depiction  of  the  system’s  structure)  \nshown in Figure 5.1 represents the desired solution from a functional perspective \nfor three major groups of users.\nwww.EBooksWorld.ir\n108 Chapter 5—Case Study: Big Data System \n24/7 Operations, \nSupport Engineers, \nDevelopers\nReal-Time \nDashboard\nData Scientists/\nAnalysts\nAdHoc \nReports\nManagement\nStatic Reports\n•Real-time monitoring\n•Full-text search\n•Anomaly detection\n• Raw and aggregated historical data\n•Ad hoc analysis\n•Real-time queries\n•Near-real-time static reports\n•Available through BI corporate tool\nWeb Servers\n•  Hundreds of \nservers\n•  Massive logs \nfrom \nmultiple \nsources\nFIGURE 5.1 Marketecture diagram for the Big Data system\n5.2 System Requirements\nRequirement  elicitation  activities  have  been  previously  performed.  The  most","metadata":{"id":423}}],["a9778093-0366-45be-9c25-3b40111f4c5d",{"pageContent":"•  Massive logs \nfrom \nmultiple \nsources\nFIGURE 5.1 Marketecture diagram for the Big Data system\n5.2 System Requirements\nRequirement  elicitation  activities  have  been  previously  performed.  The  most  \nimportant  requirements  collected  are  summarized  here.  They  comprise  a  set  of  \nprimary use cases, a set of quality attribute scenarios, a set of constraints, and a \nset of architectural concerns.\n5.2.1 Use Case Model\nThe primary use cases for the system are described in the following table.\nUse CaseDescription\nUC-1: Monitor \nonline services\nOn-duty operations staff can monitor the current state of \nservices and IT infrastructure (such as web server load, \nuser activities, and errors) through a real-time operational \ndashboard, which enables them to quickly react to issues.\nUC-2: \nTroubleshoot \nonline service \nissues\nOperations, support engineers, and developers can do \ntroubleshooting and root-cause analysis on the latest \ncollected logs by searching log patterns and filtering log \nmessages.","metadata":{"id":424}}],["1b0cf79d-aba4-4701-96c7-10139368c8e4",{"pageContent":"online service \nissues\nOperations, support engineers, and developers can do \ntroubleshooting and root-cause analysis on the latest \ncollected logs by searching log patterns and filtering log \nmessages.\nUC-3: Provide \nmanagement \nreports\nCorporate users, such as IT and product managers, can see \nhistorical information through predefined (static) reports in \na corporate BI (business intelligence) tool, such as those \nshowing system load over time, product usage, service level \nagreement (SLA) violations, and quality of releases.\nwww.EBooksWorld.ir\n5.2 System Requirements 109\nUse CaseDescription\nUC-4: Support \ndata analytics\nData scientists and analysts can do ad hoc data analysis \nthrough SQL-like queries to find specific data patterns and \ncorrelations to improve infrastructure capacity planning and \ncustomer satisfaction.\nUC-5: Anomaly \ndetection\nThe operations team should be notified 24/7 about any \nunusual behavior of the system. To support this notification","metadata":{"id":425}}],["16a53205-4a88-4279-957d-0e05ba5d2c46",{"pageContent":"customer satisfaction.\nUC-5: Anomaly \ndetection\nThe operations team should be notified 24/7 about any \nunusual behavior of the system. To support this notification \nplan, the system shall implement real-time anomaly detection \nand alerting (future requirement).\nUC-6: Provide \nsecurity reports\nSecurity analysts should be provided with the ability to \ninvestigate potential security and compliance issues by \nexploring audit log entries that include destination and source \naddresses, a time stamp, and user login information (future \nrequirement). \n5.2.2 Quality Attribute Scenarios\nThe most relevant quality attribute (raw) scenarios are presented in the following \ntable. For each scenario, we also identify the use case that it is associated with.\nID\nQuality  \nAttributeScenario\nAssociated \nUse Case\nQ A-1PerformanceThe system shall collect up to 15,000 events/\nsecond from approximately 300 web servers.\nUC-1, 2, 5\nQA-2PerformanceThe system shall automatically refresh the \nreal-time monitoring dashboard for on-duty","metadata":{"id":426}}],["4ebd85fd-f93a-41d5-9d16-5c6024bd8717",{"pageContent":"second from approximately 300 web servers.\nUC-1, 2, 5\nQA-2PerformanceThe system shall automatically refresh the \nreal-time monitoring dashboard for on-duty \noperations staff with < 1 min latency. \nUC -1\nQA-3PerformanceThe system shall provide real-time search \nqueries for emergency troubleshooting with  \n< 10 seconds query execution time, for the \nlast 2 weeks of data.\nUC-2\nQA-4PerformanceThe system shall provide near-real-time \nstatic reports with per-minute aggregation \nfor business users with < 15 min latency, < 5 \nseconds report load.\nUC-3, 6\nQA-5PerformanceThe system shall provide ad hoc (i.e., non-\npredefined) SQL-like human-time queries \nfor raw and aggregated historical data, with \n< 2 minutes query execution time. Results \nshould be available for query in < 1 hour. \nUC-4\nQA-6ScalabilityThe system shall store raw data for the last 2 \nweeks available for emergency troubleshoot-\ning (via full-text search through logs).\nUC-2\nQA-7ScalabilityThe system shall store raw data for the last","metadata":{"id":427}}],["06294416-d894-4da0-852a-c489209f9026",{"pageContent":"weeks available for emergency troubleshoot-\ning (via full-text search through logs).\nUC-2\nQA-7ScalabilityThe system shall store raw data for the last \n60 days (approximately 1 TB of raw data per \nday, approximately 60 TB in total).\nUC-4\n(\ncontinues)\nwww.EBooksWorld.ir\n110 Chapter 5—Case Study: Big Data System \nID\nQuality  \nAttributeScenario\nAssociated \nUse Case\nQA-8ScalabilityThe system shall store per-minute \naggregated data for 1 year (approximately \n40 TB) and per-hour aggregated data for 10 \nyears (approximately 50 TB).\nUC-3, 4, 6\nQA-9ExtensibilityThe system shall support adding new data \nsources by just updating a configuration, with \nno interruption of ongoing data collection.\nUC-1, 2, 5\nQ A-10AvailabilityThe system shall continue operating with  \nno downtime if any single node or \ncomponent fails.\nAll use \ncases\nQ A -11DeployabilityThe system deployment procedure shall be \nfully automated and support a number of envi-\nronments: development, test, and production.\nAll use \ncases\n5.2.3    Constraints","metadata":{"id":428}}],["f7458e52-3f0e-4ee2-ace8-0f75c0e56b15",{"pageContent":"All use \ncases\nQ A -11DeployabilityThe system deployment procedure shall be \nfully automated and support a number of envi-\nronments: development, test, and production.\nAll use \ncases\n5.2.3    Constraints\nThe constraints associated with the system are presented in the following table.\nIDConstraint\nCON -1The system shall be composed primarily of open source technologies \n(for cost reasons). For those components where the value/cost of \nusing proprietary technology is much higher, proprietary technology \nmay be used.\nCON-2The system shall use the corporate BI tool with a SQL interface for \nstatic reports (e.g., MicroStrategy, QlikView, Tableau).\nCON-3The system shall support two specific deployment environments: \nprivate cloud (with VMware vSphere Hypervisor) and public cloud \n(Amazon Web Services). Architecture and technology decisions should \nbe made to keep deployment vendor as agnostic as possible.\n5.2.4 Architectural Concerns","metadata":{"id":429}}],["6b6eb6e1-86b0-4f72-9162-3954281cee14",{"pageContent":"(Amazon Web Services). Architecture and technology decisions should \nbe made to keep deployment vendor as agnostic as possible.\n5.2.4 Architectural Concerns\nThe initial architectural concerns that are considered are shown in the following table.\nIDConcern\nCRN -1Establishing an initial overall structure as this is a greenfield system.\nCRN-2Leverage the team’s knowledge of the Apache Big Data ecosystem.\nwww.EBooksWorld.ir\n5.3 The Design Process 111\n5.3 The Design Process\nNow that we have enumerated the requirements, we are ready to begin the first it-\neration of ADD. This is a system from a relatively novel domain that is being cre-\nated from scratch. Hence we follow the roadmap of design for greenfield systems \nin mature domains (as discussed in Section 3.3.1), albeit with some modifications \nto  address  the  uncertainties  inherent  in  the  Big  Data  domain,  such  as  the  rapid  \nemergence and evolution of technologies.\n5.3.1 ADD Step 1: Review Inputs","metadata":{"id":430}}],["5328bf5d-eea3-472e-ac6a-2564aa709e80",{"pageContent":"to  address  the  uncertainties  inherent  in  the  Big  Data  domain,  such  as  the  rapid  \nemergence and evolution of technologies.\n5.3.1 ADD Step 1: Review Inputs\nThe first step of the method involves reviewing the inputs. They are summarized \nin the following table.\nCategoryDetails\nDesign \npurpose\nThis is a greenfield system in a relatively novel domain. The organi-\nzation will perform development following an Agile process with short \niterations so that developers can quickly receive real-world feedback \nand continue modifying the system. At the same time, an architectur-\nal design is needed to make conscious decisions to satisfy architec-\ntural drivers and avoid unnecessary rework.\nPrimary \nfunctional \nrequirements\nFrom the use cases presented in Section 5.2.1, the following ones \nare designated as primary:\n ■\nUC-1\n ■\nUC-2\n ■\nUC-3\n ■\nUC-4\nQuality \nattribute \nscenarios\nThe following table illustrates the priority of the primary quality \nattribute scenarios, as ranked by the customer and architect (as","metadata":{"id":431}}],["1352bd58-b7dc-42b1-889f-673e39580797",{"pageContent":"■\nUC-1\n ■\nUC-2\n ■\nUC-3\n ■\nUC-4\nQuality \nattribute \nscenarios\nThe following table illustrates the priority of the primary quality \nattribute scenarios, as ranked by the customer and architect (as \ndiscussed in Section 3.3.2). Note that quality attributes scenarios \nwith lower priorities exist but are not shown here.\nScenario  \nID\nImportance to \nCustomer\nDifficulty of Implementation \nAccording to Architect\nQ A-1HighHigh\nQA-2HighMedium\nQA-3MediumMedium\nQA-4HighHigh\nQA-5MediumHigh\nQA-6MediumMedium\nQA-7MediumMedium\nQA-8HighMedium\nQA-9HighMedium\nQ A-10HighMedium\nQ A -11MediumHigh\n(continues)\nwww.EBooksWorld.ir\n112 Chapter 5—Case Study: Big Data System \nCategoryDetails\nConstraintsSee Section 5.2.3.\nArchitectural \nconcerns\nAll of the architectural concerns presented in Section 5.2.4 are \nincluded as drivers.\n5.3.2 Iteration 1: Reference Architecture and Overall System \nStructure\nThis section presents the results of the activities that are performed in each of the \nsteps of the ADD method in the first iteration of the design process.","metadata":{"id":432}}],["27c6774d-8f39-4915-ab68-1512800ebdad",{"pageContent":"Structure\nThis section presents the results of the activities that are performed in each of the \nsteps of the ADD method in the first iteration of the design process.\n5.3.2.1 Step 2: Establish Iteration Goal by Selecting Drivers\nThis is the first iteration in the design of a greenfield system, so the iteration goal \nis  to  establish  an  initial  overall  structure  for  the  system  (CRN-1).  Even  though  \nthis first iteration is driven by a general architectural concern, the architect must \nkeep in mind all of the drivers and, in particular, constraints and quality attributes:\n§\tCON-1: Leverage open source technologies whenever applicable\n§\tCON-2: Use corporate BI tool with SQL interface for static reports\n§\tCON-3: Two deployment environments: private and public clouds\n§\tQA-1, 2, 3, 4, 5: Performance\n§\tQA-6, 7, 8: Scalability\n§\tQA-9: Extensibility\n§\tQA-10: Availability\n§\tQA-11: Deployability\n5.3.2.2 Step 3: Choose One or More Elements of the System to Refine","metadata":{"id":433}}],["c557e2a3-1f7a-4542-898c-8bbdc2cb5542",{"pageContent":"§\tQA-1, 2, 3, 4, 5: Performance\n§\tQA-6, 7, 8: Scalability\n§\tQA-9: Extensibility\n§\tQA-10: Availability\n§\tQA-11: Deployability\n5.3.2.2 Step 3: Choose One or More Elements of the System to Refine\nAgain,  as  this  is  greenfield  development,  and  we  are  in  the  initial  iteration,  the  \nelement to refine is the entire system.\n5.3.2.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nIn this iteration, design concepts are selected from a group of data analytics ref-\nerence  architectures  (a  list  of  such  reference  architectures  can  be  found  in  the  \ndesign  concepts  catalog  of  the  Smart  Decisions  Game;  see  the  Further  Reading  \nsection for more information).\nwww.EBooksWorld.ir\n5.3 The Design Process 113\nDesign \nDecisions and \nLocationRationale\nBuild the \napplication as \nan instance of \nthe Lambda \n(reference) \narchitecture\nThe Lambda architecture, shown in Figure 5.2, is a reference \narchitecture that splits the processing of a data stream into two","metadata":{"id":434}}],["4e4370ad-5ffb-452b-b426-18d7b83ff44a",{"pageContent":"application as \nan instance of \nthe Lambda \n(reference) \narchitecture\nThe Lambda architecture, shown in Figure 5.2, is a reference \narchitecture that splits the processing of a data stream into two \nstreams: the “speed layer”, which supports access to real-time \ndata (UC-1, UC-2, UC-5), and a layer that groups the “batch” \nand “serving” layers, which supports access to historical data \n(UC-3, UC-4, UC-6). (The creators of the Lambda architecture \nrefer to these as “layers”, but this is different from prior—and \nmore standard—usages of this term, which typically refer to \na grouping of modules. Here the layers are groups of runtime \ncomponents.) While the batch layer is based on immutable \nnonrelational techniques, the speed layer is based on streaming \ntechniques to support strict real-time processing requirements.\nImmutability in this case means that the data is not updated or \ndeleted when it is collected; that is, it can be only appended. \nAs all data is collected, no data can be lost and a machine","metadata":{"id":435}}],["918025d7-22de-4942-acf9-67a683a7aaa6",{"pageContent":"Immutability in this case means that the data is not updated or \ndeleted when it is collected; that is, it can be only appended. \nAs all data is collected, no data can be lost and a machine \nor human error can be tolerated. For example, if a software \nengineer made an occasional mistake in processing or viewing \nlogic, once that problem is resolved, the collected data can be \nused to replay and recompute the views from scratch.\nFor the reader’s convenience we describe the basic concepts of \nthe Lambda architecture by walking through five steps:\n1. All data received from multiple data sources is dispatched \nthrough the data stream element to both the batch layer and \nthe speed layer for processing.\n2. The batch layer acts as a landing zone that corresponds to \nthe master dataset element (as an immutable, append-only \nset of raw data), and also precomputes information that will \nbe used by the batch views.\n3. The serving layer contains precalculated and aggregated","metadata":{"id":436}}],["13c97e7f-f02e-47c3-b05f-4a71624ea8b0",{"pageContent":"set of raw data), and also precomputes information that will \nbe used by the batch views.\n3. The serving layer contains precalculated and aggregated \nviews optimized for querying with low latency, which is often \nrequired by reporting solutions.\n4. The speed layer processes and provides access to recent \ndata through real-time views that are not available in the \nserving layer due to the high latency of batch processing.\n5. All data in the system is available for querying, whether it is \nhistorical or recent, representing the key Lambda architec-\nture principle: query = function (batch data + real-time data).\nThe parallel streams provide “complexity isolation”, meaning that \ndesign decisions, development, and execution of each stream \ncan be done independently, which has been shown to increase \nfault tolerance, scalability, and modifiability (see Table 5.1).\nFigure 5.3 depicts the architectural tradeoffs between these \nalternatives, and demonstrates the differences between the","metadata":{"id":437}}],["221450f8-bf73-4285-818a-c88e435858b7",{"pageContent":"fault tolerance, scalability, and modifiability (see Table 5.1).\nFigure 5.3 depicts the architectural tradeoffs between these \nalternatives, and demonstrates the differences between the \nreference architectures in terms of four quality dimensions: \nscalability, support for ad hoc analysis, unstructured data \nprocessing capabilities, and real-time analysis capabilities:\nAs Figure 5.3 shows, the Lambda architecture provides the best \ntradeoff between scalability and ad hoc analysis.\n(\ncontinues)\nwww.EBooksWorld.ir\n114 Chapter 5—Case Study: Big Data System \nDesign \nDecisions and \nLocationRationale\nUse fault \ntolerance and no \nsingle point of \nfailure principle \nfor all elements \nin the system\nFault tolerance has become a standard for most Big Data \ntechnologies and the Lambda architecture already implies a \nnumber of design decisions to build a robust and fault-tolerant \nsystem, as noted above.\nHowever, we will need to make sure, in all subsequent design \nand deployment decisions, that all candidate technologies","metadata":{"id":438}}],["7c5101a8-4a7d-4d80-927b-a9c78b247abb",{"pageContent":"system, as noted above.\nHowever, we will need to make sure, in all subsequent design \nand deployment decisions, that all candidate technologies \nwill support the QA-10 requirement by providing fault-tolerant \nconfigurations and adhering to the “no single point of failure” \nprinciple.\nTABLE 5.1 Alternatives and Reasons for Discarding\nAlternativeReason for Discarding\nTraditional relationalThis reference architecture is based on traditional relational \nmodel principles and SQL-based DBMSs, which are \nconsidered highly efficient for complex ad hoc read queries.\nThis is, however, the least appropriate alternative because \nof scalability and real-time processing limitations.\nExtended relationalAlthough this reference architecture is completely based \non relational model principles and SQL-based DBMSs, it \nintensively uses massive parallel processing (MPP) and in-\nmemory techniques to improve scalability and extensibility.\nIt is less appropriate because of its high cost and real-time \nprocessing limitations.","metadata":{"id":439}}],["4af0745b-656a-4d56-9485-10f8c312a081",{"pageContent":"memory techniques to improve scalability and extensibility.\nIt is less appropriate because of its high cost and real-time \nprocessing limitations.\nPure nonrelationalThis reference architecture does not rely on relational model \nprinciples. It is often built on techniques such as NoSQL and \nMapReduce, and is effective for processing semistructured \nand unstructured data.\nThis alternative is closer to the goal in terms of cost \neconomy and scalability, but ad hoc analysis is limited. \nData refineryA non-relational component performs an extract–transform–\nload (ETL) process to refine semistructured/unstructured \ndata and load it, cleansed, into a data warehouse (a \nrelational database) for further analysis.\nIt is less appropriate for this solution mostly because of its \nhigh cost and significant deficiencies in terms of real-time \nprocessing capabilities.\nwww.EBooksWorld.ir\n5.3 The Design Process 115\nData Stream\nMaster\nDataset\nPrecomputing\nLayer \nBoundary\nData Flow \n(with direction indicated)\nQuery Results Flow","metadata":{"id":440}}],["8172ebe3-355a-4a3b-b8fa-2dbb6c645f57",{"pageContent":"processing capabilities.\nwww.EBooksWorld.ir\n5.3 The Design Process 115\nData Stream\nMaster\nDataset\nPrecomputing\nLayer \nBoundary\nData Flow \n(with direction indicated)\nQuery Results Flow \nLegend:\nElement \nBoundary\nBatch \nViews\nQuery & \nReporting\nReal-Time\nViews\nBATCH LayerSERVING Layer\nSPEED Layer\n1\n5\n3\n2\n4\nFIGURE 5.2 Lambda Architecture\nData Refinery\nExtended\nRelational\nPure \nNonrelational\nTraditional\nRelational\nLambda \nArchitecture\nScalability\nAd Hoc Analysis\nLegend:\nUnstructured data processing \ncapabilities (the larger the better)\nReal-time analysis capabilities\n(the more saturated the better)\nFIGURE 5.3 Tradeoffs among data analytics reference architectures\nwww.EBooksWorld.ir\n116 Chapter 5—Case Study: Big Data System \n5.3.2.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities,  \nand Define Interfaces\nThe  instantiation  design  decisions  considered  and  made  are  summarized  in  the  \nfollowing table.\nDesign Decision and \nLocationRationale\nSplit the Query and \nReporting element \ninto two subelements","metadata":{"id":441}}],["6393574e-53b1-404f-bc06-cbf40e6362c3",{"pageContent":"The  instantiation  design  decisions  considered  and  made  are  summarized  in  the  \nfollowing table.\nDesign Decision and \nLocationRationale\nSplit the Query and \nReporting element \ninto two subelements \nassociated with the \ndrivers\nThe Query and Reporting element in the Lambda \narchitecture is divided into the following two sub-elements. \nThey are associated with drivers as follows:\n ■\nCorporate BI tool (UC-3, UC-4, QA-4, QA-5, CON-2)\n ■\nDashboard/visualization tool (UC-1, UC-2, QA-2, QA-3)\nThis division is driven by knowledge of the domain and \nthe availability of tools. The guiding rationale is to have \nflexibility in selecting appropriate technologies—there could \nnot be one single “universal” tool to satisfy all of these use \ncases, constraints, and quality attributes. Thus, we choose \nto separate concerns, which should give us more design \noptions. Another difference from the “standard” Lambda \narchitecture is that we may not need to merge the results of","metadata":{"id":442}}],["77279dc4-48d2-4968-9358-90e4fd010a3f",{"pageContent":"to separate concerns, which should give us more design \noptions. Another difference from the “standard” Lambda \narchitecture is that we may not need to merge the results of \nqueries: According to our use cases, they can be executed \nindependently for batch and real-time views.\nSplit the Precomputing \nand Batch Views \nelements into \nsubelements \nassociated with Ad Hoc \nand Static Views\nThese elements are decomposed into two subelements \neach:\n ■\nAd Hoc Views Precomputing and Ad Hoc Batch Views \n(UC-4, QA-5)\n ■\nStatic Views Precomputing and Static Batch Views \n(UC-3, QA-4, CON-2)\nThe reason for this subdivision is the same as with the \nprevious case: It gives us more flexibility to select the \noptimal patterns and technologies. If we discover, in \nsubsequent design iterations, that there is one approach \nto address these two concerns simultaneously, it will be \nsimple to merge these elements.\nChange semantics and \nname of the Master \nDataset to Raw Data \nStorage","metadata":{"id":443}}],["dc5b2e4a-b840-4b40-a37b-a42ead060aca",{"pageContent":"to address these two concerns simultaneously, it will be \nsimple to merge these elements.\nChange semantics and \nname of the Master \nDataset to Raw Data \nStorage\nThis is more than just a name change; it is also a change \nin semantics. According to QA-7, the system shall store \nraw data for least 60 days. Thus older data can be \narchived and stored using other storage technologies \n(or even deleted). The Master Dataset has more \nresponsibilities: It includes raw data storage as well as \narchived data. To simplify this case, the study of archived \ndata will not be addressed.\nIn this initial iteration it is typically too early to precisely define functional-\nity and interfaces.\n5.3.2.5 Step 6: Sketch Views and Record Design Decisions\nFigure 5.4 shows the result of the prior instantiation design decisions. The table \nthat begins on the next page summarizes each element’s responsibilities.\nwww.EBooksWorld.ir\n5.3 The Design Process 117\nData\nStream\nRaw Data \nStorage\nCorporate \nBI Tool\nDashboard/\nVisualization\nTool","metadata":{"id":444}}],["73f45042-26c2-4d30-b833-9dae1165d928",{"pageContent":"that begins on the next page summarizes each element’s responsibilities.\nwww.EBooksWorld.ir\n5.3 The Design Process 117\nData\nStream\nRaw Data \nStorage\nCorporate \nBI Tool\nDashboard/\nVisualization\nTool\nReal-Time\nViews\nBATCH LayerSERVING Layer\nSPEED Layer\nAd Hoc Views\nPrecomputing\nAd Hoc \nBatch Views\nStatic Views\nPrecomputing\nStatic Batch\nViews\nLayer \nBoundary\nData Flow \n(with direction indicated)\nData\nSources \nQuery Results Flow \nLegend:\nElement \nBoundary\nFIGURE 5.4 Instantiation of the Lambda architecture\nElementResponsibility\nData SourcesWeb servers that generate logs and system metrics (e.g., \nApache access and error log, Linux sysstat).\nData StreamThis element collects data from all data sources in real-time and \ndispatches it to both the Batch Layer and the Speed Layer for \nprocessing.\nBatch LayerThis layer is responsible for storing raw data and precomputing \nthe batch views to be stored in the Serving Layer.\nServing LayerThis layer exposes the batch views in a data store (with no","metadata":{"id":445}}],["27699b1a-40c2-4eb3-9f87-5ae92780e0e0",{"pageContent":"Batch LayerThis layer is responsible for storing raw data and precomputing \nthe batch views to be stored in the Serving Layer.\nServing LayerThis layer exposes the batch views in a data store (with no \nrandom writes, but batch updates and random reads), so that \nthey can be queried with low latency.\nSpeed LayerThis layer processes and provides access to recent data, which \nis not available yet in the serving layer due to the high latency of \nbatch processing, through a set of real-time views.\nRaw Data StorageThis element is a part of the batch layer and is responsible for \nstoring raw data (immutable, append only) for a specified period \nof time (QA-7).\nAd Hoc Views \nPrecomputing\nThis element is a part of the Batch Layer and is responsible \nfor precomputing the Ad Hoc Batch Views. The precomputing \nrepresents batch operations over raw data that transform it to a \nstate suitable for fast human-time querying.\nStatic Views \nPrecomputing\nThis element is a part of the Batch Layer and is responsible","metadata":{"id":446}}],["873885cc-718e-443a-b9c0-a8a0ceba1120",{"pageContent":"represents batch operations over raw data that transform it to a \nstate suitable for fast human-time querying.\nStatic Views \nPrecomputing\nThis element is a part of the Batch Layer and is responsible \nfor precomputing the Static Batch Views. The precomputing \nrepresents batch operations over raw data that transform it to a \nstate suitable for fast human-time querying.\n(\ncontinues)\nwww.EBooksWorld.ir\n118 Chapter 5—Case Study: Big Data System \nElementResponsibility\nAd Hoc Batch \nViews\nThis element is a part of the Serving Layer and contains \nprecalculated and aggregated data optimized for ad hoc low-\nlatency queries (QA-5) executed by data scientists/analysts.\nStatic Batch \nViews\nThis element is a part of the Serving Layer and contains \nprecalculated and aggregated data optimized for predefined \nlow-latency queries (QA-4) generated by a corporate BI tool.\nReal-Time ViewsThis element is a part of the Speed Layer and contains indexed \nlogs optimized for ad hoc, low-latency search queries (QA-3)","metadata":{"id":447}}],["0742e2ea-b271-45f9-aea1-96e9aa74f2a2",{"pageContent":"low-latency queries (QA-4) generated by a corporate BI tool.\nReal-Time ViewsThis element is a part of the Speed Layer and contains indexed \nlogs optimized for ad hoc, low-latency search queries (QA-3) \nexecuted by operations and engineering staff.\nCorporate BI \nTo o l\nThis business intelligence tool is licensed to be used across \ndifferent departments. The tool supports a SQL interface (such \nas ODBC or JDBC) and can be connected to multiple data \nsources, including this system (UC-3, UC-4, CON-2).\nDashboard/\nVisualization Tool\nThe operations team uses this real-time operational dashboard \nto monitor online services, search for important messages in \nlogs, and quickly react to potential issues (UC-1, UC-2).\n5.3.2.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  decisions  made  in  this  iteration  address  important  early  considerations  af-\nfecting the overall system structure. You do not need to start from a “blank page”,","metadata":{"id":448}}],["4414f632-4fce-4061-823a-8a3be2659817",{"pageContent":"The  decisions  made  in  this  iteration  address  important  early  considerations  af-\nfecting the overall system structure. You do not need to start from a “blank page”, \nbecause the selected reference architecture already offers a proven initial decom-\nposition and data flow that significantly saves design time and effort. Further de-\nsign decisions will need to be made to selected candidate technologies and more \ndetails provided on how use cases and quality attributes will be supported. \nThe following table summarizes the design progress using the Kanban board \ntechnique discussed in Section 3.8.2.\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nUC -1Use Lambda architecture to provide \naccess to real-time data. No detailed \ndecisions of which dashboard \ntechnology to use have been made.\nUC-2Use Lambda architecture to provide \naccess to real-time data. No detailed \ndecisions of which search technology \nto use have been made.","metadata":{"id":449}}],["06843b8f-2f8f-4174-bfea-b963c90fac70",{"pageContent":"decisions of which dashboard \ntechnology to use have been made.\nUC-2Use Lambda architecture to provide \naccess to real-time data. No detailed \ndecisions of which search technology \nto use have been made.\nUC-3Use Lambda architecture to provide \naccess to historical data. No detailed \ndecisions of which storage and query \ntechnologies to use have been made.\nwww.EBooksWorld.ir\n5.3 The Design Process 119\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nUC-4Use Lambda architecture to provide \naccess to historical data. No detailed \ndecisions of which storage and query \ntechnologies to use have been made.\nUC-5This use case has been omitted in \nthis iteration as nonprimary, although \nthe Lambda architecture supports it \nand we will address it in subsequent \niterations.\nUC-6This use case has been omitted in this \niteration as nonprimary, although from \nan architectural standpoint it is similar \nto UC-3.\nQ A-1Potential data sources for the Data","metadata":{"id":450}}],["e06d043d-36ed-4815-ba72-ad8ed487512b",{"pageContent":"iterations.\nUC-6This use case has been omitted in this \niteration as nonprimary, although from \nan architectural standpoint it is similar \nto UC-3.\nQ A-1Potential data sources for the Data \nStream element have been identified. \nNo detailed decisions of which \ntechnologies to use for the data \nstream element have been made.\nQA-3The Real-Time Views element \nhas been identified. No detailed \ndecisions of which storage and query \ntechnology to use have been made.\nQA-4The Static Batch Views element has \nbeen identified and its responsibilities \nhave been established. No detailed \ndecisions of which storage technology \nto use have been made.\nQA-5The Ad Hoc Batch Views element has \nbeen identified and its responsibilities \nhave been established. No detailed \ndecisions of which storage and query \ntechnology to use have been made.\nQA-6The Real-Time Views element’s \nresponsibilities have been \nestablished. No detailed decisions of \nwhich storage and query technology \nto use have been made.","metadata":{"id":451}}],["5b56d7b4-33c9-4f2d-b05d-6cdd23d40223",{"pageContent":"technology to use have been made.\nQA-6The Real-Time Views element’s \nresponsibilities have been \nestablished. No detailed decisions of \nwhich storage and query technology \nto use have been made.\nQA-7The Raw Data Storage element has \nbeen identified and its responsibilities \nhave been established. No detailed \ndecisions of which storage technology \nto use have been made.\n(\ncontinues)\nwww.EBooksWorld.ir\n120 Chapter 5—Case Study: Big Data System \nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nQA-8The Ad Hoc and Static Batch Views \nelements have been identified and \ntheir responsibilities have been \nestablished. No detailed decisions \nof which storage technologies to use \nhave been made.\nQ A-10It has been decided that all \ntechnologies chosen to implement the \nsystem elements support QA-10 by \nproviding fault-tolerance configuration \nand no single point of failure.\nCON-2The Corporate BI Tool element has \nbeen identified. No detailed decisions","metadata":{"id":452}}],["ba44410c-ad9d-4184-a322-e582edc2297d",{"pageContent":"system elements support QA-10 by \nproviding fault-tolerance configuration \nand no single point of failure.\nCON-2The Corporate BI Tool element has \nbeen identified. No detailed decisions \non how this constraint will be met have \nbeen made.\nCRN -1An overall logical structure of the \nsystem has been established but the \nphysical structure still needs to be \ndefined.\nCRN-2No relevant decisions made\n5.3.3 Iteration 2: Selection of Technologies\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD in the second iteration of the design process.\nTechnology  choices  often  influence  the  system  architecture,  meaning  that  \nwe  need  to  select  technologies  at  the  earliest  stages  of  architecture  design.  \nChoosing technologies starts with the identification and selection of technology \nfamilies that are further instantiated into specific technologies. Starting with tech-\nnology families allows us to make specific technologies interchangeable and thus","metadata":{"id":453}}],["6d4ed76c-aea9-4f8c-9ef9-c681c49ed2f1",{"pageContent":"families that are further instantiated into specific technologies. Starting with tech-\nnology families allows us to make specific technologies interchangeable and thus \nkeep the right level of technology agnosticism to avoid vendor lock-in (and as a \nresult, there is less risk and less cost to change a technology to a better one in the \nfuture).\nIn this iteration we will show a technology tree that helps us choose optimal \nbuilding blocks when designing Big Data greenfield systems.\nwww.EBooksWorld.ir\n5.3 The Design Process 121\n5.3.3.1 Step 2: Establish Iteration Goal by Selecting Drivers\nThe  goal  of  this  iteration  is  to  address  CRN-2  (leverage  the  team’s  knowledge  \nof the Apache Big Data ecosystem) by selecting technologies to support system \nrequirements defined in Section 5.2, particularly keeping in mind CON-1 (favor \nopen source technologies).\n5.3.3.2 Step 3: Choose One or More Elements of the System to Refine","metadata":{"id":454}}],["5e1797f7-f81c-4f25-9bb5-4dfd2aefde72",{"pageContent":"requirements defined in Section 5.2, particularly keeping in mind CON-1 (favor \nopen source technologies).\n5.3.3.2 Step 3: Choose One or More Elements of the System to Refine\nThe  reference  architecture  selected  in  the  previous  iteration  (the  Lambda  archi-\ntecture) was decomposed into elements that facilitate the selection of technology \nfamilies  and  their  associated  specific  technologies.  These  elements  include  the  \nData Stream, Raw Data Storage, Ad Hoc and Static Views Precomputing, Ad Hoc \nand Static Batch Views, Real-Time Views, and Dashboard/Visualization Tool.\n5.3.3.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nThe design concepts used in this iteration are externally developed components. \nInitially, technology families are selected and associated with the elements to be \nrefined.  A  technology  family  represents  a  group  of  technologies  with  common","metadata":{"id":455}}],["b8756f18-1652-450a-8727-2af02e667607",{"pageContent":"Initially, technology families are selected and associated with the elements to be \nrefined.  A  technology  family  represents  a  group  of  technologies  with  common  \nfunctional purposes (see Section 2.5.5). The family names are indicative of their \nfunction,  and  some  specific  technologies  may  belong  to  several  families  at  the  \nsame  time,  but  having  such  a  classification  helps  us  make  rational  design  de-\ncisions  that  eventually  pay  off  in  less  rework  and  better  readiness  for  changes.  \nThe history of the software industry shows that technology implementations are \nemerging,  evolving,  and  disappearing  much  faster  than  the  patterns  and  princi-\nples represented by their families.\nFigure  5.5  illustrates  family  groups,  technology  families  (in  regular  text),  \nand their associated specific technologies (in italic text) for the Big Data domain. \nFurther details about a number of these technologies can be found in the design","metadata":{"id":456}}],["7ec4dbb9-6081-4924-9f99-cb02cb2515f4",{"pageContent":"and their associated specific technologies (in italic text) for the Big Data domain. \nFurther details about a number of these technologies can be found in the design \nconcepts catalog of the Smart Decisions Game (see the Further Reading section).\nwww.EBooksWorld.ir\n122 Chapter 5—Case Study: Big Data System \nBig Data Analytics Catalog\nIntegration\nMessaging\nData Collector\nApache Flume\nLogstash\nFluentd\nApache Kafka\nRabbitMQ\nAmazon SQS\nApache ActiveMQ\nHBase\nCassandra\nNeo4J\nOrientDB\nHP Vertica\nTeradata\nMS PDW\nAmazon Redshift\nStreamSets\nTalend\nInformatica\nMongoDB\nCouchDB\nRiak\nRedis\nBerkeley DB\nMS SQL Server\nQlikView\nMicrostrategy\nTableau\nTibco JasperSoft\nPentaho\nOracle RDBMS\nIBM DB2\nSplunk\nSplunk\nKibana\nZoomdata\nD3.js\nGoJS\nHighcharts\nImpala\nApache Hive (Stinger)\nApache Solr\nElasticsearch\nHadoop MapReduce\nApache Tez\nApache Spark\nApache Storm\nSpark Streaming\nAmazon Kinesis\nApache Samza\nCascading\nApache Crunch\nAmazon Pig\nApache Hive\nSpark SQL\nHDFS\nCassandraFS\nDistributed Message Broker\nETL/Data Integration Engine\nDocument-Oriented\nKey-Value\nGraph-Oriented","metadata":{"id":457}}],["42c0eb53-9953-4af2-be89-aecba589a8bd",{"pageContent":"Amazon Kinesis\nApache Samza\nCascading\nApache Crunch\nAmazon Pig\nApache Hive\nSpark SQL\nHDFS\nCassandraFS\nDistributed Message Broker\nETL/Data Integration Engine\nDocument-Oriented\nKey-Value\nGraph-Oriented\nMPP Analytic RDBMS\nTraditional Analytic RDBMS\nBI Platform\nInteractive Dashboard\nInteractive Query Engine\nDistributed Search Engine\nDistributed Computing Engine\nEvent Stream Processor\nData Processing Framework\nGraphic Library\nColumn-Family\nETL/ELT\nDistributed File System\nNoSQL Database\nAnalytic RDBMS\nVisualization & Reporting\nSearch & Query\nProcessing\nData Storage\nProcessing and \nAnalytics\nStraight text  –  a technology family\nItalic text  –  a specific technology \nLegend:\nFIGURE 5.5 An example of a Big Data analytics design concepts catalog \n(Source: Softserve)\nwww.EBooksWorld.ir\n5.3 The Design Process 123\nThe  BI  Platform  family  group  and  related  technologies  are  not  considered  \nfurther  in  this  design  exercise  because  the  corporate  BI  tool  is  external  to  the  \ntarget system.\nDesign \nDecisions and","metadata":{"id":458}}],["a40c5b54-5ef7-4ee8-aa2d-e92912c7bc29",{"pageContent":"further  in  this  design  exercise  because  the  corporate  BI  tool  is  external  to  the  \ntarget system.\nDesign \nDecisions and \nLocationRationale and Assumptions\nSelect the Data \nCollector family \nfor the Data \nStream element \nData Collector is a technology family (and an architectural \npattern) that collects, aggregates, and transfers log data for \nlater use. Usually Data Collector implementations offer out-of-\nthe-box plug-ins for integrating with popular event sources and \ndestinations.\nThe destinations are the Raw Data Storage and Real-Time \nViews elements, which will also be addressed in this iteration.\nAlternative   Reason for Discarding\nETL EngineThe main purpose of ETL engines is to perform \nbatch transformations, rather than per-event \noperations. This means that real-time perfor-\nmance and scalability criteria (QA-1, QA-2) will \nbe extremely difficult to meet (if it is possible to \nmeet them at all).\nDistributed \nMessage \nBroker\nAlthough this technology family can be solely","metadata":{"id":459}}],["5f053e00-40c4-4aed-8443-832360c95e09",{"pageContent":"mance and scalability criteria (QA-1, QA-2) will \nbe extremely difficult to meet (if it is possible to \nmeet them at all).\nDistributed \nMessage \nBroker\nAlthough this technology family can be solely \nused to implement the Data Stream element, \nit provides less support for extensibility (QA-9) \nand, therefore, is better suited as a complement \nto the data collector. This can be achieved, \nfor example, using Flavka—a combination of \nApache Flume (Data Collector) and Apache \nKafka (Distributed Message Broker).\nSelect the \nDistributed File \nSystem family \nfor the Raw Data \nStorage element \nAccording to the Lambda architecture principles, the Raw Data \nStorage element must be immutable. Thus new data should not \nmodify existing data, but just be appended to the dataset. Data \nwill be read in batch operations for transforming raw data to \nBatch Views. For these purposes, we can confidently choose a \nDistributed File System. \nAlternative   Reason for Discarding\nNoSQL \nDatabase\nAlthough NoSQL databases (especially col-","metadata":{"id":460}}],["20e5b6e4-8945-4fa9-9425-9b51c585de35",{"pageContent":"Batch Views. For these purposes, we can confidently choose a \nDistributed File System. \nAlternative   Reason for Discarding\nNoSQL \nDatabase\nAlthough NoSQL databases (especially col-\numn-family and document-oriented) can be used \nfor storing raw data, such as logs, this will cause \nunnecessary overhead in resource consumption \n(mostly memory consumption because of cach-\ning mechanisms) and maintainability (because of \nthe need of configuring and evolving a schema).\nAnalytic \nRDBMS\nAll relational databases including analytic capa-\nbilities are based on the relational model, forming \ntables and rows. This works very well for execut-\ning complex queries, but this option is awkward \n(and expensive) for storing semistructured logs \nin their raw format.\n(\ncontinues)\nwww.EBooksWorld.ir\n124 Chapter 5—Case Study: Big Data System \nDesign \nDecisions and \nLocationRationale and Assumptions\nSelect Interactive \nQuery Engine \nfamily for both \nthe Static and Ad \nHoc Batch Views \nelements","metadata":{"id":461}}],["2221d7d3-d347-4567-bfe3-7b9cf9871c98",{"pageContent":"124 Chapter 5—Case Study: Big Data System \nDesign \nDecisions and \nLocationRationale and Assumptions\nSelect Interactive \nQuery Engine \nfamily for both \nthe Static and Ad \nHoc Batch Views \nelements \nAs we stated in the previous iteration, the Batch Views element \nis refined into two elements, the Static and Ad Hoc Batch \nViews, to support two use cases: the generation of static re-\nports (UC-3, 6) and the support for ad hoc querying (UC-4).\nThe main design decision is to use the same technology family \nfor both Static and Ad Hoc Batch Views—namely, the Interac-\ntive Query Engine. These engines allow analytic database ca-\npabilities over data stored in a Distributed File System (thus \nthis technology family is also selected implicitly). If we select a \ntechnology that is fast enough, it can be used for both elements.\nThe benefit of using a single technology family is that we do not \nneed to have separate storage technologies for reporting and \nquerying data. \nAlternative   Reason for Discarding\nNoSQL \nDatabase","metadata":{"id":462}}],["f1952ba4-443e-414b-be56-822182251b10",{"pageContent":"The benefit of using a single technology family is that we do not \nneed to have separate storage technologies for reporting and \nquerying data. \nAlternative   Reason for Discarding\nNoSQL \nDatabase\nThe Static Batch Views element can be imple-\nmented with the Materialized View pattern, by \nstoring data in a form that is ready for querying \nand displaying in a reporting system (a corporate \nBI tool). The NoSQL Database family is often \nused for this purpose because it provides good \nscalability and, being open source, satisfies \nQA-8 (approximately 90 TB of aggregated data) \nand CON-1 (open source license).\nHowever, NoSQL databases are not good op-\ntions to use as data warehouses for ad hoc que-\nries because they were not designed for analytic \npurposes. Although they can be used for this \npurpose, this application will result in significant \nperformance penalties.\nThis alternative is therefore discarded as it can \nbe used only for the Static Batch Views, but is \nineffective for Ad Hoc Batch Views\nAnalytic","metadata":{"id":463}}],["926ce26b-1fd4-43f5-9454-a7bb0d948f2a",{"pageContent":"performance penalties.\nThis alternative is therefore discarded as it can \nbe used only for the Static Batch Views, but is \nineffective for Ad Hoc Batch Views\nAnalytic \nRDBMS\nAd hoc queries can be any queries that are \nsupported by a SQL-like interface. The query \nresult must be returned within “human” time \n(QA-5). The described scenario is exactly what \na data warehouse is used for. This pattern is \nusually implemented with Analytic RDBMS tech-\nnologies following the Kimball or Inmon design \napproaches. At the same time, it will be quite \ncostly to satisfy the scalability requirement of \nhaving approximately 90 TB of aggregated data. \nThe cost per terabyte in MPP analytic data bases \nis significantly higher (up to 30 times) than the \nsame amount of data in a NoSQL database or a \ndistributed file system (such as Hadoop).\nwww.EBooksWorld.ir\n5.3 The Design Process 125\nDesign \nDecisions and \nLocationRationale and Assumptions\nAlternative   Reason for Discarding\nAnalytic \nRDBMS","metadata":{"id":464}}],["c126f7fa-9512-4c4c-9be3-9243ae3989c8",{"pageContent":"distributed file system (such as Hadoop).\nwww.EBooksWorld.ir\n5.3 The Design Process 125\nDesign \nDecisions and \nLocationRationale and Assumptions\nAlternative   Reason for Discarding\nAnalytic \nRDBMS\nThis alternative is rejected because even if it \ncan be used for both Static and Ad Hoc Batch \nViews, the technologies associated with this \nfamily are costly compared to (open source) \nHadoop-based alternatives.\nUse Data \nProcessing \nFramework \nfor the Views \nPrecomputing \nelements\nAs we have already selected the Distributed File System family \nfor Raw Data Storage and Batch Views, the next step is to \nchoose a solution for data transformation from the Raw Data \nStorage to the format used in the Batch Views.\nThe decision is to select Data Processing Framework as \nthis technology family allows data processing pipelines to be \ncreated using abstractions that support faster development and \nbetter maintainability.\nAlternative   Reason for Discarding\nDistributed \nComputing \nEngine","metadata":{"id":465}}],["efd72152-2919-4b51-b8c0-06b77991ed03",{"pageContent":"created using abstractions that support faster development and \nbetter maintainability.\nAlternative   Reason for Discarding\nDistributed \nComputing \nEngine\nMost Distributed Computing Engine technologies \nare designed for batch data processing, but \nrequire substantial knowledge of low-level \nprimitives (e.g., for writing MapReduce tasks). \nEvent \nStream \nProcessor\nThis is designed for real-time streaming \nprocessing; it is ineffective for batch operations.\nSelect Distributed \nSearch Engine \nfor the Real-Time \nViews element\nThe Real-Time Views element is responsible for full-text search \nover recent logs and for feeding an operational dashboard with \nreal-time monitoring data (UC-1, UC-2). Distributed Search \nEngine is a technology family that serves just such purposes. \nAlternative   Reason for Discarding\nNoSQL \nDatabase\nSome NoSQL databases provide keyword \nsearch or text search, but these are not as \npowerful and fast as search engines that also \nprovide text-processing features such as \nstemming and geolocation.","metadata":{"id":466}}],["405bf932-73e4-476e-88ea-a72a4ff64fe3",{"pageContent":"Some NoSQL databases provide keyword \nsearch or text search, but these are not as \npowerful and fast as search engines that also \nprovide text-processing features such as \nstemming and geolocation.\nAnalytic \nRDBMS\nSome databases provide full-text search \ncapabilities (e.g., MS SQL Server); however, \nthey are less desirable from extensibility, \nmaintenance, and cost standpoints.\nDistributed \nFile System \nand \nInteractive \nQuery \nEngine\nThis approach works well for batch historical \ndata; however, the latency of storing and \nprocessing will be too high for real-time data.\n(\ncontinues)\nwww.EBooksWorld.ir\n126 Chapter 5—Case Study: Big Data System \nDesign \nDecisions and \nLocationRationale and Assumptions\nAutomate \ndeployment of \nthe system with \nPuppet scripts\nPuppet scripts can be used for both Private Cloud (e.g., VMware) \nand Public Cloud (e.g., AWS) deployments. This supports the \nsatisfaction of CON-3. Puppet allows automating the deployment \nprocess as well as managing the configuration of a system.","metadata":{"id":467}}],["69a2ec87-36a2-4c9f-a02a-92d4bf29a900",{"pageContent":"and Public Cloud (e.g., AWS) deployments. This supports the \nsatisfaction of CON-3. Puppet allows automating the deployment \nprocess as well as managing the configuration of a system. \nThere is a library of predefined scripts written by the Puppet \ncommunity to automate the deployment of many popular open \nsource technologies.\n5.3.3.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nIn  this  iteration,  instantiation  is  performed  by  associating  specific  technologies  \nwith the technology families that were previously selected. The instantiation de-\nsign decisions considered and made are summarized in the following table:\nDesign Decision \nand LocationRationale\nUse Apache \nFlume from the \nData Collector \nfamily for the Data \nStream element\nAs a primary candidate technology, we will select Apache \nFlume. It provides the required configurability to support QA-9 \n(adding new data sources by just updating a configuration at \nrun-time).","metadata":{"id":468}}],["3853d25b-79a5-4d0a-a03b-566fbf34554e",{"pageContent":"As a primary candidate technology, we will select Apache \nFlume. It provides the required configurability to support QA-9 \n(adding new data sources by just updating a configuration at \nrun-time).\nAlternativeReason for Discarding\nLogstash or\nFluentd\nAlthough Logstash and Fluentd are quite \npopular technologies (perhaps as popular as \nFlume) and will satisfy the requirements, we \nhave to make a choice and select only one. \nAn extra argument for choosing Flume is its \nsupport by three major Hadoop distribution \nvendors.\nUse HDFS from \nthe Distributed \nFile System family \nfor the Raw Data \nStorage element\nFor this technology, we can confidently choose HDFS, which \nwas designed to support exactly this type of usage scenario \nfor large data sets (QA-7, storing approximately 60 TB of raw \ndata). There are also a number of Hadoop file formats in which \nto store data in HDFS, such as text file, SequenceFile, RCFile, \nORCFile, Avro, and Parquet. The selection of a file format will be \naddressed in the third iteration.","metadata":{"id":469}}],["5b9ea279-5eb6-41f0-ad22-fa5a30f6ecac",{"pageContent":"to store data in HDFS, such as text file, SequenceFile, RCFile, \nORCFile, Avro, and Parquet. The selection of a file format will be \naddressed in the third iteration.\nAlternativeReason for Discarding\nCassandraFSThis technology is dependent on a NoSQL \nDatabase (Cassandra), whereas we have \nchosen Distributed File System alone.\nwww.EBooksWorld.ir\n5.3 The Design Process 127\nDesign Decision \nand LocationRationale\nUse Impala from \nthe Interactive \nQuery Engine \nfamily for both \nthe Static and Ad \nHoc Batch Views \nelements\nWe select Impala as a primary candidate technology, as it offers \ncompetitive performance (although it is still not as fast as the \ntop Analytic RDBMS platforms) and an ODBC interface for \nconnectivity with a corporate BI tool.\nKeeping possible performance issues in mind, we plan a proof-\nof-concept in the next iterations to make sure this technology \nselection satisfies QA-4 (less than 5 seconds report load) and \nQA-5 (less than 2 minutes ad hoc query execution time).","metadata":{"id":470}}],["bf126d72-4819-46b3-bc8e-11925e6401fe",{"pageContent":"of-concept in the next iterations to make sure this technology \nselection satisfies QA-4 (less than 5 seconds report load) and \nQA-5 (less than 2 minutes ad hoc query execution time).\nAlternativeReason for Discarding\nApache Hive \n(Stinger)\nAlthough Hive improved performance thanks \nto the Stinger initiative, the speed of queries is \nstill slow compared to other alternatives such \nas Impala and Spark SQL.\nSpark SQLSpark is a very promising technology for Big \nData analytics, but the use case of serving as a \nSQL adapter for a BI tool might not be optimal \nfor Spark SQL. The downside is the high \nmemory requirements and long query time of \nnoncached data. In contrast, Impala has been \ndesigned and optimized for this exact scenario.\nUse Elasticsearch \nfrom the Distribu-\nted Search En-\ngine family for the \nReal-Time Views \nelements. Use \nKibana from the \nInteractive Dash-\nboard family for \nthe Dashboard/\nVisualization Tool \nelement.\nAs a primary candidate technology, we select Elasticsearch,","metadata":{"id":471}}],["385dbe6e-9308-4f4a-9f16-c79f8c3cb1b7",{"pageContent":"Real-Time Views \nelements. Use \nKibana from the \nInteractive Dash-\nboard family for \nthe Dashboard/\nVisualization Tool \nelement.\nAs a primary candidate technology, we select Elasticsearch, \nsince it also provides a visualization tool: an interactive \ndashboard called Kibana.\nAlthough Kibana is a relatively simple dashboard without \nrole-based security (at least, at the moment of designing this \nsolution), it satisfies use cases UC-1, 2 and QA-2 (auto-refresh \ndashboard with a less than 1 minute period).\nElasticsearch also provides a domain-specific language (Query \nDSL) that is supported by Kibana to query, filter, and visualize \ntime series.\nAlternativeReason for Discarding\nSplunkSplunk also provides indexing and visualization \ncapabilities (offering more features than \nElasticsearch and Kibana); however, CON-1 \ndrives us to prefer an open source solution.\nUse Hive from the \nData Processing \nFramework \nfor the Views \nPrecomputing \nelements\nWe select Hive as a primary technology candidate, although","metadata":{"id":472}}],["fa9b8f6a-02d0-4bfc-bfeb-c5eafe531b86",{"pageContent":"drives us to prefer an open source solution.\nUse Hive from the \nData Processing \nFramework \nfor the Views \nPrecomputing \nelements\nWe select Hive as a primary technology candidate, although \nwe will need to make sure that QA-4 (less than 15 minutes \nlatency) is satisfied by creating a proof-of-concept prototype in a \nsubsequent iteration.\nHive provides a SQL-like language, just like Impala (which \nhas been already selected in this iteration); thus it allows us to \nleverage the skills of data warehouse designers when writing \ndata transformation scripts.\nAlternativeReason for Discarding\nCascading or\nApache Pig\nWe disqualified Cascading and Pig so that we \ncan minimize development time by leveraging \nthe SQL skills of an existing development team. \nwww.EBooksWorld.ir\n128 Chapter 5—Case Study: Big Data System \nThe  data  exchanged  between  the  elements  will  be  defined  more  precisely  \nin subsequent iterations. The format of this data constitutes the “interfaces” be-\ntween the elements.","metadata":{"id":473}}],["b696d03a-e264-4f09-b0a3-eb139ee0be0d",{"pageContent":"The  data  exchanged  between  the  elements  will  be  defined  more  precisely  \nin subsequent iterations. The format of this data constitutes the “interfaces” be-\ntween the elements.\n5.3.3.5 Step 6: Sketch Views and Record Design Decisions\nFigure 5.6 illustrates the result of the instantiation decisions. The responsibilities \nof the elements shown in the diagram were discussed in step 6 of Iteration 1. The \nfollowing table summarizes the technology families and candidate specific tech-\nnologies selected for these elements:\nElementTechnology FamilyCandidate Technology\nData StreamData Collector\nApache Flume\nRaw Data StorageDistributed File System\nHDFS\nAd Hoc Views \nPrecomputing\nData Processing Framework\nApache Hive\nStatic Views \nPrecomputing\nData Processing Framework\nApache Hive\nAd Hoc Batch ViewsInteractive Query Engine\nImpala\nStatic Batch ViewsInteractive Query Engine\nImpala\nReal-Time ViewsDistributed Search Engine\nElasticsearch\nDashboard/\nVisualization Tool\nInteractive DashboardKibana","metadata":{"id":474}}],["04fc4fc7-bf58-4b0d-acef-f54987ab5d0f",{"pageContent":"Impala\nStatic Batch ViewsInteractive Query Engine\nImpala\nReal-Time ViewsDistributed Search Engine\nElasticsearch\nDashboard/\nVisualization Tool\nInteractive DashboardKibana\nTechnology family + (Specific technology)\nLayer \nBoundary\nData Flow \n(with direction indicated)\nQuery Results Flow \nLegend:\nElement \nBoundary\nData Stream\nData \nSources\nData Collector\n(Flume)\nRaw Data \nStorage\nCorporate \nBI Tool\nDashboard/\nVisualization\nTool\nReal-Time Views\nBATCH Layer\nSERVING Layer\nSPEED Layer\nAd Hoc Views\nPrecomputing\nAd Hoc \nBatch Views\nStatic Views\nPrecomputing\nStatic \nBatch Views\nDistributed \nfile system \n(HDFS) \nDistributed \nSearch Engine \n(Elasticsearch) \nData processing\nframework (Hive) \nData processing\nframework (Hive) \n(Kibana)\nInteractive Query \nEngine (Impala)\nInteractive Query \nEngine (Impala)\nFIGURE 5.6 Iteration 2 instantiation design decisions\nwww.EBooksWorld.ir\n5.3 The Design Process 129\nThe next table explains the relationships between elements based on the se-\nlected technologies:\nSource ElementDestination ElementRelationship Description","metadata":{"id":475}}],["21c84cda-9790-47c2-b5b7-8e6a73beb884",{"pageContent":"www.EBooksWorld.ir\n5.3 The Design Process 129\nThe next table explains the relationships between elements based on the se-\nlected technologies:\nSource ElementDestination ElementRelationship Description\nData Sources (logs)Data Stream (Flume)To be defined in the next iteration \nData Stream (Flume)Raw Data Storage \n(HDFS)\nNetwork communication (push) \nthrough Flume HDFS sink\nRaw Data Storage \n(HDFS)\nViews Precomputing \n(Apache Hive)\nLocal and network communication \nencapsulated through Hive\nViews Precomputing \n(Apache Hive)\nBatch Views (Impala)Local and network communication \nencapsulated through Hive\nBatch Views (Impala)Corporate BI ToolNetwork communication (pull) \nthrough ODBC API\nData Stream (Flume)Real-Time Views \n(Elasticsearch)\nNetwork communication (push) \nthrough Flume Elasticsearch sink\nReal-Time Views \n(Elasticsearch)\nDashboard/\nVisualization Tool \n(Kibana)\nNetwork communication (pull) \nthrough Elasticsearch API\n5.3.3.6 Step 7: Perform Analysis of Current Design and Review Iteration","metadata":{"id":476}}],["86ac5612-ad47-45fe-b82c-c9d8867dbf01",{"pageContent":"Real-Time Views \n(Elasticsearch)\nDashboard/\nVisualization Tool \n(Kibana)\nNetwork communication (pull) \nthrough Elasticsearch API\n5.3.3.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement lf Design Purpose\nThe  following  Kanban  table  summarizes  the  design  progress  and  the  decisions  \nmade during the iteration. Note that drivers that were completely addressed in the \nprevious iteration are not shown.\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nUC -1Use Distributed Search Engine (Elastic-\nsearch) and Interactive Dashboard \n(Kibana) to display real-time monitoring \ninformation.\nPending: Model indexes and create UI \nmockup.\nUC-2Use Distributed Search Engine (Elastic-\nsearch) and Interactive Dashboard \n(Kibana) for full-text search over recent \nlog data.\nPending: Model indexes and create a \nproof-of-concept.\nUC-3 \nUC-4\nUse Interactive Query Engine (Impala) for \nthe Batch Views elements.","metadata":{"id":477}}],["c3a2a69c-e032-4c4c-b674-5d083fa2442f",{"pageContent":"(Kibana) for full-text search over recent \nlog data.\nPending: Model indexes and create a \nproof-of-concept.\nUC-3 \nUC-4\nUse Interactive Query Engine (Impala) for \nthe Batch Views elements.\nPending: Model data and typical reports.\n(\ncontinues)\nwww.EBooksWorld.ir\n130 Chapter 5—Case Study: Big Data System \nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nUC-6This use case has been omitted in this \niteration as nonprimary, although it is \nsimilar to UC-3 from an architectural \nstandpoint.\nQ A-1Use Data Collector (Apache Flume) for \nthe Data Stream element.\nPending: Configuration, proof-of-concept, \nand performance tests.\nQA-2\nQA-3\nUse Distributed Search Engine \n(Elasticsearch) and Interactive \nDashboard (Kibana).\nPending: Proof-of-concept and \nperformance tests.\nQA-4Use Interactive Query Engine (Impala) for \nthe Static Batch Views element.\nPending: Model data, proof-of-concept, \nand performance tests.\nQA-5Use Interactive Query Engine (Impala) for","metadata":{"id":478}}],["84a545ec-0aa6-4201-b968-775fe1a92614",{"pageContent":"QA-4Use Interactive Query Engine (Impala) for \nthe Static Batch Views element.\nPending: Model data, proof-of-concept, \nand performance tests.\nQA-5Use Interactive Query Engine (Impala) for \nthe Ad Hoc Batch Views element.\nPending: Model data, proof-of-concept, \nand performance tests.\nQA-6Use Distributed Search Engine \n(Elasticsearch) for the Real-Time Views \nelement.\nPending: Do capacity planning.\nQA-7Use Distributed File System (HDFS) for \nthe Raw Data Storage element.\nPending: Select file format and do \ncapacity planning.\nQA-8Use Distributed File System (HDFS) as \nstorage for Batch Views.\nPending: Select file format and do \ncapacity planning.\nQA-9Use Data Collector (Apache Flume) for \nthe Data Stream element.\nPending: Configuration and proof-of-\nconcept.\nQ A-10Use fault tolerance in all system \nelements.\nPending: Stress test.\nQ A -11Use Puppet scripts to automate the \ndeployment process for different \nenvironments.\nwww.EBooksWorld.ir\n5.3 The Design Process 131\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed","metadata":{"id":479}}],["5cf2d1be-4413-44d7-aae7-9b57e002796d",{"pageContent":"Q A -11Use Puppet scripts to automate the \ndeployment process for different \nenvironments.\nwww.EBooksWorld.ir\n5.3 The Design Process 131\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nCON -1All the selected technologies are open \nsource.\nCON-2Use Interactive Query Engine (Impala) \nwith ODBC interface.\nCON-3All selected technologies can be \ndeployed to both private cloud (VMware) \nand public cloud (AWS) environments \nusing Puppet scripts.\nCRN -1No relevant decisions made.\nCRN-2Technologies from the Apache Big Data \necosystem were selected and associated \nwith the different elements in the \nreference architecture.\n5.3.4 Iteration 3: Refinement of the Data Stream Element\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD for the third iteration of the design process.\nSome design decisions made in this iteration require the creation of a proof-","metadata":{"id":480}}],["7946624c-deb0-47d3-a22f-975c3a4252ff",{"pageContent":"steps of ADD for the third iteration of the design process.\nSome design decisions made in this iteration require the creation of a proof-\nof-concept prototype, as they cannot be addressed in a purely conceptual manner. \nGiven  that  the  Big  Data  field  is  young  and  technologies  are  rapidly  evolving,  \nproofs-of-concepts  of  key  elements  are  necessary  to  mitigate  technology  risks  \n(e.g.,  incompatibility,  slow  performance,  unsatisfactory  reliability,  limitations  \nof  claimed  features)  and  to  have  the  option  to  switch  to  an  alternative  early  in  \nthe design and development process, thereby saving overall time and budget by \navoiding later rework.\n5.3.4.1 Step 2: Establish the Iteration Goal by Selecting Drivers\nThe  goal  of  this  iteration  is  to  address  several  concerns  associated  with  the  se-\nlection  of  Apache  Flume,  as  the  technology  to  be  used  for  the  Data  Collector","metadata":{"id":481}}],["3d6f2091-b375-4f25-816e-7fefbf39f8d1",{"pageContent":"The  goal  of  this  iteration  is  to  address  several  concerns  associated  with  the  se-\nlection  of  Apache  Flume,  as  the  technology  to  be  used  for  the  Data  Collector  \nelement. Apache Flume provides a reference structure—a data-flow model—de-\npicted in the informal diagram shown in Figure 5.7.\nThe elements in Flume’s structure include:\n§\tThe source: consumes events delivered to it by external data sources such \nas web servers\n§\tThe channel: stores events received by the source\n§\tThe sink: removes events from the channel and puts them in an external \nrepository (i.e., destination)\nThe selection of Apache Flume raises several specific architectural concerns \nthat need to be addressed:\nwww.EBooksWorld.ir\n132 Chapter 5—Case Study: Big Data System \nData\nSources\nSourceChannel\nFlume Agent/Collector\nSink\nDestinations\nData Flow \n(with direction indicated)\nLegend:\nFIGURE 5.7 Apache Flume data-flow reference structure\n§\tSelecting a mechanism for getting data from the external sources","metadata":{"id":482}}],["5796eef7-b5bd-4eb9-947b-3ca49f1fbbf0",{"pageContent":"Flume Agent/Collector\nSink\nDestinations\nData Flow \n(with direction indicated)\nLegend:\nFIGURE 5.7 Apache Flume data-flow reference structure\n§\tSelecting a mechanism for getting data from the external sources\n§\tSelecting specific input formats in the Source element\n§\tSelecting a file data format in which to store the events\n§\tSelecting a mechanism for the channeling events in the channel\n§\tEstablishing a deployment topology for the Data Source elements\nAddressing these specific architectural concerns will contribute to the satis-\nfaction of the following quality attributes:\n§\tQA-1 (Performance)\n§\tQA-7 (Scalability)\n§\tQA-9 (Extensibility)\n§\tQA-10 (Availability)\n5.3.4.2 Step 3: Choose One or More Elements of the System to Refine\nIn this iteration, the focus is on the elements in Flume’s structure.\n5.3.4.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nIn this iteration most of the decisions are about instantiation, since they primarily","metadata":{"id":483}}],["b996fbc7-07b9-467a-8c01-694b6eabbdfd",{"pageContent":"5.3.4.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nIn this iteration most of the decisions are about instantiation, since they primarily \ninvolve configuring the elements that are already established by Flume. The only \nselection design decision involves choosing tactics to satisfy the availability and \nperformance quality attributes.\nwww.EBooksWorld.ir\n5.3 The Design Process 133\nDesign Decisions and \nLocationRationale and Assumptions\nUse Flume in agent/\ncollector configuration. \nAgents are co-located \non the web servers, and \nthe collector runs in the \nData Stream element.\nA Flume instance can run in two modes: as an agent \n(directly co-located in the data sources) or as a collector \n(which combines data streams from multiple agents and \nwrites to destinations).\nFrom these two modes, Flume can be used in different \nconfigurations. The decision is to use Flume in both agent \nand collector configuration: The agents are co-located","metadata":{"id":484}}],["0df539e3-b23f-4b5d-b9e3-2b794e2dc70b",{"pageContent":"writes to destinations).\nFrom these two modes, Flume can be used in different \nconfigurations. The decision is to use Flume in both agent \nand collector configuration: The agents are co-located \nwith the data sources and the Collector runs in the Data \nStream element.\nAlternativeReason for Discarding\nFlume agents are on \neach web server and \nwrite events directly to \nsinks (no collectors)\nGenerates heavy traffic \nfrom 300-plus simultaneous \nconnections to sinks (HDFS \nand Elasticsearch). Produces \nmultiple (per web server) files \nin HDFS, which is suboptimal \nfor this distributed file system \n(rather than having larger \nfiles that aggregate data from \nmultiple web servers).\nFlume collectors \nreceive events directly \nfrom web servers (no \nagents) and write to \nsinks\nDoes not support failover mode. \nIf a collector node fails, the \nconnected web servers will lose \na receiver.\nIntroduce the tactic of \n“maintaining multiples \ncopies of computations” \nby using a load-\nbalanced, failover tiered \nconfiguration","metadata":{"id":485}}],["4429d525-eba5-415b-90b9-4b3434ed4186",{"pageContent":"If a collector node fails, the \nconnected web servers will lose \na receiver.\nIntroduce the tactic of \n“maintaining multiples \ncopies of computations” \nby using a load-\nbalanced, failover tiered \nconfiguration\nOut of the possible topology alternatives, the selected \none is a load-balanced and failover tiered topology \nbased on performance (QA-1, 15,000 events/second) \nand availability (QA-10, no single point of failure) quality \nattribute scenarios. \nAlternativeReason for Discarding\nNot replicating the \ncollector\nThis would decrease \nperformance and availability.\nwww.EBooksWorld.ir\n134 Chapter 5—Case Study: Big Data System \n5.3.4.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nThe  instantiation  design  decisions  made  in  this  iteration  are  summarized  in  the  \nfollowing table:\nDesign Decisions and \nLocationRationale and Assumptions\nUse access and error \nlogs from the Apache \nHTTP Server as input \nformats\nThe system requirements include the collection and","metadata":{"id":486}}],["f9138530-22a0-4c41-aaed-e384a24b355f",{"pageContent":"following table:\nDesign Decisions and \nLocationRationale and Assumptions\nUse access and error \nlogs from the Apache \nHTTP Server as input \nformats\nThe system requirements include the collection and \nanalysis of logs such as web server load, user activities, \nand errors. In reality, there could be tens (and sometimes \nhundreds) of data source types.\nFor the development of the proof-of-concept, a single type \nof data source system is considered: an Apache HTTP \nserver (“web server”). The data to be collected includes \nuser activities that will be tracked through an access log \nand system errors through an error log.\nThe web server access log records all requests \nprocessed by the server. A log entry might look like this:\n143.21.52.246 - - [19/Jun/2014:12:15:17 \n+0000] \"GET /test.html HTTP/1.1\" 200 341 \"-\" \n\"Mozilla/5.0 (X11; Linux x86_64; rv:6.0a1) \nGecko/20110421 Firefox/6.0a1\".\nThis example consists of the following data fields: client \nIP address, client identity, user ID, time stamp, request","metadata":{"id":487}}],["9f6d661d-b81c-4978-806f-cf7fe05f2732",{"pageContent":"\"Mozilla/5.0 (X11; Linux x86_64; rv:6.0a1) \nGecko/20110421 Firefox/6.0a1\".\nThis example consists of the following data fields: client \nIP address, client identity, user ID, time stamp, request \nmethod, request URL, request protocol, response code, \nresponse size, referrer, user agent.\nThe web server error log sends diagnostic information \nand records any errors that it encounters when \nprocessing user requests. For example:\n[19/Jun/2014:14:23:15 +0000] [error] [client \n50.83.180.156] Directory index forbidden by \nrule: /home/httpd/\nThis example consists of the following data fields: time \nstamp, severity level, client IP address, message.\nFurther data modeling and technology configuration will \nbe based on these two types of logs and the described \nfields.\nLog files are piped \nthrough an IP port in the \nsource element of Flume \nagent\nApache Flume is configured to pipe log data through an \nIP port, such as by using syslog.\nAlternativeReason for Discarding\nRead from a log file \n(e.g., running the \nUNIX command","metadata":{"id":488}}],["dc44735b-3e01-49ee-bfd5-3a18f9191812",{"pageContent":"agent\nApache Flume is configured to pipe log data through an \nIP port, such as by using syslog.\nAlternativeReason for Discarding\nRead from a log file \n(e.g., running the \nUNIX command \ntail -F access_log)\nThis option looks the simplest \nbut does not guarantee event \ndelivery (events can be lost), \nwhich is stated in the Flume \nuser guide.\nwww.EBooksWorld.ir\n5.3 The Design Process 135\nDesign Decisions and \nLocationRationale and Assumptions\nIdentify event \nchanneling methods \nfor both the agents and \nthe collector; make \nfinal decision through \nprototyping\nThe ingested events from the Source element are staged \nin the Channel element. At the moment Flume offers three \npossible options to configure the channel:\n1. Memory channel: in-memory queue; faster, but if any \nevents are left in the memory queue when a Flume \nprocess dies, they cannot be recovered.\n2. File channel: durable and backed up by the local file \nsystem.\n3. Apache Kafka: an approach in which Kafka serves as \na distributed and highly available channel.","metadata":{"id":489}}],["359f160b-cc95-4bcf-9c90-6ebc30f28bd5",{"pageContent":"process dies, they cannot be recovered.\n2. File channel: durable and backed up by the local file \nsystem.\n3. Apache Kafka: an approach in which Kafka serves as \na distributed and highly available channel.\nThe selection from these options actually is a “classic” \ntradeoff of performance versus availability (or what is \nsometimes termed durability). Although we do not have \nan explicit durability scenario, we understand that with \nthe future system extension (UC-6, security reports), this \nrequirement becomes more critical. This is an example \nof an architectural concern, in the sense that it does not \nappear in any requirements document, but the architect \nhas to deal with it nonetheless.\nGiven these options and no publicly available information \nabout the performance consequences, this is a good \ncandidate for prototyping and making a decision based \non the results. Another rationale for prototyping and \nperformance measurement is the need to calculate the","metadata":{"id":490}}],["4e02ab6d-17e7-4aa0-9c72-2206c76f9fb1",{"pageContent":"candidate for prototyping and making a decision based \non the results. Another rationale for prototyping and \nperformance measurement is the need to calculate the \nrequired hardware resources. As a consequence, a new \nconcern is identified and added to the backlog:\n ■\nCRN-3: Data modeling and developing proof-of-concept \nprototypes for key system elements\nSelect Avro as a specific \nfile format for storing raw \ndata in the HDFS sink\nOne decision that needs to be made when designing a \nsolution based on Hadoop is the selection of an optimal file \nformat. Hadoop supports a variety of formats that provide \ndifferent functionalities, compression, and performance \nresults depending on stored data and usage scenarios.\nIn this case the main scenarios are related to quality \nattributes such as performance (QA-1, 15,000 events/\nsecond), scalability (QA-7, approximately 60 TB of raw \ndata), and extensibility (QA-9, adding new data sources). \nWhen we translate these requirements to file format traits,","metadata":{"id":491}}],["96f1f656-9381-4395-910d-d8ef4942d871",{"pageContent":"second), scalability (QA-7, approximately 60 TB of raw \ndata), and extensibility (QA-9, adding new data sources). \nWhen we translate these requirements to file format traits, \nthey will be impacted by performance (how fast data can \nbe pushed by the Data Stream), a compression factor \n(less space to store), and ease of schema evolution \n(when adding new log formats or changing existing ones).\nWe select Avro, as it supports rich data structures, \nprovides good compression levels (with the Snappy \ncompression codec), and is flexible enough to \naccommodate schema changes (employing a self-\ndescribing format where data is stored with its schema).\n(\ncontinues)\nwww.EBooksWorld.ir\n136 Chapter 5—Case Study: Big Data System \nDesign Decisions and \nLocationRationale and Assumptions\nAlternativeReason for Discarding\nText file (plain \ntext, CSV, \nXML, JSON)\nThe compression ratio is poor com-\npared with binary file formats (e.g., \nAvro). Also, text files do not support \nblock compression, which is necessary","metadata":{"id":492}}],["c67b12f7-d8d1-4af4-9c79-5ecf94b7ba85",{"pageContent":"Text file (plain \ntext, CSV, \nXML, JSON)\nThe compression ratio is poor com-\npared with binary file formats (e.g., \nAvro). Also, text files do not support \nblock compression, which is necessary \nwhen storing files larger than the size of \nan HDFS block. \nSequenceFileDoes not support flexible schema \nevolution. Consists of binary key/value \npairs and does not store metadata with \nthe data.\nRCFileThis Hadoop columnar file format does \nnot support schema evolution, and \nwriting requires more CPU and memory \ncompared with non-columnar formats.\nORCFileOptimized RCFile provides better \ncompression and faster querying, but \nhas the same drawbacks as RCFile \nin terms of schema evolution, at the \nexpense of writing performance.\nParquetParquet is a columnar file format that \npartially supports schema evolution, but \nstill is slower for write operations com-\npared with non-columnar file formats.\n5.3.4.5 Step 6: Sketch Views and Record Design Decisions\nFigure 5.8 illustrates the result of the instantiation decisions.","metadata":{"id":493}}],["261475ec-459a-4f7d-a5dd-51c9752f28fd",{"pageContent":"still is slower for write operations com-\npared with non-columnar file formats.\n5.3.4.5 Step 6: Sketch Views and Record Design Decisions\nFigure 5.8 illustrates the result of the instantiation decisions.\nElementResponsibility\nFlume agentConsume log events generated by a web server, split \ntext log entries to separate fields, and deliver the parsed \nevent records to a collector.\nFlume collectorCollect event records from multiple agents in a load-\nbalanced and fault-tolerant manner and deliver them \nto destinations (HDFS and Elasticsearch) for further \npersistency and processing.\nwww.EBooksWorld.ir\n5.3 The Design Process 137\nreplicatingreplicating\n+ log parsing\n+ log parsing\nLB\n+\nfailover\n...\nCollector\nSPEED Layer\nBATCH Layer\nData Stream\nWebServer1 (Data Source)\nFlume Collector Tier\nStorage Tier\nMemory channel\n(error)\nnetcatsrc\n(access)\nnetcatsrc\n(error)\nMemory channel\n(access )\navrosink\n(access)\navrosink\n(error)\nHDFS\nElasticsearch\nApplication Tier\nFlumeCollector \nMemory channel\nES\navrosrc\n(access)\nMemory channel\nHDFS\nHDFS sink\n(access)","metadata":{"id":494}}],["4535ff12-ad7f-48ab-966c-74aa3b5af1ad",{"pageContent":"(access)\nnetcatsrc\n(error)\nMemory channel\n(access )\navrosink\n(access)\navrosink\n(error)\nHDFS\nElasticsearch\nApplication Tier\nFlumeCollector \nMemory channel\nES\navrosrc\n(access)\nMemory channel\nHDFS\nHDFS sink\n(access)\nES sink\n(access)\nMemory channel\nES\navrosrc\n(error)\nMemory channel\nHDFS\nHDFS sink\nES sink\n(error)\nWebServer2 (Data Source)\nMemory channel\n(error)\nnetcatsrc\n(access)\nnetcatsrc\n(error)\nMemory channel\n(access )\navrosink\n(access)\navrosink\n(error)\nWebServerN (Data Source)\nFlume Agent Flume Agent Flume Agent \nMemory channel\n(error)\nnetcatsrc\n(access)\nnetcat\nsrc\n(e\nrror)\nMemory channel\n(access )\navrosink\n(access)\navrosink\n(error)\navro\njson\n(error)\nData flow between nodesData flow between flume components within the same node\nLegend:\nFIGURE 5.8\n \nIteration 3 instantiation design decisions\nwww.EBooksWorld.ir\n138 Chapter 5—Case Study: Big Data System \n5.3.4.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  following  Kanban  table  summarizes  the  design  progress  and  the  decisions","metadata":{"id":495}}],["46ecce4c-6ba3-4c0b-a2ba-b5ca14a12705",{"pageContent":"5.3.4.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  following  Kanban  table  summarizes  the  design  progress  and  the  decisions  \nmade during the iteration. Note that drivers that were completely addressed in the \nprevious iteration are not shown.\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nUC -1\nUC-2\nUC-3\nUC-4\nRefinement of the Data Stream element. \nDecisions about other elements that \nparticipate in these use cases still need to \nbe made.\nQ A-1Flume load-balanced, failover tiered \nconfiguration is selected.\nQA-9Usage of Flume and Avro format for \nstoring raw data.\nQ A-10Flume load-balanced, failover tiered \nconfiguration is selected.\nDecisions on other elements that partici-\npate in this scenario still need to be made.\nCRN -1Tiers were identified for the Flume \ncollector and storage.\nCRN-3This is a new architectural concern that \nwas introduced in this iteration: data","metadata":{"id":496}}],["a5406bce-9ce6-4ea9-ae64-9e076cddf2cc",{"pageContent":"pate in this scenario still need to be made.\nCRN -1Tiers were identified for the Flume \ncollector and storage.\nCRN-3This is a new architectural concern that \nwas introduced in this iteration: data \nmodeling and developing proof-of-concept \nprototypes for key system elements. At \nthis point, no relevant decisions have \nbeen made.\n5.3.5 Iteration 4: Refinement of the Serving Layer\nWe now present the results of the activities that are performed in each of the steps \nof ADD in the fourth iteration of the design process.\nWe selected the Serving Layer for refinement (not the Batch Layer) because \nthe  risk  of  not  achieving  requirements  is  higher  for  this  layer.  This  layer  is  di-\nrectly  involved  in  use  cases  UC-3  and  UC-4  and  a  number  of  quality  attribute  \nscenarios in which performance and scalability are critical factors.\nAs  in  the  previous  iteration,  design  activities  involve  the  creation  of  pro-","metadata":{"id":497}}],["36d8c0a1-34b6-449a-b896-373fb81957ed",{"pageContent":"scenarios in which performance and scalability are critical factors.\nAs  in  the  previous  iteration,  design  activities  involve  the  creation  of  pro-\ntotypes.  In  this  iteration,  UI  prototypes  are  also  created.  There  are  at  least  two  \nreasons for this:\n§\tIt will facilitate receiving early feedback from users, which can help to up-\ndate requirements.\n§\tData visualization scenarios often have an influence on data modeling.\nwww.EBooksWorld.ir\n5.3 The Design Process 139\n5.3.5.1 Step 2: Establish the Iteration Goal by Selecting Drivers\nThe  goal  of  this  iteration  is  to  address  the  newly  identified  concern  of  data  \nmodeling  and  developing  proof-of-concept  prototypes  for  key  system  elements  \n(CRN-3) so as to satisfy the primary use cases and system requirements associ-\nated with the analysis and visualization of historic data. These use cases include:\n§\tUC-3\n§\tUC-4\nThe quality attribute scenarios associated with these use cases are:\n§\tQA-4 (Performance)","metadata":{"id":498}}],["5199553e-9948-4180-9878-2adb9dade3ea",{"pageContent":"ated with the analysis and visualization of historic data. These use cases include:\n§\tUC-3\n§\tUC-4\nThe quality attribute scenarios associated with these use cases are:\n§\tQA-4 (Performance)\n§\tQA-5 (Performance)\n§\tQA-7 (Scalability)\n§\tQA-8 (Scalability)\n5.3.5.2 Step 3: Choose One or More Elements of the System to Refine\nIn this iteration, the elements that are refined are the ones that support historical \ndata,  which  include  the  Serving  Layer  elements:  the  Ad  Hoc  and  Static  Batch  \nViews. Given that both types of elements use the same technology (Impala), the \ndecisions made in this iteration affect both types of elements.\n5.3.5.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nAs in the previous iteration, the design activities here involve the configuration of the \ntechnologies that were associated with the elements. For this reason, no new design \nconcepts are selected and all of the decisions belong to the instantiation category.","metadata":{"id":499}}],["2df08605-7723-4a13-9bd5-61dd6e11f938",{"pageContent":"technologies that were associated with the elements. For this reason, no new design \nconcepts are selected and all of the decisions belong to the instantiation category.\n5.3.5.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nIn  this  iteration,  design  concepts  are  instantiated  based  on  the  best  practices  of  \nusing the chosen technologies.\nDesign Decisions \nand LocationRationale and Assumptions\nSelect Parquet as a \nfile format for Impala \nin the Batch Views\nThe decision-making process for selecting a file format for \nBatch Views is similar to that in the previous iteration, where \nwe selected a format for raw data storage. The data usage \nscenario is somewhat different, however. The previous case \nwas about fast writing, effectively storing data, and extending \ndata formats. This case is focused on fast querying (QA-4, \nless than 5 seconds report load; QA-5, less than 2 minutes \nad hoc query execution time), although scalability (QA-8,","metadata":{"id":500}}],["bba8cf49-a371-44f6-9e9a-e3c3848b2a0c",{"pageContent":"data formats. This case is focused on fast querying (QA-4, \nless than 5 seconds report load; QA-5, less than 2 minutes \nad hoc query execution time), although scalability (QA-8, \napproximately 90 TB of aggregated data) and extensibility \n(QA-9, adding new data sources) drivers are still relevant.\nOut of all the available alternatives, the Parquet file format \nlooks like the most promising option to satisfy these \nrequirements.\n(\ncontinues)\nwww.EBooksWorld.ir\n140 Chapter 5—Case Study: Big Data System \nDesign Decisions \nand LocationRationale and Assumptions\nSelect Parquet as a \nfile format for Impala \nin the Batch Views\nIn Parquet, a columnar structure represents relational \ntables on computer clusters and is designed for fast query \nprocessing, which is important for ad hoc data exploration \nand static reports. In addition, Parquet is optimized for Impala, \nwhich we selected as a primary technology for the interactive \nquery engine during the second iteration. Finally, it provides a","metadata":{"id":501}}],["9887ca3e-5f3c-4324-be3b-79f27d789ed0",{"pageContent":"and static reports. In addition, Parquet is optimized for Impala, \nwhich we selected as a primary technology for the interactive \nquery engine during the second iteration. Finally, it provides a \ngood compression ratio and allows some schema extension, \nby adding new columns at the end of the structure.\nAlternativeReason for Discarding\nText file (plain \ntext, CSV, XML, \nJSON)\nSlow for reads, especially when \nquerying individual columns. \nAlso does not support block \ncompression, which is necessary \nwhen storing files larger than the \nsize of an HDFS block.\nSequenceFileSlow for reads, especially when \nquerying individual columns.\nRCFileThe first columnar file format \nadopted in Hadoop. Does not \nsupport schema evolution.\nORCFileProvides better compression and \nfaster querying than RCFile, but has \nthe same drawbacks as RCFile in \nterms of schema evolution.\nCompared with Parquet, the \ncompression ratio is better, but \nquery performance is slower.\nAnother major limitation is that it is \nnot supported by Impala.","metadata":{"id":502}}],["9d646a7f-4a49-4ef3-a735-f61e56dd1c69",{"pageContent":"terms of schema evolution.\nCompared with Parquet, the \ncompression ratio is better, but \nquery performance is slower.\nAnother major limitation is that it is \nnot supported by Impala.\nAvroAlthough Avro is considered the \nbest multipurpose storage format \nfor Hadoop, its query performance \nis noticeably slower compared with \ncolumnar formats, such as RCFile, \nORCFile, and Parquet. \nwww.EBooksWorld.ir\n5.3 The Design Process 141\nDesign Decisions \nand LocationRationale and Assumptions\nUse the star schema \nas a data model in \nthe Batch Views\nIn the previous iteration, we selected Impala as a single \ntechnology for the Batch Views components, which impacts \nboth static reports (UC-3, 6) and ad hoc querying (UC-4).\nThe star schema technique was selected for two reasons:\n ■\nImpala was designed for analytical queries, so it naturally \nprovides good support for star schema data modeling.\n ■\nAd hoc querying in combination with BI tools requires data \nto be well modeled to simplify query complexity and, as a","metadata":{"id":503}}],["12323882-3209-43d5-a20e-149f28161ea3",{"pageContent":"provides good support for star schema data modeling.\n ■\nAd hoc querying in combination with BI tools requires data \nto be well modeled to simplify query complexity and, as a \nresult, allow faster query performance.\nIn our case, the star schema was designed to have small-\ndimension (in terms of number of rows) tables to avoid \njoins between big tables, as this typically consumes large \namounts of system resources and affects query execution \nperformance. Small-dimension tables can fit in memory and \njoins can be performed more effectively.\nAlternativeReason for Discarding\nFlat tablesFlat tables are typically represented in \nthe format of wide denormalized tables \nthat contain all measures and dimension \nattributes.\nFlat tables can cause significant \nperformance issues when querying \nagainst large volumes of data.\n5.3.5.5 Step 6: Sketch Views and Record Design Decisions\nFigure  5.9  depicts  the  star  schema  data  model  implemented  using  Impala  and  \nParquet.","metadata":{"id":504}}],["3785a051-a195-406d-b479-6448fab648aa",{"pageContent":"against large volumes of data.\n5.3.5.5 Step 6: Sketch Views and Record Design Decisions\nFigure  5.9  depicts  the  star  schema  data  model  implemented  using  Impala  and  \nParquet.\nThe screenshot in Figure 5.10 presents a sample static report implemented \nwith Tableau to demonstrate a possible view through a corporate BI tool. The re-\nport was created using test data stored in Parquet and provided by Impala through \nthe ODBC interface.\nwww.EBooksWorld.ir\n142 Chapter 5—Case Study: Big Data System \ndim_request\ndim_referrer\nrequest_id <pi> int\nrequest_method             string\nrequest_url                     string\nrequest_protocol            string\nfact_access\nclient_ip   string\nrequest_id  <fi5> int\nreferrer_id  <fi4> int\nuser_agent_id  <fi1> int\ncity_id  <fi2> int\nzip_code_id  <fi3> int\nlatitude   string\nlongitude   string\nevent_timestamp     Timestamp\nserver_host   string\nrequst_time   int\nresponse_code   smallint\nresponse_size   int\nreferrer_id <pi> int\nreferrer_url                    string","metadata":{"id":505}}],["6ab3d5c9-db47-469e-a7d6-20a37456d600",{"pageContent":"longitude   string\nevent_timestamp     Timestamp\nserver_host   string\nrequst_time   int\nresponse_code   smallint\nresponse_size   int\nreferrer_id <pi> int\nreferrer_url                    string\nreferrer_site                   string\ndim_city\ncity_id <pi> int\ncity   string\nregion   string\ncountry   string\ndim_user_agent\nuser_agent_id <pi> int\nuser_agent_full    string\nbrowser   string\ndevice_type   string\nos   string\ndim_zip_code\nzip_code_id <pi> int\nzip_code   string\nfact_error\nevent_timestamp     Timestamp\nmessage_id  <fi1> int\nserver_host   string\nclient_ip   string\nlevel   string\ndim_message\nmessage_id <pi> int\nmessage_url                  string\nFIGURE 5.9 Star schema implemented in Impala and Parquet\nFIGURE 5.10 Sample static report implemented with Tableau\nwww.EBooksWorld.ir\n5.4    Summary 143\n5.3.5.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  following  Kanban  table  summarizes  the  design  progress  and  the  decisions","metadata":{"id":506}}],["1ddf6cfe-83bd-4f46-8c5d-ad3471f406a4",{"pageContent":"5.3.5.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe  following  Kanban  table  summarizes  the  design  progress  and  the  decisions  \nmade during the iteration. Note that drivers that were completely addressed in the \nprevious iteration are not shown.\nNot \nAddressed\nPartially \nAddressed\nCompletely \nAddressed\nDesign Decisions Made During the \nIteration\nUC-3  \nUC-4\nRefinement of the Serving Layer, which is \nused in the use case. Decisions on other \nelements that participate in these use \ncases still need to be made.\nQA-4  \nQA-5  \nQA-8\nUse Parquet and star schema. \nPerformance tests are still required and \nthus a new concern is introduced:\n ■\nCRN-4: Develop performance tests.\nCRN -1No relevant decisions made.\nCRN-3Data modeling and proof-of-concept \nprototypes were developed for the \nelements in the Serving Layer, but the \nsame activity remains to be completed for \nthe elements in the Speed Layer.\n5.4    Summary","metadata":{"id":507}}],["0874f27c-32f0-4ac0-8dd2-f364482bb79e",{"pageContent":"prototypes were developed for the \nelements in the Serving Layer, but the \nsame activity remains to be completed for \nthe elements in the Speed Layer.\n5.4    Summary\nIn  this  chapter  we  presented  an  extended  example  of  using  ADD  3.0  in  a  rela-\ntively  novel  domain,  that  of  Big  Data.  As  this  example  shows,  architectural  de-\nsign  can  require  many  detailed  decisions  to  be  made  to  ensure  that  the  quality  \nattributes will be satisfied.\nAlso, this example shows that a large number of decisions rely on knowledge \nof many different patterns and technologies. The more novel the domain, the more \nlikely that preexisting information (e.g., design concepts catalog, books of patterns, \nand reference architectures) will not be available for it. In such a case, you need to \nrely  on  your  own  judgment  and  experience,  or  you  need  to  perform  experiments  \nand build prototypes. One way or another, such decisions must be made.","metadata":{"id":508}}],["e2f20df4-7ef7-4b27-bb6e-ff498ca59442",{"pageContent":"rely  on  your  own  judgment  and  experience,  or  you  need  to  perform  experiments  \nand build prototypes. One way or another, such decisions must be made.\nThis instance of ADD also differed from the example presented in Chapter 4 \nin that we spent relatively little time and effort on building sequence diagrams as \na means of deriving interface specifications. The example presented here relied on \na relatively simple data-flow architecture with a modest number of components, \nso  sequence  diagrams  were  not  needed  to  understand  the  relationships  between  \nthe  components.  The  “contracts”  between  the  elements  were  determined  by  the  \ninformation exchanged, as exemplified in step 5 of Iteration 3 (Section 5.3.4.4).\nwww.EBooksWorld.ir\n144 Chapter 5—Case Study: Big Data System \n5.5 Further Reading\nThe  design  of  a  data  warehouse  has  been  extensively  studied.  Two  good  ap-\nproaches are documented in R. Kimball and M. Ross, The Data Warehouse Tool-","metadata":{"id":509}}],["0b68c46d-ee3d-4aa1-895b-f24a6ea3b557",{"pageContent":"5.5 Further Reading\nThe  design  of  a  data  warehouse  has  been  extensively  studied.  Two  good  ap-\nproaches are documented in R. Kimball and M. Ross, The Data Warehouse Tool-\nkit, 3rd ed., Wiley, 2013; and W. Inmon, Building the Data Warehouse, 4th ed., \nWiley, 2005.\nThe Lambda architecture was first presented by N. Marz and J. Warren, Big \nData:  Principles  and  Best  Practices  of  Scalable  Realtime  Data  Systems,  Man-\nning, 2015.\nA good discussion of how to engineer for scalability can be found in M. Ab-\nbott and M. Fisher, The Art of Scalability: Scalable Web Architecture, Processes, \nand Organizations for the Modern Enterprise, Addison-Wesley, 2010.\nP. Sadalage and M. Fowler. NoSQL Distilled: A Brief Guide to the Emerging \nWorld of Polyglot Persistence, Addison-Wesley, 2009.\nA discussion of how and when to prototype as part of the architecture design \nprocess can be found in H-M Chen, R. Kazman, and S. Haziyev, “Strategic Pro-","metadata":{"id":510}}],["65cd17fe-8fa9-43a7-9a48-683227ea7c01",{"pageContent":"A discussion of how and when to prototype as part of the architecture design \nprocess can be found in H-M Chen, R. Kazman, and S. Haziyev, “Strategic Pro-\ntotyping for Developing Big Data Systems”, IEEE Software, March/April 2016.\nA design concepts catalog that includes many of the reference architectures \nand  technologies  used  in  this  case  study  is  part  of  the  Smart  Decisions  Game,  \nwhich  can  be  found  at  H.  Cervantes,  S.  Haziyev,  O.  Hrytsay,  and  R.  Kazman,  \n“Smart Decisions Game”, http://smartdecisionsgame.com.\nwww.EBooksWorld.ir\n145\n6\nCase Study: Banking \nSystem\nChapters  4  and  5  were  both  instances  of  greenfield  development.  In  truth,  that  \nkind of development is relatively rare. Most of the time you, as an architect, will \nbe working on evolving an existing system rather than creating one from scratch. \nIn this chapter, we present an example of using ADD 3.0 for a brownfield system","metadata":{"id":511}}],["586d32d3-8438-4ad8-9466-840597da3050",{"pageContent":"be working on evolving an existing system rather than creating one from scratch. \nIn this chapter, we present an example of using ADD 3.0 for a brownfield system \nin a mature domain (as discussed in Section 3.3.3). We first present the business \ncontext and then examine the project’s existing architectural documentation. This \nis followed by a step-by-step summary of the activities that are performed during \nthe ADD iterations to evolve the system. While this is a real system, some of the \ndetails have been changed to protect the identities of the actors.\n6.1 Business Case\nIn 2010, the government of a Latin American country issued a regulation that re-\nquired banking institutions to digitally sign bank statements. To comply with the \nregulation, “ACME Bank” decided to commission the development of a software \nsystem, which we will call BankStat, whose main purpose was the generation of \ndigitally signed bank statements.\nFigure 6.1 presents a context diagram that illustrates how the BankStat sys-","metadata":{"id":512}}],["599a041a-4ec9-4906-a574-0031f65c12dc",{"pageContent":"system, which we will call BankStat, whose main purpose was the generation of \ndigitally signed bank statements.\nFigure 6.1 presents a context diagram that illustrates how the BankStat sys-\ntem works. At its core, the system executes a batch process, which retrieves raw \nwww.EBooksWorld.ir\n146 Chapter 6—Case Study: Banking System\nbank  statement  information  from  a  data  source  (an  external  database)  and  then  \nperforms a series of validations on this data to generate the bank statements and \nprepare them for digital signature by an external provider. The statements are sent \nto the provider, which returns the signed bank statements. These statements are \nthen stored by BankStat for further processing, including sending the statements \nto  customers.  This  batch  process  is  triggered  automatically  once  a  month  and,  \nduring its execution, approximately 2 million bank statements are processed.\nThe following quality attributes scenarios are primary for this system:","metadata":{"id":513}}],["16a277b8-15b5-4ea4-bb26-2932cc5fbfde",{"pageContent":"during its execution, approximately 2 million bank statements are processed.\nThe following quality attributes scenarios are primary for this system:\n§\tReliability: Under normal operating conditions, the batch process is execut-\ned in its entirety 100% of the time.\n§\tPerformance: Under normal operating conditions, when the batch process \nstarts, 2 million bank statements are read, processed, and sent to the signing \nprovider in at most one hour.\n§\tAvailability: During normal processing, a failure may occur when reading \ninformation from the data source or when sending information for digital \nsignature. A notification is then sent to the administrator, who manually \nrestarts the process. When it is restarted, only the information that had not \nalready been processed is treated.\nDue to time constraints imposed by the government, only the core batch pro-\ncess  for  the  system  was  developed  and  put  into  production.  This  initial  release,","metadata":{"id":514}}],["2dfc6ca5-7ecb-4455-9ee5-36dda8c3f913",{"pageContent":"Due to time constraints imposed by the government, only the core batch pro-\ncess  for  the  system  was  developed  and  put  into  production.  This  initial  release,  \nhowever, did not provide a friendly interface with the system, which is necessary \nto monitor the state of the bank statement processing, to request the reprocessing \nof  incorrect  statements.  and  to  generate  reports.  In  the  first  release,  the  process  \ncould only be started or stopped manually from a console. For a second release \nof the system, the ACME Bank requested an extension of the BankStat system to \nbetter address these shortcomings.\n:\nFIGURE 6.1 Context diagram for the BankStat system\nwww.EBooksWorld.ir\n6.1 Business Case 147\nThe following subsections present the drivers for this second release of the \nsystem.\n6.1.1 Use Case Model\nFigure 6.2 presents the use case model for the second release of BankStat.\nThese use cases are described in more detail here:\nUse CaseDescription\nUC -1: Quer y \nand reprocess \nstatements","metadata":{"id":515}}],["7792b925-1be0-4a23-8856-0f8ecd16903b",{"pageContent":"Figure 6.2 presents the use case model for the second release of BankStat.\nThese use cases are described in more detail here:\nUse CaseDescription\nUC -1: Quer y \nand reprocess \nstatements\nThe user manually requests the reprocessing of a number \nof statements. The user specifies criteria to query and select \nthe statements that must be reprocessed. The user can, for \nexample, select a period of interest or status of the statements \nthat he is interested in (e.g., processed, signed, non-signed).\nUC-2: Log inThe user logs in to the system.\nUC-3: Generate \nreport\nThe user generates reports regarding the process. \nUC-4: Query \nusers log\nThe administrator queries user logs to display the activities of \na particular user or groups of users. Information can be filtered \nusing criteria such as dates or types of operations.\nFIGURE 6.2 Use cases for the BankStat system (Key: UML)\nwww.EBooksWorld.ir\n148 Chapter 6—Case Study: Banking System\n6.1.2 Quality Attribute Scenarios","metadata":{"id":516}}],["c49b1af3-5ff4-450d-9d79-d6f33d2dbc70",{"pageContent":"using criteria such as dates or types of operations.\nFIGURE 6.2 Use cases for the BankStat system (Key: UML)\nwww.EBooksWorld.ir\n148 Chapter 6—Case Study: Banking System\n6.1.2 Quality Attribute Scenarios\nThe following table presents the new quality attribute scenario that is considered \nfor this extension of the system.\nID\nQuality \nAttributeScenario\nAssociated \nUse Case\nQ A-1SecurityA user performs any operation on the system, \nat any moment, and 100% of the operations \nperformed by the user are recorded by the \nsystem in the operations log.\nUC-4\n6.1.3    Constraints\nThe following table presents the constraints that are considered for this extension \nof the system.\nIDConstraint\nCON -1The user’s accounts and permissions are handled by an existing user \ndirectory server that is used by various applications in the bank.\nCON-2Communication with the data source must be realized using JDBC.\nCON-3Communication with the digital signature provider system is \nperformed using web services. These web services receive and","metadata":{"id":517}}],["07916967-e401-45b5-b410-cf613d37acc0",{"pageContent":"CON-2Communication with the data source must be realized using JDBC.\nCON-3Communication with the digital signature provider system is \nperformed using web services. These web services receive and \nreturn the information in an XML format that adheres to specifications \nestablished by the government.\nCON-4The system must be accessed from a web browser, although the \naccess is available only from the bank’s intranet.\n6.1.4 Architectural Concerns\nThe  following  table  presents  the  concerns  that  are  initially  considered  for  this  \nextension of the system.\nIDConcern\nCRN -1The system shall be programmed using Java and Java-related \ntechnologies to leverage the expertise of the development team.\nCRN-2The introduction of new functionality must, as far as possible, avoid \nmodifications to the existing batch processing core.\nwww.EBooksWorld.ir\n6.2 Existing Architectural Documentation 149\n6.2 Existing Architectural Documentation","metadata":{"id":518}}],["1408315d-a6f3-4960-b635-db0f8d79b186",{"pageContent":"modifications to the existing batch processing core.\nwww.EBooksWorld.ir\n6.2 Existing Architectural Documentation 149\n6.2 Existing Architectural Documentation\nThis  section  presents  a  simplified  version  of  the  system’s  views,  which  provide  \nrelevant information for the changes in the architecture.\n6.2.1 Module View\nThe package diagram shown in Figure 6.3 depicts the system layers and the mod-\nules that they contain.\nFIGURE 6.3 Existing modules and layers in the BankStat system (Key: UML)\nwww.EBooksWorld.ir\n150 Chapter 6—Case Study: Banking System\nThe responsibilities of the elements depicted in the diagram are described in \nthe following table.\nElementResponsibility\nBatch Processing \nLayer\nThis layer contains modules that perform the batch process. \nThese components are developed using the Spring Batch \nframework.\nData Access LayerThis layer contains modules that store and retrieve data \nfrom a local database, which is used by the modules in the \nBatch Processing Layer.\nCommunications \nLayer","metadata":{"id":519}}],["b5152796-bbb9-4031-9535-9f2ad7617210",{"pageContent":"framework.\nData Access LayerThis layer contains modules that store and retrieve data \nfrom a local database, which is used by the modules in the \nBatch Processing Layer.\nCommunications \nLayer\nThis layer contains modules that support communication \nwith the external digital signature provider and the bank \nstatement data source.\nBatch Job \nCoordinator\nThis module is responsible for coordinating the execution \nof the batch process, including launching the process and \ninvoking the different steps associated with it.\nJob StepsThis module contains the “steps” that are part of the batch \njob. These steps perform activities such as validating the \ninformation retrieved from the data source and generating \nthe bank statements. Such steps generally read, process, \nand write data. Data is read from and written to the local \ndatabase.\nLocal Database \nConnector\nThis module is responsible for accessing a local database \nused by the job steps to exchange information while","metadata":{"id":520}}],["1e904af0-f6e6-4e34-875d-43476a257600",{"pageContent":"database.\nLocal Database \nConnector\nThis module is responsible for accessing a local database \nused by the job steps to exchange information while \nperforming the batch process. We refer to this database \nas “local” to differentiate it from the external data source; \nthis database is used only locally (i.e., internally) by the \napplication, even if it is deployed in a different node (see the \nnext section).\nNotifications ManagerThis module manages logs and sends notifications in case \nof issues such as a communication failure with the external \nsystem.\nData Source \nConnector\nThis module is responsible for connecting with the external \ndatabase that provides the raw bank statement information.\nDigital Signature \nProvider Connector\nThis module is responsible for accessing the external \nsystem that performs the digital signing of the bank \nstatements.\n6.2.2 Allocation View\nThe  deployment  diagram  shown  in  Figure  6.4  presents  an  allocation  view  con-\nsisting of nodes and their relationships.","metadata":{"id":521}}],["8e543f14-fe12-4402-9522-e475cbae09c9",{"pageContent":"statements.\n6.2.2 Allocation View\nThe  deployment  diagram  shown  in  Figure  6.4  presents  an  allocation  view  con-\nsisting of nodes and their relationships.\nwww.EBooksWorld.ir\n6.3 The Design Process 151\nFIGURE 6.4 Existing deployment diagram for the BankStat system (Key: UML)\nThe responsibilities of the elements depicted in the diagram are described in \nthe following table.\nElementResponsibility\nData Source \nServer\nThis server hosts a database that contains the raw data used to \nproduce the bank statements.\nBankStat \nServer\nThis server hosts the main batch process that is responsible for \nretrieving information from the Data Source Server, validating the \ninformation, and sending the information to the Digital Signature \nServer for signing.\nDatabase \nServer\nThis server hosts a database that is used locally by the batch \nprocess in the BankStat Server to hold the state and information \nused in the execution of the batch process.\nDigital \nSignature \nServer","metadata":{"id":522}}],["adff413d-93e2-41c8-b500-24407da63823",{"pageContent":"This server hosts a database that is used locally by the batch \nprocess in the BankStat Server to hold the state and information \nused in the execution of the batch process.\nDigital \nSignature \nServer\nThis server, which is provided by an external entity, is responsible \nreceiving, digitally signing, and returning the bank statements. \nThe server exposes web services that receive and produce XML \ninformation.\n6.3 The Design Process\nWe  now  describe  the  design  process  through  the  different  steps  of  ADD  (as  dis-\ncussed in Section 3.2). As this is not a huge change to the existing system, the ar-\nchitect expects that the design activities will require only a single iteration of ADD.\nwww.EBooksWorld.ir\n152 Chapter 6—Case Study: Banking System\n6.3.1 ADD Step 1: Review Inputs\nThe first step of the ADD method involves reviewing the inputs. They are sum-\nmarized in the following table.\nCategoryDetails\nDesign purposeThis is a brownfield system in a mature domain. The","metadata":{"id":523}}],["eb6a2209-84ed-4c68-a69a-4e44860dd2df",{"pageContent":"The first step of the ADD method involves reviewing the inputs. They are sum-\nmarized in the following table.\nCategoryDetails\nDesign purposeThis is a brownfield system in a mature domain. The \npurpose is to design for the next system release.\nPrimary functional \nrequirements\nThe primary use case for this release is UC-1.\nQuality attribute \nscenarios\nThis extension of the system involves only a few quality \nattribute scenarios, so they are all considered as primary.\nConstraintsSee Section 6.1.3.\nArchitectural concernsSee Section 6.1.4.\nExisting architecture \ndesign\nSince this is brownfield development, an additional input \nis the existing architecture design, which was described in \nthe previous section.\n6.3.2 Iteration 1: Supporting the New Drivers\nThis section presents the results of the activities that are performed in each of the \nsteps of ADD in the single iteration performed in this example.\n6.3.2.1 Step 2: Establish Iteration Goal by Selecting Drivers","metadata":{"id":524}}],["c4529566-9549-458d-a082-efbc5a9a2a77",{"pageContent":"steps of ADD in the single iteration performed in this example.\n6.3.2.1 Step 2: Establish Iteration Goal by Selecting Drivers\nOnly a limited number of drivers need to be addressed, so the architect has de-\ncided that a single iteration is sufficient. The goal of this iteration is to modify the \nexisting design to support all of the new drivers listed in Section 6.1\n6.3.2.2 Step 3: Choose One or More Elements of the System to Refine\nThe  elements  to  refine  include  the  main  modules  from  BankStat  and  the  node  \nwhere  the  system  is  deployed  (BankStat  Server).  In  addition  to  refining  these  \nmodules,  the  physical  node  where  the  application  is  hosted  is  a  candidate  for  \nrefinement.\n6.3.2.3 Step 4: Choose One or More Design Concepts That Satisfy the \nSelected Drivers\nThe  following  table  summarizes  the  design  decisions  made  with  respect  to  the  \nselection of design concepts.\nwww.EBooksWorld.ir\n6.3 The Design Process 153\nDesign Decisions and \nLocationRationale","metadata":{"id":525}}],["ac924b01-a308-4bf0-bd76-89ce9e62a2a6",{"pageContent":"The  following  table  summarizes  the  design  decisions  made  with  respect  to  the  \nselection of design concepts.\nwww.EBooksWorld.ir\n6.3 The Design Process 153\nDesign Decisions and \nLocationRationale\nUse the Web Application \nReference architecture\nThe use cases that are being introduced in the \nsystem require interaction through a web browser \n(CON-4). Since there are no requirements for rich user \ninteraction, the Web Application architecture is selected \n(see Section A.1.1).\nDiscarded alternatives:\n ■\nRich Internet application (see Section A.1.3), as it \nwould require additional development effort and there \nare no requirements for a rich user interface.\nSelect the Spring Security \nframework to manage \nauthorization and \nauthentication\nSecurity is a complex topic, and writing ad hoc code \nto support it is difficult and error prone. The needs for \nthis application include managing authorization and \nauthentication and an activity log. All of these features","metadata":{"id":526}}],["aced63ed-10c0-466a-9812-d4332d668244",{"pageContent":"to support it is difficult and error prone. The needs for \nthis application include managing authorization and \nauthentication and an activity log. All of these features \nare available in the Spring Security framework, which \ncan easily be integrated into the existing user directory \nserver (CON-1) and is Java related (CRN-1).\nDiscarded alternatives:\n ■\nAd hoc code: Challenging, error-prone, takes signifi-\ncant time to develop.\n ■\nOther frameworks: The first release of the solution \nhas already been developed using Spring technolo-\ngies. Hence it makes sense to continue using other \ntechnologies from the Spring platform, as they can be \neasily integrated with the existing frameworks.\nUse the Shared Database \nIntegration pattern \nto obtain information \nabout the state of bank \nstatements\nThe interactive part of the system needs to query the \ndatabase that is used locally by the batch process to \ndisplay the state of bank statement processing. The \nbatch and interactive parts of the system can be seen","metadata":{"id":527}}],["caeb8e5d-7999-4419-aa2e-577b7525d77a",{"pageContent":"database that is used locally by the batch process to \ndisplay the state of bank statement processing. The \nbatch and interactive parts of the system can be seen \nas two different applications (or subsystems) that \nshare data that is contained in the same database. The \nShared Database Integration pattern can be used in \nthis context to support the interaction between these \nsystems. This approach does not require changes to be \nmade in the existing parts of the system (CRN-2).\nDiscarded alternatives:\n ■\nObtaining the information through an API, which \nwould require modifications in the existing modules \nand would have a negative impact on performance.\nDeploy using a three-tier \ndeployment model \nDeploying the web part of the application will be done \nin a separate server. Thus, the deployment of this part \nof the application can be seen as an instance of the \nthree-tier deployment model (see Section A.2.2). The \nbenefit of this approach is that the server that hosts the","metadata":{"id":528}}],["2bf11697-ac1c-41bd-90a5-b6bcc9bd1c34",{"pageContent":"of the application can be seen as an instance of the \nthree-tier deployment model (see Section A.2.2). The \nbenefit of this approach is that the server that hosts the \nbatch process will not have to process the interactive \nrequests, so performance will not be hindered.\nDiscarded alternatives:\n ■\nHosting the application in the same server where \nthe batch process is hosted. This would save some \nserver costs, but could limit performance of either the \nbatch process or the interactive functions.\nwww.EBooksWorld.ir\n154 Chapter 6—Case Study: Banking System\n6.3.2.4 Step 5: Instantiate Architectural Elements, Allocate Responsibilities, \nand Define Interfaces\nThe  instantiated  design  decisions  considered  and  made  are  summarized  in  the  \nfollowing table.\nDesign Decision and LocationRationale\nHost the web application in a separate \nserver\nThis choice avoids performance reduc-\ntions on the batch server and increases \nsecurity (QA-1).\nConfigure Spring Security to use an \nexternal user directory server","metadata":{"id":529}}],["6388f655-e251-44dc-abe3-7a7c2d587c97",{"pageContent":"server\nThis choice avoids performance reduc-\ntions on the batch server and increases \nsecurity (QA-1).\nConfigure Spring Security to use an \nexternal user directory server\nThis is to address CON-1.\nThe results of these instantiation decisions are recorded in the next step.\n6.3.2.5 Step 6: Sketch Views and Record Design Decisions\nThe  deployment  diagram  shown  in  Figure  6.5  depicts  the  new  server  that  will  \nhost the application and the external user directory server, along with their con-\nnections to the existing nodes.\nThe  responsibilities  of  the  newly  introduced  elements  are  described  in  the  \nfollowing table.\nElementResponsibility\nWeb/App ServerHosts the interactive part of the application.\nAuth ServerExisting server that manages users and permissions for multiple \napplications in the bank (CON-1).\nThe package diagram shown in Figure 6.6 illustrates how the reference ar-\nchitecture is instantiated and identifies the modules that are introduced to support","metadata":{"id":530}}],["e85cd9c5-1d33-46af-a96f-352e582ebb0c",{"pageContent":"applications in the bank (CON-1).\nThe package diagram shown in Figure 6.6 illustrates how the reference ar-\nchitecture is instantiated and identifies the modules that are introduced to support \nthe primary use case (UC-1). It also shows how these newly introduced elements \nare  integrated  with  the  existing  layers  and  modules  from  the  previous  system  \nrelease.\nwww.EBooksWorld.ir\n6.3 The Design Process 155\nFIGURE 6.5 Refined deployment diagram (Key: UML)\nFIGURE 6.6 Modules introduced to support the use case UC-1 (Key: UML)\nwww.EBooksWorld.ir\n156 Chapter 6—Case Study: Banking System\nThe  responsibilities  of  the  newly  introduced  elements  are  described  in  the  \nfollowing table.\nElementResponsibility\nBank Statement \nReprocessing View\nThis module displays a view that allows the user to query \nthe state of bank statements that have been processed. It \nalso allows the user to select from these statements the \nones that need to be reprocessed.\nBank Statement \nReprocessing Service","metadata":{"id":531}}],["cd8c9d1a-374b-43d6-8f49-5a029186e056",{"pageContent":"the state of bank statements that have been processed. It \nalso allows the user to select from these statements the \nones that need to be reprocessed.\nBank Statement \nReprocessing Service\nThis module manages requests from the view, which include \nrequesting bank statement information, marking bank \nstatements that need to be reprocessed, and triggering the \nrestart of the batch job.\nSecurity ManagerThis module, which is implemented using Spring Security, \nhandles authentication, authorization, and the activity log \n(QA-1). It is also integrated with the external user directory \nserver (CON-1).\nThe  sequence  diagram  shown  in  Figure  6.7  illustrates  how  UC-1  is  per-\nformed. The user requests the state of bank statements to be displayed. This in-\nformation is retrieved from the local database by the Local Database Connector. \nOnce  displayed,  the  user  selects  the  statements  to  reprocess.  These  bank  state-","metadata":{"id":532}}],["100d6442-e386-47c1-ab48-95f7d7831e7c",{"pageContent":"formation is retrieved from the local database by the Local Database Connector. \nOnce  displayed,  the  user  selects  the  statements  to  reprocess.  These  bank  state-\nments  are  marked  for  reprocessing  (by  changing  a  flag)  and  the  information  is  \nupdated  on  the  local  database.  Finally,  the  batch  job  is  restarted.  Note  that  the  \ninteractions with the system are recorded by Spring Security in the view. In addi-\ntion, the invocation of the Batch Job Coordinator is asynchronous, which avoids \nthe problem of blocking the user interface.\nFrom the interactions identified in the sequence diagram, initial methods for \nthe interfaces of the interacting elements can be identified.\nBankStatementReprocessingService\nMethod NameDescription\nBankStatement [] get BSStatus(criteria)\nRetrieves a collection of bank \nstatements according to diverse \ncriteria, including periods in \ntime or status.\nboolean reprocess(BankStatement [])\nRequests the reprocessing of a \ncollection of bank statements.","metadata":{"id":533}}],["82598701-5a21-4d6d-9ee3-245ce70da165",{"pageContent":"statements according to diverse \ncriteria, including periods in \ntime or status.\nboolean reprocess(BankStatement [])\nRequests the reprocessing of a \ncollection of bank statements.\n6.3.2.6 Step 7: Perform Analysis of Current Design and Review Iteration \nGoal and Achievement of Design Purpose\nThe following Kanban table summarizes the status of the various architectural driv-\ners  and  the  decisions  that  were  made  during  the  iteration  to  address  them.  As  all  \nthe drivers were completely addressed, just a single iteration of ADD was required.\nwww.EBooksWorld.ir\n6.3 The Design Process 157\nFIGURE 6.7\n \nSequence diagram for use case UC-1 (Key: UML)\nwww.EBooksWorld.ir\n158 Chapter 6—Case Study: Banking System\nNot \nAddressed\nPartially \nAddressed \nCompletely\nAddressed\nDesign Decisions Made During the \nIteration\nUC -1Modules that support the use case \nand their interfaces were identified and \ndefined based on the Web Application \nReference architecture.\nQ A-1Security logs are handled by Spring \nSecurity.","metadata":{"id":534}}],["e3d186b0-5e2d-476b-8c62-7c0de56ff883",{"pageContent":"Iteration\nUC -1Modules that support the use case \nand their interfaces were identified and \ndefined based on the Web Application \nReference architecture.\nQ A-1Security logs are handled by Spring \nSecurity.\nCON -1Spring Security connects to the existing \nuser directory server and uses its \ninformation to support authorization and \nauthentication.\nCON-3No changes have been made to the \nmodule that connects to the data \nsource.\nCON-3No changes have been made to the \nmodule that connects to the digital \nsignature provider.\nCON-4The Web Application Reference \narchitecture that was used specifically \nsupports access from web browsers.\nCRN -1The technologies that have been \nselected are Java related.\nCRN-2Integration with the existing functionality \nwas made through the database (using \nthe Database Integration pattern); \nchanges to the existing functionality \nwere not needed.\n6.4    Summary\nIn  this  chapter,  we  presented  a  simple  (but  real-world)  example  of  the  use  of","metadata":{"id":535}}],["d7d10527-67d4-4346-898a-58e60e1f7ca7",{"pageContent":"the Database Integration pattern); \nchanges to the existing functionality \nwere not needed.\n6.4    Summary\nIn  this  chapter,  we  presented  a  simple  (but  real-world)  example  of  the  use  of  \nADD in the context of a brownfield system. As this example illustrates, the steps \nof ADD are followed in exactly the same manner as in the context of the design \nof  greenfield  systems.  The  main  difference  is  that  one  of  the  inputs  of  the  de-\nsign  process  is  the  existing  architecture.  This  highlights  the  importance  of  doc-\numenting  the  architecture:  If  this  information  was  not  present,  a  great  deal  of  \ntime would need to be spent in understanding and reverse-engineering the code to \ncreate an appropriate model of the architecture before proceeding with the design \nand eventual implementation process.\nDesign  in  the  context  of  brownfield  systems  usually  involves  more  ex-","metadata":{"id":536}}],["090b1ea8-4b64-41fa-8e17-8c747f2917f8",{"pageContent":"create an appropriate model of the architecture before proceeding with the design \nand eventual implementation process.\nDesign  in  the  context  of  brownfield  systems  usually  involves  more  ex-\ntensive  changes  than  the  ones  illustrated  by  this  example.  Such  changes  often  \nrequire  refactoring  and  modification  of  the  existing  architecture  to  support  the  \nwww.EBooksWorld.ir\n6.5 Further Reading    159\nintroduction  of  new  elements  and  new  relationships  that  result  from  the  design  \nactivity.  Modifying  an  existing  architecture  is  oftentimes  the  most  challenging  \naspect of designing in the context of brownfield systems. In brownfield systems, \nit is all too common that detailed knowledge of some parts of the system has been \nlost. Because this process can be complex and some uncertainty exists regarding \nthe consequences of changes, we recommend that you perform an analysis of the \nproposed design changes before committing them to code.\n6.5 Further Reading","metadata":{"id":537}}],["dd2cd789-7761-41c2-9efa-a9aea8e9c61b",{"pageContent":"the consequences of changes, we recommend that you perform an analysis of the \nproposed design changes before committing them to code.\n6.5 Further Reading\nThe Shared Database Integration pattern is discussed in G. Hohpe and B. Woolf, \nEnterprise  Integration  Patterns:  Designing,  Building  and  Deploying  Messaging  \nSolutions, Addison Wesley Professional, 2003.\nIn-depth  discussions  of  software  maintenance  and  evolution  can  be  found  \nin  the  classic  book  by  F.  Brooks,  The  Mythical  Man  Month,  Addison-Wesley,  \n1995, and also in M. M. Lehman, “On Understanding Laws, Evolution, and Con-\nservation  in  the  Large-Program  Life  Cycle”,  Journal  of  Systems  and  Software, \n1:213–221, 2010.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n161\n7\nOther Design Methods\nOver the past two decades, a number of architecture design methods have been \nproposed  and  documented.  In  this  chapter  we  briefly  present  some  of  the  most","metadata":{"id":538}}],["b9d9fd46-26d3-480c-b3e5-08f617e0432c",{"pageContent":"161\n7\nOther Design Methods\nOver the past two decades, a number of architecture design methods have been \nproposed  and  documented.  In  this  chapter  we  briefly  present  some  of  the  most  \nwell-known methods, which we then relate and compare to ADD. We begin with \na  “general  model”  of  architecture  design,  then  briefly  present  five  other  design  \nmethods.  We  conclude  the  chapter  with  a  discussion  of  how  ADD  differs  from  \nthese other methods.\n7.1 A General Model of Software Architecture Design\nIn  their  paper  “A  General  Model  of  Software  Architecture  Design  Derived  from  \nFive Industrial Approaches”, Hofmeister and her colleagues compared five indus-\ntrial software architecture design methods and extracted from their commonalities \na  generic  software  architecture  design  approach.  The  five  models  they  reviewed  \nwere ADD 2.0, Siemens 4 views, RUP’s 4+1 Views, Business Architecture Process","metadata":{"id":539}}],["d7938808-9812-4816-8f54-12e38c917c92",{"pageContent":"a  generic  software  architecture  design  approach.  The  five  models  they  reviewed  \nwere ADD 2.0, Siemens 4 views, RUP’s 4+1 Views, Business Architecture Process \nand Organization (BAPO), and Architecture Separation of Concerns (ASC).\nwww.EBooksWorld.ir\n162 Chapter 7—Other Design Methods\nArchitectural\nSynthesis\nArchitecturally\nsignificant\nrequirements\nArchitecturally\nsignificant\nrequirements\nCandidate\narchitectural\nsolutions\nArchitectural\nAnalysis\nArchitectural\nconcerns\nContext\nArchitectural\nEvaluation\nKey: \nActivityData flow\nValidated\narchitecture\nFIGURE 7.1\n \nArchitectural design activities\nwww.EBooksWorld.ir\n7.1 A General Model of Software Architecture Design 163\nThe derived general model, shown in Figure 7.1, consists of three main ac-\ntivities that are present in all five models reviewed:\n§\tArchitectural analysis. In this activity, requirements (called concerns) and \nthe system context are used as inputs to determine a set of architecturally \nsignificant requirements (ASRs).","metadata":{"id":540}}],["676e0d36-59ae-4eee-a61d-209d1215b6e4",{"pageContent":"§\tArchitectural analysis. In this activity, requirements (called concerns) and \nthe system context are used as inputs to determine a set of architecturally \nsignificant requirements (ASRs).\n§\tArchitectural synthesis. This activity is described as being the core of ar-\nchitecture design. It proposes architecture solutions to a set of ASRs, mov-\ning from the problem to the solution space. The results of this activity are \ncandidate architectural solutions, which are partial or complete architecture \ndesigns and include information about the rationale.\n§\tArchitectural evaluation. This activity ensures that the architectural de-\ncisions are the right ones. Candidate architectural solutions are measured \nagainst ASRs. Several evaluations of different architectural solutions are \nexpected, but the eventual result is the validated architecture.\nHofmeister  and  her  colleagues  further  explain  that  these  activities  do  not","metadata":{"id":541}}],["39a01071-1859-4fdc-8d01-71328448e9e2",{"pageContent":"expected, but the eventual result is the validated architecture.\nHofmeister  and  her  colleagues  further  explain  that  these  activities  do  not  \nproceed sequentially, but rather architects proceed in small “leaps” as they move \nfrom  one  activity  to  another.  Progress  is  driven  by  an  implicit  or  explicit  back-\nlog of smaller needs, issues, problems, and ideas that architects need to address \n(Figure 7.2).\nThis  general  model  presented  by  Hofmeister  et  al.  is  not  detailed,  by  in-\ntent, because it abstracts the specific techniques found in other design processes, \nincluding  ADD.  Thus  the  model  can  represent  ADD,  but  also  covers  a  bigger  \nscope  of  architecture  development,  where  architectural  requirements  gathering  \nand analysis are performed using methods such as QAW, architectural synthesis \nis performed using methods such as the ones presented in the paper, and architec-\ntural evaluation is performed using methods such as ATAM.\nServer Side","metadata":{"id":542}}],["07b13c7d-4531-4878-8d4a-1c1362cf36a8",{"pageContent":"is performed using methods such as the ones presented in the paper, and architec-\ntural evaluation is performed using methods such as ATAM.\nServer Side\nClient Side\n«Layer»\nPresentation CS\n«Layer»\nBusiness logic CS\n«Layer»\nData CS\n«Layer»\nServices SS\n«Layer»\nBusiness Logic SS\n«Layer»\nData SS\nNetworkStatusMonitoringView\nNetworkStatusMonitoringController\nRequestManager\n«facade»\nRequestService\nTopologyController\nDomainEntities\nRegionDataMapper\nTimeServerDataMapper\nEventDataMapper\nTimeServerConnector\nTimeServerEventsController\nDataCollectionController\nFIGURE 7.2 Architecture backlog\nwww.EBooksWorld.ir\n164 Chapter 7—Other Design Methods\n7.2 Architecture-Centric Design Method\nThe Architecture-Centric Design Method (ACDM) is a software architecture de-\nvelopment  method  that  covers  the  complete  life  cycle  of  the  architecture.  This  \niterative method consists of 8 stages, as shown in Figure 7.3.\nStage  3  is  focused  on  design;  it  is  where  an  initial  architectural  design  is","metadata":{"id":543}}],["e49e883d-699f-47de-a568-32397a380527",{"pageContent":"iterative method consists of 8 stages, as shown in Figure 7.3.\nStage  3  is  focused  on  design;  it  is  where  an  initial  architectural  design  is  \ncreated  or  refined.  For  new  systems,  the  first  iteration  of  this  process  promotes  \nthe  rapid  creation  of  a  “notional”  or  initial  architecture.  This  iteration  proceeds  \nby first establishing the system context and then performing decomposition in an\nFIGURE 7.3 ACDM stages\nwww.EBooksWorld.ir\n7.3 Architecture Activities in the Rational Unified Process 165\niterative  manner  to  produce  structures.  In  ACDM,  decomposition  is  driven  by  \nquality  attribute  scenarios  and  constraints,  but  functional  requirements  are  also  \nconsidered.  In  subsequent  iterations,  issues  uncovered  in  the  architecture  re-\nview  (Stage  4)  also  serve  as  inputs.  ACDM  suggests  using  patterns  to  support  \ndecomposition and using more than one perspective (static, dynamic) during the","metadata":{"id":544}}],["40acc388-1723-4d8e-86ef-28e70e2ba063",{"pageContent":"view  (Stage  4)  also  serve  as  inputs.  ACDM  suggests  using  patterns  to  support  \ndecomposition and using more than one perspective (static, dynamic) during the \nprocess. After decomposition occurs, responsibilities are associated with the ele-\nments and interfaces are defined.\nACDM has a broader scope than ADD, as it encompasses the whole archi-\ntecture  development  life  cycle  (requirements,  design,  evaluation,  and  documen-\ntation)  in  its  8  stages.  Stage  3  of  ACDM  is  the  equivalent  of  ADD.  However,  \nACDM provides less detailed guidance than ADD on how to perform this crucial \nstep. ADD and ACDM can be used together, however. To do so, you can simply \nuse ADD directly in stage 3 of ACDM.\n7.3 Architecture Activities in the Rational Unified \nProcess\nThe Rational  Unified  Process  (RUP)  has  been  a  popular  software  development  \nprocess framework for more than a decade. The framework is extensive and the","metadata":{"id":545}}],["8ebcf4bc-a683-4226-8d8a-ca3ad1945877",{"pageContent":"Process\nThe Rational  Unified  Process  (RUP)  has  been  a  popular  software  development  \nprocess framework for more than a decade. The framework is extensive and the \nversion  we  reviewed  (7.0.1)  provides  two  flavors:  one  for  large  projects  (used  \nhere  for  discussion)  and  one  for  small  projects.  Every  project  in  RUP  is  devel-\noped iteratively and iterations are performed across four sequential phases:\n§\tInception. In this phase, the project is conceived and feasibility is evaluated.\n§\tElaboration. In this phase, many aspects that are necessary to successfully \nperform the project are handled. One of these aspects is the design of the \narchitecture.\n§\tConstruction. In this phase, the system is built iteratively.\n§\tTransition. In this phase, the completed system is transitioned from the de-\nvelopment environment to the end-user environment.\nFor  RUP,  architecture  is  a  fundamental  aspect  of  system  creation,  and  ac-","metadata":{"id":546}}],["8ef24568-ee32-4c1a-9306-af2fdded3ca1",{"pageContent":"velopment environment to the end-user environment.\nFor  RUP,  architecture  is  a  fundamental  aspect  of  system  creation,  and  ac-\ntivities are associated with it across the different phases and, in particular, in the \ninception and elaboration phases. In the inception phase, RUP defines an activity \ncalled “perform architectural synthesis”, whose goal is to construct and assess an \narchitectural proof-of-concept  to  demonstrate  the  feasibility  of  the  system.  This  \nactivity includes tasks such as defining a system context, performing architectural \nanalysis (which actually refers to defining a candidate architecture), constructing \nan architectural proof-of-concept (a prototype), and evaluating the viability of the \nproof-of-concept.\nThe  elaboration  phase  includes  two  activities  associated  with  software  \narchitecture:\nwww.EBooksWorld.ir\n166 Chapter 7—Other Design Methods\n§\tDefine a candidate architecture. In this activity, an initial sketch of the soft-","metadata":{"id":547}}],["862eb382-4e6b-41f7-bd35-ec728936bac0",{"pageContent":"architecture:\nwww.EBooksWorld.ir\n166 Chapter 7—Other Design Methods\n§\tDefine a candidate architecture. In this activity, an initial sketch of the soft-\nware architecture is created. This includes defining architecturally signifi-\ncant elements, identifying a set of analysis mechanisms, defining the initial \nlayering and organization of the system, and defining use-case realizations \nfor the current iteration. The key tasks are performing architectural analysis \nand use case analysis; other tasks include operation analysis and identifying \nsecurity patterns.\n§\tRefine the architecture. This activity is focused on completing the architec-\nture for an iteration. It involves making a transition from analysis activities \nto design activities by identifying design elements from analysis elements \nand design mechanisms from analysis mechanisms. In addition, the runtime \nand deployment architecture is described, along with an implementation","metadata":{"id":548}}],["f8e0727d-5d83-4185-9385-a62c9f102558",{"pageContent":"and design mechanisms from analysis mechanisms. In addition, the runtime \nand deployment architecture is described, along with an implementation \nmodel to facilitate the transition between design and implementation. To \nachieve this, the RUP suggests performing tasks such as identifying design \nmechanisms, identifying design elements, performing operation analysis, \nincorporating existing design elements, structuring the implementation \nmodel and describing the runtime architecture, describing distribution, and \nreviewing the architecture.\nRUP provides an extensive, detailed process for architectural development. \nIt also makes clear distinctions between analysis, design, and implementation as-\npects. Initially, the architecture is designed in a conceptual fashion in the analysis \ntasks,  and  then  it  is  made  concrete  in  the  design  and  implementation  tasks.  For  \nexample,  initially  an  analysis  mechanism  such  as  persistence  can  be  identified.","metadata":{"id":549}}],["a6db37a8-d3fc-42ab-82b7-6cb36f360e09",{"pageContent":"tasks,  and  then  it  is  made  concrete  in  the  design  and  implementation  tasks.  For  \nexample,  initially  an  analysis  mechanism  such  as  persistence  can  be  identified.  \nThis is refined into a design mechanism such as a DBMS, which is further refined \ninto an implementation mechanism such as a specific Oracle or MySQL database.\nThe  process  in  RUP  is  iterative  by  nature,  as  several  iterations  of  the  ar-\nchitectural activities defined in the inception and elaboration phases can be per-\nformed. A nice aspect of the process defined by RUP is that it provides detailed \nguidance with respect to architectural concerns such as defining the system con-\ntext  and  establishing  an  initial  structure  for  the  system  both  in  a  logical  and  a  \nphysical  way.  The  architecture  process  in  RUP  also  has  a  strong  focus  on  use  \ncases. Even though quality attributes are mentioned (as “supplementary require-","metadata":{"id":550}}],["6004ccac-9305-4bc1-81e2-3e789df40d29",{"pageContent":"physical  way.  The  architecture  process  in  RUP  also  has  a  strong  focus  on  use  \ncases. Even though quality attributes are mentioned (as “supplementary require-\nments”),  they  do  not  drive  the  architecture  design  process  as  much  as  the  use  \ncases. Also, this process explicitly considers the creation of an executable archi-\ntectural prototype.\nEven though the architecture process in RUP is comprehensive, it does not \ngive as much detail as ADD in terms of the concrete steps to perform the design. \nIn this sense, ADD and RUP can be seen as being complementary methods, and \nADD can be integrated into RUP (as can other more detailed architecture-based \nmethods such as the QAW, ATAM, and CBAM).\nwww.EBooksWorld.ir\n7.4 The Process of Software Architecting 167\n7.4 The Process of Software Architecting\nIn the book The Process of Software Architecting, Peter Eeles and Peter Cripps, \nwho  are  architects  at  IBM,  describe  how  they  approach  architecture.  Their  pro-","metadata":{"id":551}}],["acad10fe-bba5-4a30-b893-8f6f6a59c82f",{"pageContent":"In the book The Process of Software Architecting, Peter Eeles and Peter Cripps, \nwho  are  architects  at  IBM,  describe  how  they  approach  architecture.  Their  pro-\ncess covers the entire architecture life cycle and is independent of any software \ndevelopment methodology, but the book makes several references to its use with \nRU P.\nThe process described by Eeles and Cripps includes three major activities: \n“define  requirements”,  “create  logical  architecture”,  and  “create  physical  archi-\ntecture”. The last two are the activities where architectural design is performed. \nAccording to the authors, the logical architecture is “a stepping stone in getting \nfrom the requirements to the solution—a first step that considers the architecture \nin a largely technology-independent manner. A physical architecture, on the other \nhand, is more specific—and takes technology into account”. The creation of the","metadata":{"id":552}}],["047885bc-666a-40a3-a002-1d99272f0ee9",{"pageContent":"in a largely technology-independent manner. A physical architecture, on the other \nhand, is more specific—and takes technology into account”. The creation of the \nlogical  architecture  and  the  physical  architecture  comprises  the  same  tasks  (see  \nFigure 7.4), but in the creation of the physical architecture the focus, not surpris-\ningly, is on its physical aspects.\nFIGURE 7.4 Tasks in the “create logical architecture” and “create physical \narchitecture” activities\nwww.EBooksWorld.ir\n168 Chapter 7—Other Design Methods\nThis  process  acknowledges  the  existence  of  different  types  of  architects:  \nlead, application, infrastructure, and data architects. Also, it makes a distinction \nbetween  “outlining”  tasks,  which  are  associated  with  the  most  important  archi-\ntectural elements and are the responsibility of the lead architect, and “detailing” \ntasks, which are focused on less significant elements and are the responsibility of","metadata":{"id":553}}],["8c69ec34-4d0a-4bec-8ad8-01322923bf3c",{"pageContent":"tectural elements and are the responsibility of the lead architect, and “detailing” \ntasks, which are focused on less significant elements and are the responsibility of \nthe other architects, depending on the task. For example, whereas outlining tasks \ndeal  with  subsystems  and  components,  detailing  tasks  deal  with  interfaces  and  \noperation signatures.\nThe  method  described  by  Eeles  and  Cripps  also  emphasizes  two  different  \nmodels:  (1)  the  functional  model,  which  is  composed  of  components  with  re-\nsponsibilities  and  relationships  and  their  collaborations  to  deliver  the  required  \nfunctionality,  and  (2)  the  deployment  model,  which  shows  the  configuration  of  \nnodes,  communication  links  between  them,  and  the  components  that  are  de-\nployed on the nodes. Both functional and quality attribute requirements influence \nthe functional and deployment models. The authors mention that they adopt the","metadata":{"id":554}}],["68f0a7f9-96bd-4302-a5b5-6d1b3f013d4b",{"pageContent":"ployed on the nodes. Both functional and quality attribute requirements influence \nthe functional and deployment models. The authors mention that they adopt the \n“systems engineering philosophy” of treating software and hardware as peers that \ncollaborate to achieve system qualities.\nThe following list summarizes the purposes of the tasks in the create logical \nand  physical  architecture  activities  that  are  related  to  design.  The  role  that  has  \nprimary  responsibility  for  the  task  appears  in  parentheses,  while  other  types  of  \narchitects may take a secondary role:\n§\tSurvey architecture assets (lead architect). Identify reusable architecture \nassets that can be applied to the system under development.\n§\tDefine architecture overview (lead architect). Identify and describe the \nmajor elements of the system under development from a functional and de-\nployment perspective.\n§\tDocument architecture decisions (lead architect). Capture key decisions","metadata":{"id":555}}],["c21512da-6d0a-416d-b3a5-d8d9201311ba",{"pageContent":"major elements of the system under development from a functional and de-\nployment perspective.\n§\tDocument architecture decisions (lead architect). Capture key decisions \nmade in shaping the architecture and the rationale behind them. This step \nincludes assessing options and selecting a preferred option.\n§\tOutline functional elements (application architect). Identify the major function-\nal elements (subsystems and components) of the system under development.\n§\tOutline deployment elements (infrastructure architect). Identify the lo-\ncations to which the system under development will be deployed and the \nnodes within each location.\n§\tVerify architecture (lead architect). Verify that the architecture work prod-\nucts are consistent and ensure that any concerns that cut across the architec-\nture work products have been addressed consistently.\n§\tBuild architecture proof-of-concept (lead architect). Synthesize at least one \nsolution (which can be conceptual) that satisfies the architecturally signifi-","metadata":{"id":556}}],["f7bd1b05-8a08-4242-8cd6-2f7cca951d7b",{"pageContent":"§\tBuild architecture proof-of-concept (lead architect). Synthesize at least one \nsolution (which can be conceptual) that satisfies the architecturally signifi-\ncant requirements to determine whether such a solution, as envisaged by the \narchitects, exists.\n§\tDetail functional elements (application architect). Refine the functional \nelements to the point that they can be handed off to detailed design. This \nwww.EBooksWorld.ir\n7.5 A Technique for Architecture and Design 169\nincludes defining component interfaces in a detailed way (e.g., operation \nsignatures, pre and post conditions) using sequence diagrams.\n§\tDetail deployment elements (infrastructure architect). Refine the deploy-\nment elements to the point they can be handed off to detailed design. This \nincludes assigning components to nodes and defining connections between \nnodes and locations.\nIn a spirit that is similar to RUP, the Process of Software Architecting is a","metadata":{"id":557}}],["0b911052-477e-4a0a-9291-ba127a9d1f52",{"pageContent":"includes assigning components to nodes and defining connections between \nnodes and locations.\nIn a spirit that is similar to RUP, the Process of Software Architecting is a \nframework,  and  it  needs  to  be  adjusted  according  to  the  type  of  project  that  is  \nbeing  tackled.  For  instance,  the  amount  of  logical  architecture  that  needs  to  be  \nestablished can vary; indeed, in some cases, no logical architecture may be cre-\nated if the system being designed is similar to existing ones. Also, the elaboration \nphase  emphasizes  the  logical  architecture,  whereas  the  construction  phase  em-\nphasizes the physical architecture. Finally, the logical and physical architectures \nneed  not  be  created  sequentially  and  the  process  acknowledges  that  some  tech-\nnology choices may be made early.\nThe  Process  of  Software  Architecting  is  a  comprehensive  framework,  and  \nthis book provides a detailed example of how to execute the different tasks. The","metadata":{"id":558}}],["83764dde-6a65-4932-ab48-891e195f6fc7",{"pageContent":"nology choices may be made early.\nThe  Process  of  Software  Architecting  is  a  comprehensive  framework,  and  \nthis book provides a detailed example of how to execute the different tasks. The \ntasks related to creating the logical/physical architecture are similar to the steps of \nADD combined with the roadmap discussed in Section 3.3. The Process of Soft-\nware Architecting, however, puts less emphasis on guiding iterations by specific \nscenarios and provides less guidance on how to actually make design decisions.\n7.5 A Technique for Architecture and Design\nIn the book Application Architecture Guide, second edition, Microsoft proposes a \ntechnique for sketching an architecture. This technique consists of five steps that \nare performed iteratively (Figure 7.5):\n1. Identify architecture objectives. These goals and constraints shape the design \nprocess, provide scope, and help determine when you are finished. Examples \ninclude building a prototype, exploring technologies, and developing an ar-","metadata":{"id":559}}],["04735f8c-0fd2-45dd-a75e-a2ecf3f0e55f",{"pageContent":"process, provide scope, and help determine when you are finished. Examples \ninclude building a prototype, exploring technologies, and developing an ar-\nchitecture. Also, at this point, the consumers for the architecture are identified \nand the scope, time, and resources that will be dedicated to design activities \nare established.\n2. Identify key scenarios. Key scenarios represent issues, architecturally signif-\nicant use cases, intersections between quality attributes and functionality, or \ntradeoffs between quality attributes.\n3. Create application overview. This step refers to creating an overview of what \nthe application will look like when it is complete. At the end of this step, \nthe process suggests “whiteboarding” the architecture—that is, creating an \nwww.EBooksWorld.ir\n170 Chapter 7—Other Design Methods\ninformal representation of the architecture. This step is divided into the fol-\nlowing set of activities:\na. Determining application type: involves the selection of a reference","metadata":{"id":560}}],["198e31a6-e34e-414b-a914-ec95789767da",{"pageContent":"informal representation of the architecture. This step is divided into the fol-\nlowing set of activities:\na. Determining application type: involves the selection of a reference \narchitecture.\nb. Identifying deployment constraints: involves the selection of a \ndeployment topology.\nc. Identifying important architecture design styles.\nd. Determining relevant technologies: based on the application type and \nconstraints.\n4. Identify key issues. Key issues are grouped into quality attributes and cross-\ncutting concerns. Crosscutting concerns are features of the design that may \napply across all layers, components, and tiers, such as the following:\na. Authentication and authorization\nb.  Caching\nc.  Communication\nd. Configuration management (information that must be configurable)\ne. Exception management\nf. Logging and instrumentation\ng. Validation (of input data)\n5. Define candidate solutions. Candidate architectures include an application","metadata":{"id":561}}],["c4ea985e-f8b0-4277-b106-8726a7fe3caf",{"pageContent":"e. Exception management\nf. Logging and instrumentation\ng. Validation (of input data)\n5. Define candidate solutions. Candidate architectures include an application \ntype, deployment architecture, architectural style, technology choices, quality \nattributes, and crosscutting concerns. If a candidate architecture satisfies the \nrequirements and issues, then it becomes a baseline architecture and is refined \nin further iterations.\nFIGURE 7.5 Iterative steps of the technique for architecture and design\nwww.EBooksWorld.ir\n7.6 Viewpoints and Perspectives Method 171\nBesides  these  five  main  steps,  the  technique  discussed  by  the  Microsoft  \nteam suggests performing reviews of the architecture and representing and com-\nmunicating the design. This technique is independent of a particular development \nprocess  and  there  is  only  a  suggestion  that,  when  using  an  Agile  process,  itera-\ntions should combine architecture and development activities.","metadata":{"id":562}}],["d605db9c-435d-4c6a-99c6-7a3545b1e155",{"pageContent":"process  and  there  is  only  a  suggestion  that,  when  using  an  Agile  process,  itera-\ntions should combine architecture and development activities.\nThe technique presented by the Microsoft team is not very detailed, but the \ndiscussion of this technique is only a small part of Microsoft’s book. The rest of \nthe book provides pragmatic and detailed information on the considerations that \nmust  be  taken  into  account  for  different  types  of  applications,  including  web,  \nrich client, rich internet, and mobile applications, among others. For example, the \nbook devotes a chapter to the specific aspects of the design of the business layer. \nAlthough  much  of  the  information  is  technology  agnostic,  Microsoft  has  also  \ndone  an  excellent  job  of  showing  how  its  own  technologies  can  be  used  in  this  \nprocess.  In  addition,  the  book  provides  an  extensive  discussion  of  the  concerns  \nthat must be addressed for a series of reference architectures.","metadata":{"id":563}}],["3a3787bd-0414-4621-b525-a8c7f0841f9b",{"pageContent":"process.  In  addition,  the  book  provides  an  extensive  discussion  of  the  concerns  \nthat must be addressed for a series of reference architectures.\nThis  technique  is  similar  in  purpose  to  ADD  but  less  detailed  in  terms  of  \nhow to perform the actual design steps. ADD can be used as an alternative, but \nit is a good idea to keep Microsoft’s book on hand to identify the many specific \narchitectural concerns that you will need to address during design and to leverage \nall of the practical advice that is provided, particularly if you are designing one \nof the types of applications discussed in the book. The ideas presented in Micro-\nsoft’s book inspired us when creating several aspects of this book.\n7.6 Viewpoints and Perspectives Method\nThe viewpoints and perspectives method is described in the book Software Sys-\ntems  Architecture:  Working  with  Stakeholders  Using  Viewpoints  and  Perspec-","metadata":{"id":564}}],["edbeba25-72d1-49a2-b027-a4da90bbdf77",{"pageContent":"7.6 Viewpoints and Perspectives Method\nThe viewpoints and perspectives method is described in the book Software Sys-\ntems  Architecture:  Working  with  Stakeholders  Using  Viewpoints  and  Perspec-\ntives,  by  Nick  Rozanski  and  Eoin  Woods.  Two  critical  concepts,  highlighted  in  \nthe  book  title,  are  viewpoints  and  perspectives,  which  the  authors  define  in  the  \nfollowing way:\n§\tA viewpoint is a collection of patterns, templates, and conventions for con-\nstructing one type of view. It defines the stakeholders whose concerns are \nreflected in the viewpoint and the guidelines, principles, and template mod-\nels for constructing its views. The viewpoints defined include functional, \ninformation, concurrency, development, deployment, and operational.\n§\tAn architectural perspective is a collection of activities, tactics, and guide-\nlines that are used to ensure a system exhibits a set of quality properties that","metadata":{"id":565}}],["ea3f7404-d5a5-491b-acc3-af9a78a6f5a2",{"pageContent":"§\tAn architectural perspective is a collection of activities, tactics, and guide-\nlines that are used to ensure a system exhibits a set of quality properties that \nmust be considered across the system’s architectural views. The primary \nperspectives that are covered in Rozanski and Woods’s book are security, \nperformance and scalability, availability and resilience, and evolution.\nwww.EBooksWorld.ir\n172 Chapter 7—Other Design Methods\nPerspectives  are  orthogonal  to  viewpoints  because  a  particular  perspective  \ncan be applied across different viewpoints. For example, the security perspective \ninvolves aspects from the functional, information and operational viewpoints.\nThe  architecture  is  established  in  the  architecture  definition  process  illus-\ntrated in Figure 7.6. The steps in this process are outlined here:\n1. Consolidate the inputs. Understand, validate, and refine the initial inputs.\n2. Identify the scenarios. Identify a set of scenarios that illustrate the system’s","metadata":{"id":566}}],["86a62a99-12ee-42c9-9938-fdea608fc45c",{"pageContent":"1. Consolidate the inputs. Understand, validate, and refine the initial inputs.\n2. Identify the scenarios. Identify a set of scenarios that illustrate the system’s \nmost important requirements.\n3. Identify relevant architectural styles. Identify one or more proven architec-\ntural styles that could be used as a basis for the overall organization of the \nsystem.\n4. Produce a candidate architecture. Create a first-cut architecture for the sys-\ntem that reflects its primary concerns (requirements and goals) and that can \nact as a basis for further architectural evaluation and refinement.\n5. Explore architectural options. Explore various architectural possibilities for \nthe system and make the key decisions to choose among them.\n6. Evaluate the architecture with stakeholders. Work through an evaluation of \nthe architecture with your key stakeholders, capture any problems or deficien-\ncies, and gain the stakeholders’ acceptance of the architecture.\n7. Two steps are performed in parallel at this point:","metadata":{"id":567}}],["c3a94020-b9ae-4a5c-99f9-eb1927be5c19",{"pageContent":"the architecture with your key stakeholders, capture any problems or deficien-\ncies, and gain the stakeholders’ acceptance of the architecture.\n7. Two steps are performed in parallel at this point:\nA. Rework the architecture. Address any concerns that have emerged during \nthe evaluation task.\nB. Revisit the requirements. Consider any changes to the system’s original re-\nquirements that may have to be made in light of architectural evaluations.\nThis  method  suggests  the  creation  of  a  candidate  architecture  that  is  ob-\ntained from—or at least based on—architectural styles. This candidate architec-\nture is further refined through a series of iterations until it is deemed acceptable \nafter an evaluation is performed.\nIn comparison with ADD, this method does not provide step-by-step guid-\nance on how to perform steps 4 and 5. One benefit of this approach, however, is \nthat the six viewpoints it defines can be related to general architectural concerns","metadata":{"id":568}}],["a9d0c236-f5d1-4c14-9fc9-c25e130fd160",{"pageContent":"ance on how to perform steps 4 and 5. One benefit of this approach, however, is \nthat the six viewpoints it defines can be related to general architectural concerns \nin  our  approach.  Furthermore,  tactics  and  perspectives  are  related,  and  the  idea  \nof applying perspectives across the different viewpoints is valuable and may be \na complement to a scenario-based approach. For example, if you have only one \nsecurity  scenario  in  your  drivers  list,  you  may  consider  only  elements  that  sup-\nport this particular scenario. Thinking of a security perspective, however, may be \nuseful in making design decisions concerning security, which may not be directly \nrelated to the particular scenario but flow across different areas of concern such \nas deployment or operation.\nwww.EBooksWorld.ir\n7.7    Summary 173\nFIGURE 7.6 Viewpoints and perspectives method steps\n7.7    Summary\nIn  this  chapter,  we  reviewed  a  number  of  design  methods  and  compared  them  to","metadata":{"id":569}}],["e879589d-9e0a-4fff-90b6-14bb451a20d6",{"pageContent":"www.EBooksWorld.ir\n7.7    Summary 173\nFIGURE 7.6 Viewpoints and perspectives method steps\n7.7    Summary\nIn  this  chapter,  we  reviewed  a  number  of  design  methods  and  compared  them  to  \nADD.  As  you  can  see,  there  are  several  methods  to  choose  from.  So  why  should  \nyou use ADD instead of, or in addition to, these alternatives? Quite simply, ADD \nis more concrete and specific in its steps and guidance for accomplishing the archi-\ntecture design activity. Having read this far, you should now be convinced of that.\nADD is focused specifically on design and, as such, provides more detailed \nguidance to an (aspiring) architect. This is not a weakness of ADD. Many other \nmethods  can  guide  you  in  the  other  phases  of  the  architecture  life  cycle,  such  \nas  QAW  for  eliciting  and  prioritizing  architectural  requirements,  ATAM  for  \nwww.EBooksWorld.ir\n174 Chapter 7—Other Design Methods\nanalyzing an architecture, the Views and Beyond technique for documenting an","metadata":{"id":570}}],["499c6deb-9cb2-4245-b69e-a51693209a1c",{"pageContent":"www.EBooksWorld.ir\n174 Chapter 7—Other Design Methods\nanalyzing an architecture, the Views and Beyond technique for documenting an \narchitecture. In several parts of this book we have discussed how such methods \ncan be seamlessly integrated into ADD.\nIn the interest of full disclosure, ADD 3.0 borrows from, benefits from, and \nowes a debt of gratitude to all of the approaches described in this chapter.\n7.8 Further Reading\nThe  architecture  design  methods  discussed  in  this  chapter  can  be  found  in  the  \nfollowing sources:\n§\tP. Eeles, P. Cripps. The Process of Software Architecting. Addison-Wesley \nProfessional, 2009.\n§\tC. Hofmeister, P. Kruchten, R. Nord, H. Obbink, A. Ran, P. America. “A \nGeneral Model of Software Architecture Design Derived from Five Indus-\ntrial Approaches”, Journal of Systems and Software, 80:106–126, 2007.\n§\tA. Lattanze. Architecting Software Intensive Systems: A Practitioner’s \nGuide. CRC Press, 2009.","metadata":{"id":571}}],["8415ee65-5cec-47ea-8819-7e438f5d0262",{"pageContent":"trial Approaches”, Journal of Systems and Software, 80:106–126, 2007.\n§\tA. Lattanze. Architecting Software Intensive Systems: A Practitioner’s \nGuide. CRC Press, 2009.\n§\tP. Kruchten. The Rational Unified Process: An Introduction, 3rd ed., \nAddison-Wesley, 2003.\n§\tMicrosoft, Application Architecture Guide, 2nd ed. Microsoft Press, 2009.\n§\tN. Rozanski, E. Woods. Software Systems Architecture. Addison Wesley, \n2005.\nwww.EBooksWorld.ir\n175\n8\nAnalysis in the Design \nProcess\nWhile this is a book focused on architectural design, we have always believed that \ndesign and analysis are two sides of the same coin. Design is the process of mak-\ning decisions; analysis is the process of understanding those decisions, so that the \ndesign may be evaluated. To reflect this intimate relationship, we now turn our at-\ntention to why, when, and how to analyze architectural decisions during the design \nprocess. We look at various techniques for analysis, discuss when they can be done, \nand explore their costs and benefits.","metadata":{"id":572}}],["c0c935b1-c2b3-4811-9b82-d6d8e1bc4265",{"pageContent":"process. We look at various techniques for analysis, discuss when they can be done, \nand explore their costs and benefits.\n8.1 Analysis and Design\nAnalysis is the process of breaking a complex entity into its constituent parts as \na means of understanding it. The opposite of analysis is synthesis. Analysis and \ndesign are therefore intertwined activities. During the design process, the activity \nof analysis can refer to several aspects:\n§\tStudying the inputs to the design process to understand the problem whose \nsolution you are about to design. This includes giving priority to the drivers \nas discussed in Section 3.2.2. This type of analysis is performed in steps 1 \nand 2 of ADD.\n§\tStudying the alternative design concepts that you identified to solve a de-\nsign problem so as to select the most appropriate one. In this situation, \nwww.EBooksWorld.ir\n176 Chapter 8—Analysis in the Design Process\nanalysis forces you to provide concrete evidence for your choices. This ac-","metadata":{"id":573}}],["926de036-ec10-4ca3-b29c-60cde32098d7",{"pageContent":"www.EBooksWorld.ir\n176 Chapter 8—Analysis in the Design Process\nanalysis forces you to provide concrete evidence for your choices. This ac-\ntivity is performed in step 4 of ADD and was discussed in Section 3.2.4.\n§\tEnsuring the decisions made during the design process (or an iteration) are \nappropriate. This is the type of analysis that you perform in step 7 of ADD.\nThe  decisions  that  you  make  when  designing  the  architecture  are  not  only  \ncritical  to  achieve  the  quality  attribute  responses,  but  frequently  the  cost  asso-\nciated with correcting them at a later time can be significant, as these decisions \nmay affect many parts of the system. For these reasons, it is necessary to perform \nanalysis during  the  design  process,  so  that  problems  can  be  identified,  possibly  \nquantified, and corrected quickly. Remember, being too confident and following \nyour gut instincts may not be the best idea (see the sidebar “‘I believe’ Isn’t Good","metadata":{"id":574}}],["bf80910d-0cfa-415a-be45-d8c856d7f14d",{"pageContent":"quantified, and corrected quickly. Remember, being too confident and following \nyour gut instincts may not be the best idea (see the sidebar “‘I believe’ Isn’t Good \nEnough”). Fortunately, if you have followed the recommendations that we have \ngiven up to this point, you should be able to conduct analysis either by yourself \nor with the help of peers by using the preliminary sketches and views that have \nbeen produced as you perform the design process.\n“I Believe” Isn’t Good Enough\nEven if you are following a systematic approach to designing your \narchitecture and using design concepts from well-established sources, \nand even if you have nice-looking diagrams that represent your structures, \nnothing really guarantees that the decisions you are making will actually \nsatisfy a particular quality attribute scenario. Certain quality attributes are \ncritical to the success of your system; particularly for these decisions, the \nrationale of “I believe” is not good enough. Studies of practicing software","metadata":{"id":575}}],["951cbaf9-acb1-4a43-8a57-cb16ff124de6",{"pageContent":"critical to the success of your system; particularly for these decisions, the \nrationale of “I believe” is not good enough. Studies of practicing software \narchitects have shown that most follow an “adequacy” approach to making \ndesign decisions—that is, they adopt the first decision that appears to \nmeet their needs. All too often, they have no rationale to substantiate \nthose decisions other than their gut instincts, their beliefs, based on their \n(inevitably limited) experience. Thus important decisions are frequently \nmade after insufficient reasoning, which can add risk to a system.\nFor drivers that are critical to your system, you owe it to yourself and to \nyour organization to perform a more detailed analysis rather than just trust-\ning your gut instinct, relying on analogy and history, or performing a couple \nof superficial tests to ensure that your drivers are satisfied. The following \noptions will deepen your analysis and hence support your rationale for the \ndecisions made:","metadata":{"id":576}}],["fb7a1d0b-3df3-4b35-9d78-f9b2d2d133f0",{"pageContent":"of superficial tests to ensure that your drivers are satisfied. The following \noptions will deepen your analysis and hence support your rationale for the \ndecisions made:\n§\tAnalytic models. These well-established mathematical models allow you \nto study quality attributes such as performance or availability. They include \nMarkov and statistical models for availability, and queuing and real-time \nscheduling theory for performance. Analytic models—particularly those that \naddress performance—are highly mature but may require considerable ed-\nucation and training to be used adequately.\nwww.EBooksWorld.ir\n8.1 Analysis and Design 177\n§\tChecklists. Checklists are useful tools that allow you to ensure in a systematic \nway that certain decisions that need to be taken into account are not forgotten. \nChecklists are available for particular quality attributes in the public domain—\nfor example, the OWASP checklist guides you in performing black box security","metadata":{"id":577}}],["ba90ef63-2df2-4881-9497-e73b1260c403",{"pageContent":"Checklists are available for particular quality attributes in the public domain—\nfor example, the OWASP checklist guides you in performing black box security \ntesting of web applications. Also, your organization may develop proprietary \nchecklists that are specific to the application domains that you are develop-\ning. Tactics-based questionnaires, which we will discuss shortly, are a type of \nchecklist for the most important quality attributes, based on the use of tactics.\n§\tThought experiments, reflective questions, and back-of-the-envelope analy-\nses. Thought experiments are informal analyses performed by a small group \nof designers in which important scenarios are studied to identify potential \nproblems. For example, you might use a sequence diagram produced inside \nstep 5 of ADD and perform a walk-through of the interaction of the objects \nthat support the scenario modeled in the diagram with a colleague. Reflective \nquestions (discussed in depth in Section 8.5) are questions that challenge","metadata":{"id":578}}],["f761dcbb-540a-4e17-9ff6-9e8f5311aad9",{"pageContent":"that support the scenario modeled in the diagram with a colleague. Reflective \nquestions (discussed in depth in Section 8.5) are questions that challenge \nthe assumptions included in the decision-making process. Back-of-the-enve-\nlope analyses are rough calculations that are less precise than analytic mod-\nels, but can be performed quickly. These calculations, which are frequently \nbased on analogies to other similar systems or on prior experience, are \nuseful to obtain ballpark estimates for desired quality attribute responses. For \nexample, by summing the latencies of a number of processes in a pipeline, \nyou can derive a crude estimate of the end-to-end latency.\n§\tPrototypes, simulations, and experiments. Purely conceptual techniques \nfor analyzing a design are sometimes inadequate to accurately understand \nwhether certain design decisions are appropriate, or whether you should \nfavor one particular technology over another. In such situations, the creation","metadata":{"id":579}}],["a2a72dd8-95f7-47ac-9a94-af7a497ff7e2",{"pageContent":"whether certain design decisions are appropriate, or whether you should \nfavor one particular technology over another. In such situations, the creation \nof prototypes, simulations, or experiments can be an invaluable option to \nobtain a better understanding. For example, in the back-of-the-envelope es-\ntimate of latency described previously, you may not have taken into account \nthat several of the processes are sharing (and hence competing for) the \nsame resources; thus we cannot simply sum their individual latencies and \nexpect to get accurate results. Prototypes and simulations provide a deeper \nunderstanding of system dynamics, but may require a significant effort that \nneeds to be considered in the project plan.\nAs always, none of these techniques is inherently better than the others. \nThought experiments and back-of-the-envelope calculations are inexpen-\nsive and can be done early in the design process, but their validity may be","metadata":{"id":580}}],["34dcf05a-43f2-4ca9-b610-3edd405c1a62",{"pageContent":"Thought experiments and back-of-the-envelope calculations are inexpen-\nsive and can be done early in the design process, but their validity may be \nquestionable. Prototypes, simulations, and experiments typically produce \nmuch higher-fidelity results, but at a far greater cost. The choice of which \ntechnique to employ depends on the context, the risk involved, and the \npriorities of your quality attributes.\nEven so, applying any of these techniques will be helpful in going from \n“I believe” (that my design is appropriate) to an approach that is backed by \ndocumented evidence and argumentation. \nwww.EBooksWorld.ir\n178 Chapter 8—Analysis in the Design Process\n8.2 Why Analyze?\nAnalysis  and  design  are  two  sides  of  the  same  coin.  Design  is  (the  process  of)  \nmaking decisions. Analysis is (the process of) understanding the consequences—\nin  terms  of  cost,  schedule,  and  quality—of  those  decisions.  No  sensible  archi-","metadata":{"id":581}}],["33e1f48a-d7c4-4c2a-acf8-4afc9eee3253",{"pageContent":"making decisions. Analysis is (the process of) understanding the consequences—\nin  terms  of  cost,  schedule,  and  quality—of  those  decisions.  No  sensible  archi-\ntect  would  make  any  decision,  or  at  least  any  nontrivial  decision,  without  first  \nattempting  to  understand  the  implications  of  that  decision:  its  near-term  effects  \nand possibly its long-term consequences. Architects, of course, make thousands \nof decisions in the course of designing a large project, and clearly not all of them \nmatter. Furthermore, not all of the decisions that matter are carriers of quality at-\ntributes. Some may deal with which vendor to select, or which coding convention \nto follow, or which programmer to hire or fire, or which IDE to use—important \ndecisions,  to  be  sure,  but  not  ones  that  are  directly  linked  to  a  quality  attribute  \noutcome.\nOf  course,  some  of  these  decisions  will  affect  the  achievement  of  quality","metadata":{"id":582}}],["757e8df9-c40b-474c-b4e3-ffe2d194c24b",{"pageContent":"decisions,  to  be  sure,  but  not  ones  that  are  directly  linked  to  a  quality  attribute  \noutcome.\nOf  course,  some  of  these  decisions  will  affect  the  achievement  of  quality  \nattributes. When the architect breaks down the development into a system of lay-\ners  or  modules,  or  both,  this  decision  will  affect  how  a  change  ripples  through  \nthe code base, who needs to talk to who when adding a feature or fixing a bug, \nhow  easy  or  difficult  it  is  to  distribute  or  outsource  some  of  the  development,  \nhow easy it is to port the software to a different platform, and so forth. When the \narchitect  chooses  a  distributed  resource  management  system,  how  it  determines  \nwhich services are masters and which are slaves, how it detects failures, and how \nit detects resource starvation will all affect the availability of the system.\nSo when and why do we analyze during the design process? First, we ana-","metadata":{"id":583}}],["212e51b2-3191-4d25-ab92-f197f518ec33",{"pageContent":"it detects resource starvation will all affect the availability of the system.\nSo when and why do we analyze during the design process? First, we ana-\nlyze because we can. An architecture specification, whether it is just a whiteboard \nsketch or something that has been more formally documented and circulated, is \nthe  first  artifact  supporting  an  analysis  that  sheds  insight  into  quality  attributes.  \nYes, we can analyze requirements, but we mainly analyze them for consistency \nand completeness. Until we translate those requirements into structures resulting \nfrom design decisions, we will have little to say about the actual consequences of \nthose decisions, their costs and benefits, and the tradeoffs among them.\nSecond,  and  more  to  the  point,  we  analyze  because  it  is  a  prudent  way  of  \ninforming  decisions  and  managing  risk.  No  design  is  completely  without  risk,  \nbut we want to ensure that the risks that we take on are commensurate with our","metadata":{"id":584}}],["a5d8e8df-d2d2-4e5b-8353-e6dcb446adcf",{"pageContent":"informing  decisions  and  managing  risk.  No  design  is  completely  without  risk,  \nbut we want to ensure that the risks that we take on are commensurate with our \nstakeholders’ expectations and tolerances. For a banking application or a military \napplication, our stakeholders will demand low levels of risk, and they should be \nwilling to pay accordingly for higher levels of assurance. For a startup company, \nwhere  time  to  market  is  of  the  essence  and  budgets  are  tight,  we  might  be  pre-\npared to accept far higher levels of risk. As with every important decision in soft-\nware engineering, the answer is clear: It depends.\nwww.EBooksWorld.ir\n8.3 Analysis Techniques 179\nFinally, analysis is the key to evaluation. Evaluation is the process of deter-\nmining the value of something. Companies are evaluated to determine their share \nprice. A company’s employees are evaluated annually to determine their raises. In","metadata":{"id":585}}],["252b9112-859e-4ea6-8447-d286232c3d53",{"pageContent":"mining the value of something. Companies are evaluated to determine their share \nprice. A company’s employees are evaluated annually to determine their raises. In \neach case, the evaluation is built upon an analysis of the properties of the com-\npany or employee.\n8.3 Analysis Techniques\nDifferent  projects  will  demand  different  responses  to  risk.  Fortunately  we,  as  \narchitects, have a wide variety of tools at our disposal to analyze architectures. \nWith a bit of planning, we can match our risk tolerance with a set of analysis \ntechniques that both meet our budget and schedule constraints and provide rea-\nsonable levels of assurance. The point here is that analysis does not need to be \ncostly or complex. Just asking thoughtful questions is a form of analysis, and \nthat exercise is pretty inexpensive. Building a simple prototype is more expen-\nsive,  but  in  the  context  of  a  large  project  this  analysis  technique  may  be  well","metadata":{"id":586}}],["29ec7b23-42db-4648-8926-80fe003352c9",{"pageContent":"that exercise is pretty inexpensive. Building a simple prototype is more expen-\nsive,  but  in  the  context  of  a  large  project  this  analysis  technique  may  be  well  \nworth  the  additional  expense  owing  to  how  it  explores  and  mitigates  risks,  as  \nwe saw in Chapter 5.\nExamples of (relatively economical, relatively low ceremony) analysis tech-\nniques  already  in  widespread  use  include  design  reviews  and  scenario-based  \nanalyses,  code  reviews,  pair  programming,  and  Scrum  retrospective  meetings.  \nOther commonly used, albeit somewhat more costly, analysis techniques include \nprototypes (throw-away or evolutionary) and simulations.\nAt the high end of expense and complexity, we can build formal models of \nour systems and analyze them for properties such as latency or security or safety. \nWhen a candidate implementation or a fielded system finally exists, we can per-\nform experiments, including instrumenting running systems and collecting data,","metadata":{"id":587}}],["e0375d6b-51a3-4910-9561-8f5c95d36a3c",{"pageContent":"When a candidate implementation or a fielded system finally exists, we can per-\nform experiments, including instrumenting running systems and collecting data, \nideally from executions of the system that reflect realistic usages.\nAs  indicated  in  Table  8.1,  the  cost  of  these  techniques  typically  increases  \nas you proceed through the software development life cycle. A prototype or ex-\nperiment  is  more  expensive  than  a  checklist,  which  is  more  expensive  than  an  \nexperience-based analogy. This expected cost correlates fairly strongly with the \nconfidence  that  you  can  have  in  the  analysis  results.  Unfortunately,  there  is  no  \nfree lunch!\nwww.EBooksWorld.ir\n180 Chapter 8—Analysis in the Design Process\nTABLE 8.1 Analysis at Different Stages of the Software Life Cycle\nLife-Cycle StageForm of AnalysisCostConfidence\nRequirementsExperience-based analogyLowLow–high\nRequirementsBack-of-the-envelope \nanalysis\nLowLow–medium\nArchitectureThought experiment/\nreflective questions","metadata":{"id":588}}],["27d7272c-4cc2-44b8-9c45-4e5818d9944a",{"pageContent":"Life-Cycle StageForm of AnalysisCostConfidence\nRequirementsExperience-based analogyLowLow–high\nRequirementsBack-of-the-envelope \nanalysis\nLowLow–medium\nArchitectureThought experiment/\nreflective questions\nLowLow–medium\nArchitectureChecklist-based analysisLowMedium\nArchitectureTactics-based analysisLowMedium\nArchitectureScenario-based analysisLow–mediumMedium\nArchitectureAnalytic modelLow–mediumMedium\nArchitectureSimulationMediumMedium\nArchitecturePrototypeMediumMedium–high\nImplementationExperimentMedium–highMedium–high\nFielded systemInstrumentationMedium–highHigh\n8.4 Tactics-Based Analysis\nArchitectural tactics (discussed in Section 2.5.4) have been presented thus far as \ndesign primitives. However, because these taxonomies are intended to cover the \nentire space of architectural design possibilities for managing a quality attribute, \nwe can use them in an analysis setting as well. Specifically, we can use them as \nguides for interviews or questionnaires. These interviews help you, as an analyst,","metadata":{"id":589}}],["0c12fd47-1591-44b3-a9a1-ba7b3acc279c",{"pageContent":"we can use them in an analysis setting as well. Specifically, we can use them as \nguides for interviews or questionnaires. These interviews help you, as an analyst, \nto gain rapid insight into the architectural approaches taken or not taken.\nConsider, for example, the tactics for availability, shown in Figure 8.1.\nwww.EBooksWorld.ir\n8.4 Tactics-Based Analysis 181\nDetect Faults\nPrevent Faults\nPing / Echo\nRemoval from\nService\nMonitor\nTransactions\nPredictive\nModel\nRecover from Faults\nHeartbeat\nPreparation\nand Repair\nReintroduction\nActive\nRedundancy\nPassive\nRedundancy\nSpare\nEscalating\nRestart\nException\nHandling\nShadow\nNon-Stop\nForwarding\nState\nResynchronization\nException\nPrevention\nFault\nFault\nMasked\nor\nRepair\nMade\nTimestamp\nSanity\nChecking\nCondition\nMonitoring\nVoting\nException\nDetection\nSelf-Test\nRollback\nSoftware\nUpgrade\nRetry\nIgnore Faulty\nBehavior\nDegradation\nReconfiguration\nIncrease\nCompetence Set\nAvailability Tactics\nFIGURE 8.1 Availability tactics\nEach of these tactics is a design option for the architect who wants to design","metadata":{"id":590}}],["69085e72-d7c4-424f-9896-9727213a3a01",{"pageContent":"Ignore Faulty\nBehavior\nDegradation\nReconfiguration\nIncrease\nCompetence Set\nAvailability Tactics\nFIGURE 8.1 Availability tactics\nEach of these tactics is a design option for the architect who wants to design \na highly available system. Used in hindsight, however, they represent a taxonomy \nof the entire design space for availability and hence can be a way of gaining in-\nsight into the decisions made, and not made, by the architect. To do this, we sim-\nply turn each tactic into an interview question. For example, consider the (partial) \nset of tactics-inspired availability questions in Table 8.2.\nwww.EBooksWorld.ir\n182 Chapter 8—Analysis in the Design Process\nTABLE 8.2\n \nExample Tactics-Based Availability Questions\nTactics Group\nTactics Question\nSupported? (Y/N)\nRisk\nDesign Decisions and Location\nRationale and Assumptions\nDetect faults\nDoes the system use \nping/\necho\n to detect a failure of a \ncomponent or connection, or network congestion?\nY\nL\nThe server periodically pings the time servers to see if they are “alive”.","metadata":{"id":591}}],["55670c3c-86ad-4a45-aebc-985fc4654b5a",{"pageContent":"Detect faults\nDoes the system use \nping/\necho\n to detect a failure of a \ncomponent or connection, or network congestion?\nY\nL\nThe server periodically pings the time servers to see if they are “alive”.\nIt is not possible to modify the time servers take to implement a heartbeat approach.\nDoes the system use a com\n-\nponent to \nmonitor\n the state \nof health of other parts of the system? A system monitor can detect failure or congestion in the network or other shared resources, such as from a denial-of-service attack.\nN\nN/A\nThis was not implemented in the system. We will rely on other techniques to mon\n-\nitor the system. For example, memory consumption or processor load informa\n-\ntion can be obtained from the OS. \nWe assume that informa\n-\ntion beyond what the OS provides is not critical.\nDoes the system use a \nheart\n-\nbeat\n—a periodic message \nexchange between a system monitor and a process—to detect a failure of a compo\n-\nnent or connection, or network congestion?\nY\nL\nThe server periodically sends a heartbeat to the clients.","metadata":{"id":592}}],["589950c9-bb57-43b3-a986-f1608a69c1f3",{"pageContent":"—a periodic message \nexchange between a system monitor and a process—to detect a failure of a compo\n-\nnent or connection, or network congestion?\nY\nL\nThe server periodically sends a heartbeat to the clients.\nThe server does not have to process incoming ping requests from the clients.\nDoes the system use a \ntime \nstamp\n to detect incorrect \nsequences of events in distributed systems?\nY\nM\nEvents sent from the server to the clients have a time stamp, as they have to be processed in the order that they were received.\n \nWe want to ensure that clients display an accurate representation of the state of the network, which involves receiving all of the notifications from the server and processing them in the correct order.\nwww.EBooksWorld.ir\n8.4 Tactics-Based Analysis 183\nDoes the system use \nvot\n-\ning \nto check that replicated \ncomponents are producing the same results? The replicated components may be identical replicas, functionally redun\n-\ndant, or analytically redundant.\nN\nN/A\nThis is not required by the system.\n \n   \nN/A","metadata":{"id":593}}],["17b40794-e3e5-4134-af97-759b10a62360",{"pageContent":"components are producing the same results? The replicated components may be identical replicas, functionally redun\n-\ndant, or analytically redundant.\nN\nN/A\nThis is not required by the system.\n \n   \nN/A\nDoes the system use\n excep\n-\ntion detection \nto\n \ndetect a \nsystem condition that alters the normal flow of execution—for example, system exceptions, parameter fences, parameter typing, timeouts?\nY\nL\nStandard Java exception management is used and all exceptions are sent to a log.Timeouts are implemented on the client side, when requests are sent to the server.\nThe assumption is that exceptions in Java and using timeouts are all that is needed.\nCan the system do a \nself-\ntest \nto test itself for correct \noperation?\nN\nN/A\nThis was not considered in our original design.\nThe assumption is that monitoring and exception management will provide enough information to test for correct operation. \nRecov\n-\ner from faults (prepa\n-\nration and repair)\nDoes the system employ \nac\n-\ntive redundancy \n(hot spare)?","metadata":{"id":594}}],["85d4551f-11bd-40a6-86d9-6432a9107b9a",{"pageContent":"Recov\n-\ner from faults (prepa\n-\nration and repair)\nDoes the system employ \nac\n-\ntive redundancy \n(hot spare)? \nIn active redundancy, all nodes in a protection group (a group of nodes where one or more nodes are “active”, with the re\n-\nmainder serving as redundant spares) receive and process identical inputs in parallel, allowing redundant spares to maintain synchronous state with the active node(s).\nY\nH\nActive redundancy is used in the application server and the message queue.\nActive redundancy was favored over a passive approach to reduce the possibility of losing information that needs to be collected from the time servers because of server failure. This actually exceeds the requirement established in QA-3.Also, we assume there will be no common-mode failure. \n(\ncontinues\n)\nwww.EBooksWorld.ir\n184 Chapter 8—Analysis in the Design Process\nTactics Group\nTactics Question\nSupported? (Y/N)\nRisk\nDesign Decisions and Location\nRationale and Assumptions\nDoes the system employ passive redundancy \n(warm","metadata":{"id":595}}],["af3948a3-88e3-402c-8603-caf0a4685ddb",{"pageContent":"184 Chapter 8—Analysis in the Design Process\nTactics Group\nTactics Question\nSupported? (Y/N)\nRisk\nDesign Decisions and Location\nRationale and Assumptions\nDoes the system employ passive redundancy \n(warm \nspare)? In passive redundancy, only the active members of the protection group process input traffic; one of their duties is to provide the redundant spare(s) with periodic state updates.\nN\nN/A\nActive redundancy was favored.\nN/A\nDoes the system employ rollback\n, so that it can revert to \na previously saved good state (the “rollback line”) in the event of a fault?\nY\nM\nTransaction management is supported through the Spring framework.\nSpring provides adequate support for the type of transactions required by this system.\nwww.EBooksWorld.ir\n8.5 Reflective Questions 185\nWhen the questions in Table 8.2 are used in an interview setting, we can record \nwhether each tactic is supported by the system’s architecture, according to the opin-","metadata":{"id":596}}],["f7b448cd-ddf8-46cd-af60-ac0660bcc5cd",{"pageContent":"8.5 Reflective Questions 185\nWhen the questions in Table 8.2 are used in an interview setting, we can record \nwhether each tactic is supported by the system’s architecture, according to the opin-\nions of the architect. For example, in the table, the questions have been answered with \nrespect to design decisions made for the FCAPS system presented in Chapter 4. Note \nthat  the  answers  shown  in  the  table  are  rather  succinct  because  this  is  an  example;  \nmore detailed explanations are encouraged in real-world applications. If we are ana-\nlyzing an existing system we can additionally investigate the following issues:\n§\tWhether there are any obvious risks in the use (or nonuse) of this tactic. If \nthe tactic has been used, we can record here how it is realized in the system \n(e.g., via custom code, frameworks, or other externally produced compo-\nnents). For example, we might note that the active redundancy tactic has","metadata":{"id":597}}],["6f2b2011-8904-4d72-ab72-3fe1be9cc917",{"pageContent":"(e.g., via custom code, frameworks, or other externally produced compo-\nnents). For example, we might note that the active redundancy tactic has \nbeen employed by replicating the application server and other critical com-\nponents such as the database (as in the case study presented in Chapter 4).\n§\tThe specific design decisions made to realize the tactic and where in the code \nbase the implementation (realization) may be found. This information is useful \nfor auditing and architecture reconstruction purposes. Continuing the example \nfrom the previous bullet, we might probe how many replicas of the application \nserver have been created and where these replicas are located (e.g., on the same \nrack in a data center, on different racks, in different data centers).\n§\tAny rationale or assumptions made in the realization of this tactic. For \nexample, we might assume that there will be no common-mode failure, so \nit is acceptable that the replicas are identical virtual machines, running on","metadata":{"id":598}}],["54f8c622-331a-4b45-a77a-d65d4255fe9c",{"pageContent":"example, we might assume that there will be no common-mode failure, so \nit is acceptable that the replicas are identical virtual machines, running on \nidentical hardware.\nWhile this interview-based approach might sound simplistic, it can actually \nbe quite powerful and insightful. In your daily activities as an architect, you may \nnot always take the time to step back and consider the bigger picture. A set of in-\nterview questions such as those shown in Table 8.2 force you to do just that. This \napproach is also quite efficient: A typical interview for a single quality attribute \ntakes between 30 and 90 minutes.\nA set of tactics-based questionnaires, covering the seven most important sys-\ntem  quality  attributes—availability,  interoperability,  modifiability,  performance,  \nsecurity, testability, and usability—can be found in Appendix B. In addition, we \nhave included an eighth questionnaire, on DevOps, as an example of how you can","metadata":{"id":599}}],["fd32600a-b668-4137-a866-a5dd5accc6c3",{"pageContent":"security, testability, and usability—can be found in Appendix B. In addition, we \nhave included an eighth questionnaire, on DevOps, as an example of how you can \ncombine the other (more fundamental) questionnaires to create a new question-\nnaire to address a new set of quality concerns.\n8.5 Reflective Questions\nSimilar to the tactics-based interviews, a number of researchers have advocated \nthe practice of asking (and answering) reflective questions to augment the design \nwww.EBooksWorld.ir\n186 Chapter 8—Analysis in the Design Process\nprocess. The idea behind this process is that we actually think differently when \nwe are problem-solving and when we are reflecting. For this reason, researchers \nhave advocated a separate “reflection” activity in design that both challenges the \ndecisions made and challenges us to examine our biases.\nArchitects, like all humans, are subject to bias. For example, we are subject \nto  confirmation  bias—the  tendency  to  interpret  new  information  in  a  way  that","metadata":{"id":600}}],["b606b1fc-8177-4bcd-b67b-629382d9ccef",{"pageContent":"Architects, like all humans, are subject to bias. For example, we are subject \nto  confirmation  bias—the  tendency  to  interpret  new  information  in  a  way  that  \nconfirms  our  preconceptions—and  we  are  subject  to  anchoring  bias—the  ten-\ndency to rely too heavily on the first piece of information that we receive when \ninvestigating a problem, using this information to filter and judge any subsequent \ninformation.  Reflective  questions  help  to  uncover  such  biases  in  a  systematic  \nway, which can lead us to revise our assumptions and hence our designs.\nIn their research on reflective questions, Razavian et al. have proposed that \none can and should reflect on context and requirements (Are the contexts and re-\nquirements identified relevant, complete, and accurate?), design problems (Have \nthey been properly and fully articulated?), design solutions (Are they appropriate \ngiven  the  requirements?),  and  design  decisions  (Are  they  principled  and  justi-","metadata":{"id":601}}],["2f32d8a3-ade5-4e8e-aecf-68d8ce782efa",{"pageContent":"they been properly and fully articulated?), design solutions (Are they appropriate \ngiven  the  requirements?),  and  design  decisions  (Are  they  principled  and  justi-\nfied?). Examples of reflective questions that they propose include the following:\n§\tWhich assumptions are made? Do the assumptions affect the design prob-\nlem? Do the assumptions affect the solution option? Is an assumption ac-\nceptable in a decision?\n§\tWhat are the risks that certain events would happen? How do the risks \ncause design problems? How do the risks affect the viability of a solution? \nIs the risk of a decision acceptable? What can be done to mitigate the risks?\n§\tWhat are the constraints imposed by the contexts? How do the constraints \ncause design problems? How do the constraints limit the solution options? \nCan any constraints be relaxed when making a decision?\n§\tWhat are the contexts and the requirements of this system? What does this \ncontext mean? What are the design problems? Which are the important","metadata":{"id":602}}],["463a8437-c37c-4bf7-ae81-8d949963ba63",{"pageContent":"Can any constraints be relaxed when making a decision?\n§\tWhat are the contexts and the requirements of this system? What does this \ncontext mean? What are the design problems? Which are the important \nproblems that need to be solved? What does this problem mean? Which po-\ntential solutions exist for this problem? Are there other problems to follow \nup in this decision?\n§\tWhich contexts can be compromised? Can a problem be framed differently? \nWhat are the solution options? Can a solution option be compromised? Are \nthe pros and cons of each solution treated fairly? What is an optimal solution \nafter tradeoff?\nOf course, you might not employ all of these questions, and you would not \nemploy this technique for every decision that you make. Used judiciously, how-\never, these kinds of questions can help you to reflect mindfully on the decisions \nthat you are making.\nwww.EBooksWorld.ir\n8.6 Scenario-Based Design Reviews 187\n8.6 Scenario-Based Design Reviews","metadata":{"id":603}}],["7af13589-8900-4579-a67d-bcaddb385d10",{"pageContent":"ever, these kinds of questions can help you to reflect mindfully on the decisions \nthat you are making.\nwww.EBooksWorld.ir\n8.6 Scenario-Based Design Reviews 187\n8.6 Scenario-Based Design Reviews\nComprehensive scenario-based design reviews, such as the ATAM, have typically \nbeen conducted outside the design process. The ATAM is an example of a com-\nprehensive architecture evaluation (see the sidebar “The ATAM”).\nAn  ATAM  review,  as  it  was  initially  conceived,  was  a  “milestone”  review.  \nWhen  an  architect  or  other  key  stakeholder  believed  that  there  was  enough  of  \nan  architecture  or  architecture  description  to  analyze,  an  ATAM  meeting  could  \nbe convened. This might occur when an architectural design had been done but \nbefore  much,  if  any,  implementation  had  been  completed.  More  commonly,  it  \noccurred  when  an  existing  system  was  in  place  and  some  stakeholders  wanted","metadata":{"id":604}}],["5a175cae-5253-492b-89e0-e5bc1f58fef2",{"pageContent":"before  much,  if  any,  implementation  had  been  completed.  More  commonly,  it  \noccurred  when  an  existing  system  was  in  place  and  some  stakeholders  wanted  \nan  objective  evaluation  of  the  risks  of  the  architecture  before  committing  to  it,  \nevolving it, acquiring it, and so forth.\nThe ATAM\nThe ATAM—Architecture Tradeoff Analysis Method (ATAM) is an estab-\nlished method for analyzing architectures, driven by scenarios. Its purpose \nis to assess the consequences of architectural decisions in light of quality \nattribute requirements and business goals.\nThe ATAM brings together three groups in an evaluation:\n§\tA trained evaluation team\n§\tAn architecture’s “decision makers”\n§\tRepresentatives of the architecture’s stakeholders\nThe ATAM helps stakeholders ask the right questions to discover poten-\ntially problematic architectural decisions—that is, risks. These discovered \nrisks can then be made the focus of mitigation activities such as further de-","metadata":{"id":605}}],["b22d2c88-1d1c-4695-9007-5790d0dd216e",{"pageContent":"tially problematic architectural decisions—that is, risks. These discovered \nrisks can then be made the focus of mitigation activities such as further de-\nsign, further analysis, prototyping, and implementation. In addition, design \ntradeoffs are often identified—hence the name of the method. The purpose \nof the ATAM is not to provide precise analyses: This method typically is \napplied in two 2-day meetings and this (relatively) short time frame does \nnot permit a deep dive into any specific concern. Those kinds of analyses \nare, however, appropriate as part of the risk mitigation activities that could \nfollow and be guided by an ATAM.\nThe ATAM can be used throughout the software development life cycle. \nFor example, it can be used in the following circumstances:\n§\tAfter an architecture has been specified but there is little or no code\n§\tTo evaluate potential architectural alternatives\n§\tTo evaluate the architecture of an existing system\nThe outputs of the ATAM evaluation are as follows:","metadata":{"id":606}}],["39c53d76-4fac-494b-b779-425d7d69a14d",{"pageContent":"§\tTo evaluate potential architectural alternatives\n§\tTo evaluate the architecture of an existing system\nThe outputs of the ATAM evaluation are as follows:\nwww.EBooksWorld.ir\n188 Chapter 8—Analysis in the Design Process\n§\tA concise presentation of the architecture. The architecture is presented in \none hour.\n§\tA concise articulation of the business goals for the system under scrutiny. \nFrequently, the business goals presented in the ATAM are being seen by \nsome of the assembled participants for the first time and these are cap-\ntured in the outputs.\n§\tA set of prioritized quality attribute requirements, expressed as scenarios.\n§\tA mapping of architectural decisions to quality requirements. For each \nquality attribute scenario examined, the architectural decisions that help to \nachieve it are identified and recorded.\n§\tA set of sensitivity and tradeoff points. These architectural decisions have a \nmarked effect on one or more quality attributes.","metadata":{"id":607}}],["526b0218-237d-48e4-aaf2-e200184c62b9",{"pageContent":"achieve it are identified and recorded.\n§\tA set of sensitivity and tradeoff points. These architectural decisions have a \nmarked effect on one or more quality attributes.\n§\tA set of risks and non-risks. A risk is defined as an architectural decision \nthat may lead to undesirable consequences in light of quality attribute \nrequirements. A non-risk is an architectural decision that, upon analysis, \nis deemed safe. The identified risks form the basis of an architectural risk \nmitigation plan.\n§\tA set of risk themes. The evaluation team examines the full set of discov-\nered risks to identify overarching themes that reveal systemic weaknesses \nin the architecture (or perhaps even in the architecture process and team). \nIf left untreated, these weaknesses will threaten the project’s ability to meet \nthe business goals.\nThere are also intangible results of an ATAM-based evaluation: a sense \nof community developed among the stakeholders, open communication","metadata":{"id":608}}],["18b34bf1-9b64-44ed-8c60-d2eb76d0e1ad",{"pageContent":"the business goals.\nThere are also intangible results of an ATAM-based evaluation: a sense \nof community developed among the stakeholders, open communication \nchannels between the architect and the stakeholders, a better overall \nunderstanding of the architecture and its strengths and weaknesses. While \nthese results are difficult to measure, they are no less important than the \nothers and often are the longest-lasting artifacts.\nAn ATAM evaluation takes place in four phases. The first phase (phase 0) \nand the final phase (phase 3) are managerial: setting up the evaluation at \nthe start and reporting results and follow-on activities at the end. The middle \nphases (phases 1 and 2) are when the actual analysis takes place. The steps \nenacted in phases 1 and 2 are as follows:\n1. Present the ATAM\n2. Present the business drivers\n3. Present the architecture\n4. Identify the architectural approaches\n5. Generate a quality attribute utility tree\n6. Analyze the architectural approaches","metadata":{"id":609}}],["8f8556eb-1aab-4963-b4f0-e86f5e07e457",{"pageContent":"1. Present the ATAM\n2. Present the business drivers\n3. Present the architecture\n4. Identify the architectural approaches\n5. Generate a quality attribute utility tree\n6. Analyze the architectural approaches\n7. Brainstorm and prioritize scenarios\n8. Analyze the architectural approaches\n9. Present the results\nwww.EBooksWorld.ir\n8.6 Scenario-Based Design Reviews 189\nIn phase 1, we enact steps 1–6 with a small, internal group of stake-\nholders—typically just the architect, project manager and perhaps one or \ntwo senior developers. In phase 2, we invite a larger group of stakeholders \nto attend—all the people who attended phase 1 plus external stakehold-\ners, such as customer representatives, end-user representatives, quality \nassurance, operations, and so forth. In phase 2, we review steps 1–6 and \nenact steps 7–9.\nThe actual analysis takes place in step 6, where we analyze archi-\ntectural approaches by asking the architect to map the highest-priority","metadata":{"id":610}}],["8f0a8730-c1d8-4237-9cbd-2b4819259183",{"pageContent":"enact steps 7–9.\nThe actual analysis takes place in step 6, where we analyze archi-\ntectural approaches by asking the architect to map the highest-priority \nscenarios, one at a time, onto the architectural approaches that have been \ndescribed. During this step, the analysts ask probing questions, moti-\nvated by a knowledge of quality attributes, and risks are discovered and \ndocumented. \nThe  idea  of  having  a  separate,  distinct  evaluation  activity  once  the  archi-\ntecture is “done” fits poorly with the way that most organizations operate today. \nToday, most software organizations are practicing some form of Agile or iterative \ndevelopment.  There  is  no  distinct  monolithic  “architecture  phase”  in  Agile  pro-\ncesses. Rather, architecture and development are co-created in a series of sprints. \nFor example, as discussed in Chapter 2, many Agile thought leaders are promot-\ning  practices  such  as  “disciplined  agility  at  scale”,  the  “walking  skeleton”,  and","metadata":{"id":611}}],["2fd43cc8-487e-4fc6-9095-c5792914d7c6",{"pageContent":"For example, as discussed in Chapter 2, many Agile thought leaders are promot-\ning  practices  such  as  “disciplined  agility  at  scale”,  the  “walking  skeleton”,  and  \nthe  “scaled  Agile  framework”,  all  of  which  embrace  the  idea  that  architectures  \ncontinuously  evolve  in  relatively  small  increments,  addressing  the  most  critical  \nrisks.  This  may  be  aided  by  developing  a  small  proof-of-concept  or  minimum \nviable product (MVP), or doing strategic prototyping.\nTo  better  align  with  this  view  of  software  development,  a  lightweight  \nscenario-based  peer  review  method,  based  on  the  ATAM,  has  been  promoted.  A  \nlightweight ATAM evaluation can be conducted in a half-day meeting. It can also \nbe carried out internally, using just project members. Of course, an external review \ngives  more  objectivity  and  may  produce  better  results,  but  this  exercise  may  be","metadata":{"id":612}}],["83c7ae05-7b58-48a0-860e-8c4df6b44bb4",{"pageContent":"be carried out internally, using just project members. Of course, an external review \ngives  more  objectivity  and  may  produce  better  results,  but  this  exercise  may  be  \ntoo costly or infeasible due to schedule or intellectual property (IP) constraints. A \nlightweight ATAM therefore provides a reasonable middle ground between a costly \nbut more objective and comprehensive ATAM and doing no analysis whatsoever, or \nonly doing ad hoc analysis.\nAn example schedule for a lightweight ATAM evaluation conducted by proj-\nect members on their own project is given in Table 8.3. \nwww.EBooksWorld.ir\n190 Chapter 8—Analysis in the Design Process\nTABLE 8.3 A Typical Agenda for a Lightweight ATAM Evaluation\nStep\nTime\nAllottedNotes\n1. Present \nbusiness \ndrivers\n0.25 hourThe participants are expected to understand the \nsystem and its business goals and their priorities. \nFifteen minutes is allocated for a brief review to \nensure that these are fresh in everyone’s mind and \nthat there are no surprises.\n2. Present","metadata":{"id":613}}],["caab5c58-d8af-460d-9610-fd9526d42427",{"pageContent":"system and its business goals and their priorities. \nFifteen minutes is allocated for a brief review to \nensure that these are fresh in everyone’s mind and \nthat there are no surprises.\n2. Present \narchitecture\n0.5 hourAll participants are expected to be familiar with the \nsystem, so a brief overview of the architecture is \npresented and 1 or 2 scenarios are traced through \nthe documented architecture views.\n3. Identify \narchitectural \napproaches\n0.25 hourThe architecture approaches for specific quality \nattribute concerns are identified by the architect. \nThis may be done as a portion of step 2.\n4. Generate \nquality \nattribute \nutility tree\n0.5 hourScenarios might already exist; if so, use them. A \nutility tree might already exist; if so, the team reviews \nit and updates it, if necessary.\n5. Analyze \narchitectural \napproaches\n2.0 hoursThis step—mapping the highly ranked scenarios \nonto the architecture—consumes the bulk of the \ntime and can be expanded or contracted as needed.\n6. Present \nresults","metadata":{"id":614}}],["224fe9d1-c930-484b-9302-06a27d9e4c35",{"pageContent":"architectural \napproaches\n2.0 hoursThis step—mapping the highly ranked scenarios \nonto the architecture—consumes the bulk of the \ntime and can be expanded or contracted as needed.\n6. Present \nresults\n0.5 hourAt the end of the evaluation, the team reviews the \nexisting and newly discovered risks and tradeoffs \nand discusses priorities.\nTOTAL4 hours\nA half-day review such as this is similar, in terms of effort, to other quality \nassurance efforts that are typically conducted in a development project, such as \ncode reviews, inspections, and walk-throughs. For this reason, it is easy to sched-\nule a lightweight ATAM evaluation in a sprint, particularly in those sprints where \narchitectural decisions are being made, challenged, or changed.\n8.7 Architecture Description Languages\nIf the application that you are building has stringent quality requirements in the \nareas of runtime performance (latency, throughput), reliability/availability, safety,","metadata":{"id":615}}],["ce1b167e-7209-40ed-9acf-c610d6f1476b",{"pageContent":"If the application that you are building has stringent quality requirements in the \nareas of runtime performance (latency, throughput), reliability/availability, safety, \nor  security,  then  you  might  consider  documenting  your  design  decisions,  in  the  \nform  of  architectural  structures,  in  an  architecture  description  language  (ADL). \nADLs lend themselves to formal, automated analysis, which is precisely why we \ninclude them here. ADLs typically employ both a graphical and a (formally de-\nfined)  textual  notation  to  describe  an  architecture—primarily  the  computational  \nwww.EBooksWorld.ir\n8.8    Summary 191\n(runtime)  components  and  interactions  among  them—and  its  properties.  The  \nUnified  Modeling  Language  (UML)  is  the  most  widely  used  notation  for  doc-\numenting  architectures  in  industrial  practice,  though  even  it  is  not  universally  \nused. Few industrial projects endeavor to describe all, or even most, of their ar-\nchitectures in any ADL.","metadata":{"id":616}}],["ff440e3f-536b-43ba-a654-d7863de93580",{"pageContent":"umenting  architectures  in  industrial  practice,  though  even  it  is  not  universally  \nused. Few industrial projects endeavor to describe all, or even most, of their ar-\nchitectures in any ADL.\nSome  ADLs,  such  as  AADL,  strive  to  be  formal  models  that  have  precise  \nand  decidable  semantics.  This  regimentation  means  that  they  can  be  automati-\ncally  checked  for  properties  of  interest,  typically  performance,  availability,  and  \nsafety, although in principle other quality attributes can be accommodated. While \nthere is an often a steep learning curve for becoming proficient with the language \nand  the  surrounding  tool  suite,  using  a  formalized  ADL  offers  several  benefits.  \nFirst,  an  ADL  forces  you  to  document  your  architectural  decisions,  and  hence  \nto  explicitly  acknowledge  when  and  where  your  architectural  understanding  is  \nincomplete  or  vague.  This  benefit  accrues  with  any  form  of  documentation—it","metadata":{"id":617}}],["79031f14-b5dc-4618-9501-d1c3ea53b351",{"pageContent":"to  explicitly  acknowledge  when  and  where  your  architectural  understanding  is  \nincomplete  or  vague.  This  benefit  accrues  with  any  form  of  documentation—it  \nforces you to be explicit—but is especially true of ADLs. This leads to the second \nbenefit of ADLs: They are typically accompanied by a tool suite that can analyze \nthe architecture description for various properties at the click of a button.\nSo  why  are  ADLs  seldom  used  outside  of  academia?  A  number  of  pos-\nsible  reasons  for  this  reluctance  exist.  First,  it  is  not  in  our  common  practice.  \nADLs—even the UML—are typically not taught in computer science or software \nengineering curricula and are not well supported in most popular IDEs. Second, \nADLs are perceived as being challenging to use and not user-friendly, requiring \nboth a large up-front effort and a large continuing effort to maintain. This point \nis,  perhaps,  the  most  significant  one:  Architects  and  programmers  generally  do","metadata":{"id":618}}],["73b0f762-0b5c-43d1-8670-1d2af36fdf96",{"pageContent":"both a large up-front effort and a large continuing effort to maintain. This point \nis,  perhaps,  the  most  significant  one:  Architects  and  programmers  generally  do  \nnot  want  to  maintain  a  second,  parallel  base  of  knowledge  about  their  systems.  \nFor some systems, this may be the right choice. For others—typically those with \nstringent and uncompromising quality attribute requirements—having a separate \nand separately analyzable representation of the design might be the most prudent \ncourse of action. In civil engineering, by way of contrast, no project may be ap-\nproved  for  construction  without  first  being  represented  in  a  separate  analyzable  \ndocument.\n8.8    Summary\nNo  one  would  consider  fielding  code  that  they  had  not  tested—yet  architects  \nand  programmers  regularly  commit  to  (implement)  architectural  decisions  that  \nhave not been analyzed. Why the dichotomy? Surely, if testing code is important,","metadata":{"id":619}}],["8cb97a41-4717-4482-b737-1a23923696ac",{"pageContent":"and  programmers  regularly  commit  to  (implement)  architectural  decisions  that  \nhave not been analyzed. Why the dichotomy? Surely, if testing code is important, \nthen “testing” the design decisions you have made is an order of magnitude more \nimportant, as these decisions often have long-term, system-wide, and significant \nimpacts.\nwww.EBooksWorld.ir\n192 Chapter 8—Analysis in the Design Process\nThe most important message of this chapter is that design and analysis are \nnot  really  separate  activities.  Every  important  design  decision  that  you  make  \nshould  be  analyzed.  A  variety  of  techniques  can  be  applied  to  do  this  continu-\nously, in a relatively disruption-free manner, as part of the process of designing \nand evolving a system.\nThe interesting questions are not whether to analyze, but rather how much \nto analyze and when. Analysis is inherent in doing good design, and it should be \na continuous process.\n8.9 Further Reading","metadata":{"id":620}}],["4110871b-54ba-4209-b0ee-ed300c4d1e65",{"pageContent":"The interesting questions are not whether to analyze, but rather how much \nto analyze and when. Analysis is inherent in doing good design, and it should be \na continuous process.\n8.9 Further Reading\nThe  sets  of  architectural  tactics  used  here  have  been  documented  in  L.  Bass,  \nP.  Clements,  and  R.  Kazman,  Software  Architecture  in  Practice  (3rd  ed.),  \nAddison-Wesley, 2012. The availability tactics were first created in J. Scott and \nR. Kazman, “Realizing and Refining Architectural Tactics: Availability”, CMU/\nSEI-2009-TR-006, 2009.\nThe  idea  of  reflective  questions  was  first  introduced  in  M.  Razavian,  \nA.  Tang,  R.  Capilla,  and  P.  Lago,  “In  Two  Minds:  How  Reflections  Influence  \nSoftware Architecture Design Thinking”, VU University Amsterdam, Tech. Rep. \n2015-001,  April  2015.  The  idea  that  software  designers  satisfice—that  is,  they  \nlook  for  a  “good  enough”,  as  opposed  to  an  optimal,  solution—has  been  dis-","metadata":{"id":621}}],["9abc2b32-5895-4e05-96e0-dc80ec1e3d20",{"pageContent":"2015-001,  April  2015.  The  idea  that  software  designers  satisfice—that  is,  they  \nlook  for  a  “good  enough”,  as  opposed  to  an  optimal,  solution—has  been  dis-\ncussed  in  A.  Tang  and  H.  van  Vliet,  “Software  Designers  Satisfice”,  European \nConference on Software Architecture (ECSA 2015), 2015.\nThe  ATAM  was  comprehensively  described  in  P.  Clements,  R.  Kazman,  \nand  M.  Klein,  Evaluating  Software  Architectures:  Methods  and  Case  Studies, \nAddison-Wesley,  2001.  The  lightweight  ATAM  was  first  presented  in  L.  Bass,  \nP.  Clements,  and  R.  Kazman,  Software  Architecture  in  Practice  (3rd  ed.),  \nAddison-Wesley,  2012.  In  addition,  ATAM-style  peer  reviews  have  been  de-\nscribed  in  F.  Bachmann,  “Give  the  Stakeholders  What  They  Want:  Design  Peer  \nReviews the ATAM Style”, Crosstalk, November/December 2011.\nArchitecture  description  languages  have  a  history  almost  as  long  as  the","metadata":{"id":622}}],["13d12236-15c6-4ecc-a761-18976bb186ea",{"pageContent":"Reviews the ATAM Style”, Crosstalk, November/December 2011.\nArchitecture  description  languages  have  a  history  almost  as  long  as  the  \nhistory  of  software  architecture  itself.  The  most  widely  used  ADL  in  practice  \nis  AADL  (Architecture  Analysis  and  Design  Language),  which  is  described  in  \nP.  Feiler  and  D.  Gluch,  Model-Based  Engineering  with  AADL:  An  Introduction  \nto the SAE Architecture Analysis & Design Language, Addison-Wesley, 2013. An \noverview  of,  and  analysis  of  industrial  requirements  for,  ADLs  can  be  found  in  \nI.  Malavolta,  P.  Lago,  H.  Muccini,  P.  Pelliccione,  and  A.  Tang,  “What  Industry  \nNeeds from Architectural Languages: A Survey”, IEEE Transactions on Software \nEngineering, 39(6):869–891, June 2013.\nwww.EBooksWorld.ir\n193\n9\nThe Architecture \nDesign Process in the \nOrganization\nChapter  1  introduced  a  set  of  software  architecture  life-cycle  activities—things","metadata":{"id":623}}],["da7ddec9-23c0-4402-acdd-a66099c462bb",{"pageContent":"www.EBooksWorld.ir\n193\n9\nThe Architecture \nDesign Process in the \nOrganization\nChapter  1  introduced  a  set  of  software  architecture  life-cycle  activities—things  \nlike  collecting  requirements,  designing  the  architecture,  and  evaluating  and  im-\nplementing  the  architecture.  We  called  these  “life-cycle  activities”  because  we  \nrecognize that not all organizations do all of them; those that do them might do \nthem  in  different  ways,  and  might  embed  them  into  different  life-cycle  models  \nand organizational contexts. This chapter takes a closer look at those aspects of \nsoftware development and considers how architecture design fits in with them.\n9.1 Architecture Design and the Development Life Cycle\nTwo important phases that occur in most development projects, as illustrated in \nFigure 9.1, are pre-sales and development and operations.\nwww.EBooksWorld.ir\n194 Chapter 9—The Architecture Design Process in the Organization\nPre-Sales\nArchitecture Design\nArchitecture Design","metadata":{"id":624}}],["202ee8b3-bd55-4c4d-9005-d1fc8389dd4c",{"pageContent":"Figure 9.1, are pre-sales and development and operations.\nwww.EBooksWorld.ir\n194 Chapter 9—The Architecture Design Process in the Organization\nPre-Sales\nArchitecture Design\nArchitecture Design\nFIGURE 9.1 The two major phases of project development\n§\tDuring the pre-sales phase, the scope of the project is established and a \nbusiness case is established. Although we call this phase “pre-sales”, it \noccurs in every organization, whether they engage in “sales” or not. One \nfrequent and important product of this phase is an estimation of the cost \nand duration of the project. This estimation is used by the customers (or \nfunders) to decide if they want to pursue the project.\n§\tThe development and operations phase occurs when the pre-sales proposal \nhas been accepted by the customer. Development can be performed follow-\ning different methodologies including Agile, RUP, or TSP. Once the system \n(or part of it) is developed, it is put into operation. Newer approaches such","metadata":{"id":625}}],["a2ba0e1c-a0ee-4077-a1ef-6b22b2f85b06",{"pageContent":"ing different methodologies including Agile, RUP, or TSP. Once the system \n(or part of it) is developed, it is put into operation. Newer approaches such \nas DevOps intend to reduce the gap that is usually present between devel-\nopment and operation.\nArchitectural  design  plays  an  important  role  in  these  two  major  phases,  as  \nwe will now discuss.\n9.1.1 Architecture Design During Pre-Sales\nIn many types of development projects, but particularly in the context of custom \nsoftware development, organizations typically need to provide an initial estimate \nof the time and cost of the project during the pre-sales phase. Frequently the pre-\nsales activities must be performed in a short time period, and the information that \nis available to inform this process is always limited. For example, typically only \nhigh-level requirements or features (rather than detailed use cases) are available \nat this phase.\nThe problem with limited information is that the estimate that is produced","metadata":{"id":626}}],["cf8960fb-78dd-4b17-a439-01770db9b3f1",{"pageContent":"high-level requirements or features (rather than detailed use cases) are available \nat this phase.\nThe problem with limited information is that the estimate that is produced \nfrequently  has  a  lot  of  uncertainty,  as  illustrated  by  the  cone  of  uncertainty  de-\npicted in Figure 9.2. The cone of uncertainty refers to the uncertainty surrounding \nestimates in a project, typically those of cost and schedule, but also risk. All of \nthese estimates get better as a project progresses, and the cone narrows. When the \nproject is done, uncertainty is zero. The issue for any development methodology \nis how to narrow the cone of uncertainty earlier in the project’s life cycle.\nwww.EBooksWorld.ir\n9.1 Architecture Design and the Development Life Cycle 195\nInitial\nProject\nDefinition\nApproved\nProject\nDefinition\nRequirements\nSpecification\nProduct\nDesign\nSpecification\nDetailed\nDesign\nSpecification\nAccepted\nSoftware\n1.6x\n1.25x\n1.15x\n1.1x\n0.9x\n0.85x\n0.8x\n0.6x\nx\nFIGURE 9.2 Example cone of uncertainty","metadata":{"id":627}}],["2da0a8a6-d42f-4eee-818e-849a511a60ee",{"pageContent":"Approved\nProject\nDefinition\nRequirements\nSpecification\nProduct\nDesign\nSpecification\nDetailed\nDesign\nSpecification\nAccepted\nSoftware\n1.6x\n1.25x\n1.15x\n1.1x\n0.9x\n0.85x\n0.8x\n0.6x\nx\nFIGURE 9.2 Example cone of uncertainty\nArchitectural practices can be applied in the pre-sales phase to help reduce \nthe cone of uncertainty:\n§\tArchitectural drivers can be identified in the pre-sales phase. Even if it may \nbe complicated to describe detailed quality attribute scenarios at this point, \nthe most important quality attributes with initial measures and constraints \nshould be identified.\n§\tADD can be used to produce an initial architecture that is then used as the \nbasis for early cost and schedule estimates.\n§\tSketches of this initial architecture are useful for communication with the \ncustomer. They are also useful as a basis to perform lightweight evaluations \nof this initial design.\nGenerating  an  initial  architecture  allows  estimation  to  be  performed  using","metadata":{"id":628}}],["8e156e58-0b85-41d3-8915-6cf4408c812c",{"pageContent":"customer. They are also useful as a basis to perform lightweight evaluations \nof this initial design.\nGenerating  an  initial  architecture  allows  estimation  to  be  performed  using  \nthe “standard components” technique. Standard components are a type of proxy; \nthey  include  web  pages,  business  rules,  and  reports,  among  other  things.  When  \nestimating  with  standard  components,  companies  typically  build  historic  data-\nbases that contain, for example, measurements and size data for components that \nhave  been  built  into  previously  developed  systems.  To  estimate  with  standard  \ncomponents,  you  need  to  identify  the  components  that  will  be  required  for  the  \nwww.EBooksWorld.ir\n196 Chapter 9—The Architecture Design Process in the Organization\nproblem that you are trying to solve, and then use historical data (or some other \ntechnique  such  as  Wideband  Delphi)  to  estimate  the  size  of  these  components.","metadata":{"id":629}}],["8ee46845-47ba-4388-a494-8e018a18ef05",{"pageContent":"problem that you are trying to solve, and then use historical data (or some other \ntechnique  such  as  Wideband  Delphi)  to  estimate  the  size  of  these  components.  \nThe total size can then be translated into effort, and these estimates can be rolled \nup to produce a project-level time and cost estimate.\nIdentifying  the  components  that  are  required  to  create  estimates  with  this  \ntechnique  can  be  achieved  in  a  short  time  frame  through  the  use  of  ADD.  This  \napproach  is  similar  to  what  we  just  recommended  for  the  design  of  greenfield  \nsystems:\n§\tThe goal of your first design iteration should be to address the concern of \nestablishing an initial overall structure for the application. The reference \narchitecture, if you employ one, dictates the types of standard components \nthat will be used in the estimation. At this point, the most relevant technolo-\ngies to use in the project can also be selected, particularly if your historical","metadata":{"id":630}}],["f44566f6-486d-4153-88b8-1e7f456a5a1b",{"pageContent":"that will be used in the estimation. At this point, the most relevant technolo-\ngies to use in the project can also be selected, particularly if your historical \ndata is tied to specific technologies.\n§\tThe goal of your second design iteration should be to identify components \nto support all of the functionality that needs to be considered for the estima-\ntion. As opposed to what we discussed for the design of greenfield systems, \nwhen designing to produce an estimate, you need to consider more than \njust primary functionality. To identify the standard components, you need \nto consider all of the important functional requirements that are part of the \nscope and map them to the structure that you defined in the first iteration. \nDoing so ensures you will have a more accurate estimation.\nThis technique will help you estimate costs and schedule for meeting the most \nimportant functional requirements. At this point, however, you will likely not have","metadata":{"id":631}}],["707c2e5b-8c90-4791-9d96-d1f55abc70db",{"pageContent":"This technique will help you estimate costs and schedule for meeting the most \nimportant functional requirements. At this point, however, you will likely not have \ntaken quality attributes into account. As a consequence, you should perform a few \nmore  iterations  focusing  on  where  you  will  make  design  decisions  to  address  the  \ndriving  quality  attributes.  If  the  time  available  to  perform  the  pre-sales  process  is  \nlimited, you will not be able to design it in much detail, so the decisions that you \nshould take here are the ones that will have a significant impact in the estimate. Ex-\namples include identifying redundant hardware or additional standard components \nto address quality attributes such as performance, availability, and security.\nWhen this technique is used in the pre-sales process, an initial architecture de-\nsign is produced—the pre-sales architecture design (see Figure 9.1). If the project","metadata":{"id":632}}],["f31df904-ea18-4940-9311-e674e0b70979",{"pageContent":"When this technique is used in the pre-sales process, an initial architecture de-\nsign is produced—the pre-sales architecture design (see Figure 9.1). If the project \nproposal is accepted by the customer and the project proceeds, this initial architec-\nture can become one of the bases for a contract. This architecture should be used as \na starting point in the subsequent architecture design activities that are performed \nduring the Development and Operation phase of the project. In this case, the road-\nmap for designing brownfield systems (discussed in Section 3.3.3) can be used.\nThe  preliminary  documentation  produced  for  this  initial  architecture  can  \nalso be included as part of the technical proposal that is provided to the customer. \nFinally,  this  initial  architecture  design  can  be  evaluated,  preferably  before  esti-\nmation occurs. This can be performed using a technique such as the lightweight \nATAM presented in Section 8.6.\nwww.EBooksWorld.ir","metadata":{"id":633}}],["82e82058-f639-44aa-a261-2b61f3069351",{"pageContent":"mation occurs. This can be performed using a technique such as the lightweight \nATAM presented in Section 8.6.\nwww.EBooksWorld.ir\n9.1 Architecture Design and the Development Life Cycle 197\n9.1.2 Architecture Design During Development and Operation\nThe development of a software system can be performed using different method-\nologies. Architectural design, however, is performed independently of the chosen \ndevelopment methodology. For this reason, a design method such as ADD can be \nused in conjunction with different development methodologies. We now discuss \nthe relationship between architectural design and some development methodolo-\ngies that are commonly used in industry.\n9.1.2.1 Agile Methods\nThe relationship between software architecture and agility has been the subject of \nsome debate over the past decade. Although we believe, and much research has \nshown, that architectural practices and Agile practices are actually well aligned, \nthis position has not always been universally accepted.","metadata":{"id":634}}],["872d49c7-3971-48da-ad70-4856805e18fd",{"pageContent":"shown, that architectural practices and Agile practices are actually well aligned, \nthis position has not always been universally accepted.\nAgile practices, according to the original Agile Manifesto emphasize, “Individ-\nuals  and  interactions  over  processes  and  tools,  working  software  over  comprehen-\nsive documentation, customer collaboration over contract negotiation, and respond-\ning to change over following a plan”. None of these values is inherently in conflict \nwith architectural practices. So why has the belief arisen—at least in some circles—\nthat the two sets of practices are somehow incompatible? The crux of the matter is \nthe one principle on which Agile practices and architectural practices differ.\nThe  original  creators  of  the  Agile  Manifesto  described  12  principles  behind  \nthe manifesto. While 11 of these are fully compatible with architectural practices, \none of them is not: “The best architectures, requirements, and designs emerge from","metadata":{"id":635}}],["246f65f7-003c-4308-8af4-39e51e750c49",{"pageContent":"the manifesto. While 11 of these are fully compatible with architectural practices, \none of them is not: “The best architectures, requirements, and designs emerge from \nself-organizing teams”. While this principle may have held true for small and per-\nhaps even medium-sized projects, we are unaware of any cases where it has been \nsuccessful in large projects, particularly those with complex requirements and dis-\ntributed development. The heart of the problem is this: Software architecture design \nis “up-front” work. You could always just start a project by coding and doing mini-\nmal or no up-front analysis or design. This is what we call the emergent approach, \nas  shown  in  Figure  9.3b.  In  some  cases—small  systems,  throw-away  prototypes,  \nsystems  where  you  have  little  idea  of  the  customer’s  requirements—this  may,  in  \nfact,  be  the  optimal  decision.  At  the  opposite  extreme,  you  could  attempt  to  col-","metadata":{"id":636}}],["b3f37d19-69cf-4d90-9670-e28b72a5731e",{"pageContent":"systems  where  you  have  little  idea  of  the  customer’s  requirements—this  may,  in  \nfact,  be  the  optimal  decision.  At  the  opposite  extreme,  you  could  attempt  to  col-\nlect  all  the  requirements  up  front,  and  from  that  synthesize  the  ideal  architecture,  \nwhich you would then implement, test, and deploy. This so-called Big Design Up \nFront approach (BDUF; Figure 9.3a) is usually associated with the classic Water-\nfall  model  of  software  development.  The  Waterfall  model  has  fallen  out  of  favor  \nover the past decade due to its complexity and rigidity, which led to many well-doc-\numented  cases  of  cost  overruns,  schedule  overruns,  and  customer  dissatisfaction.  \nWith respect to architectural design, the downside of the BDUF approach is that it \ncan end up producing an extensively documented but untested design that may not \nbe  appropriate.  This  occurs  because  problems  in  the  design  are  often  discovered","metadata":{"id":637}}],["9001b450-50c9-48d6-8f91-f5546ca7cee4",{"pageContent":"can end up producing an extensively documented but untested design that may not \nbe  appropriate.  This  occurs  because  problems  in  the  design  are  often  discovered  \nlate and may require a lot of rework, or the original design may end up being ig-\nnored and the true architecture is not documented.\nwww.EBooksWorld.ir\n198 Chapter 9—The Architecture Design Process in the Organization\n(a) BDUF Approach(b) Emergent Approach\n(c) Iteration 0 Approach\nProject Iterations\nDesign Effort\nTime\nTimeTime\nProject Iterations\nDesign EffortDesign Effort\nFIGURE 9.3 Three approaches to architectural design\nClearly, neither of these extremes makes sense for most real-world projects, \nwhere  some  (but  not  all)  of  the  requirements  are  well  understood  up  front  but  \nthere  is  also  a  risk  of  doing  too  much  too  soon  and  hence  becoming  locked  in  \nto a solution that will inevitably need to be modified, at significant cost. So the","metadata":{"id":638}}],["cfba0f42-851e-4ad2-bbcd-3cfa6406bbee",{"pageContent":"there  is  also  a  risk  of  doing  too  much  too  soon  and  hence  becoming  locked  in  \nto a solution that will inevitably need to be modified, at significant cost. So the \ntruly interesting question is this: How much up-front work, in terms of require-\nments analysis, risk mitigation, and architecture, should a project do? Boehm and \nTurner have presented evidence arguing that there is no single right answer to this \nquestion, but that you can find a “sweet spot” for any given project. The “right” \namount of project work depends on several factors, with the most dominant be-\ning project size, but other important factors include requirements complexity, re-\nquirements volatility (related to the precedentedness of the domain), and degree \nof distribution of development.\nSo how do architects achieve the right amount of agility? How do they find \nthe  right  balance  between  up-front  work  and  technical  debt  leading  to  rework?  \nwww.EBooksWorld.ir","metadata":{"id":639}}],["71e7a4bc-7740-4514-9b27-4bbd8585466f",{"pageContent":"So how do architects achieve the right amount of agility? How do they find \nthe  right  balance  between  up-front  work  and  technical  debt  leading  to  rework?  \nwww.EBooksWorld.ir\n9.1 Architecture Design and the Development Life Cycle 199\nFor  small,  simple  projects,  no  up-front  work  on  architecture  is  justifiable.  It  is  \neasy and relatively inexpensive to turn on a dime and refactor. In projects where \nthere  is  some  understanding  of  the  requirements,  begin  by  performing  a  few  \nADD iterations. These design iterations can focus on choosing the major archi-\ntectural  patterns  (including  a  reference  architecture,  if  one  is  appropriate)  and  \nframeworks.  This  is  the  iteration  0  approach  depicted  in  Figure  9.3c.  This  will  \nhelp  to  structure  the  project,  define  work  assignments  and  team  formation,  and  \naddress  the  most  critical  quality  attributes.  If  and  when  requirements  change—","metadata":{"id":640}}],["0d6ce167-e3d5-428e-983f-905f3fc1d205",{"pageContent":"help  to  structure  the  project,  define  work  assignments  and  team  formation,  and  \naddress  the  most  critical  quality  attributes.  If  and  when  requirements  change—\nparticularly if these are driving quality attribute requirements—adopt a practice \nof Agile experimentation, where spikes are used to address new requirements. A \nspike is a time-boxed task that is created to answer a technical question or gather \ninformation; it is not intended to lead to a finished product. Spikes are developed \nin a separate branch and, if successful, merged into the main branch of the code. \nIn this way, emerging requirements can be welcomed and managed without being \ntoo disruptive to the overall process of development.\nAgile architecture practices, however, help to tame some of the complexity, \nnarrowing  the  cone  of  uncertainty  and  hence  reducing  project  risk.  A  reference  \narchitecture  defines  families  of  technology  components  and  their  relationships.","metadata":{"id":641}}],["a216ad45-14db-4bb2-8bc1-f42b95ead032",{"pageContent":"narrowing  the  cone  of  uncertainty  and  hence  reducing  project  risk.  A  reference  \narchitecture  defines  families  of  technology  components  and  their  relationships.  \nIt guides integration and indicates where abstraction should be built into the ar-\nchitecture, to help reduce rework when a new technology (from within a family) \nreplaces an existing one. Agile spikes allow prototypes to be built quickly and to \n“fail fast”, thereby guiding the eventual selection of technologies to be included \non the main development branch.\n9.1.2.2 Rational Unified Process\nThe  Rational  Unified  Process  (RUP)  is  a  software  development  process  frame-\nwork  that  puts  a  strong  emphasis  on  architecture.  In  the  RUP  (which  we  also  \ndiscussed in Section 7.3), development projects are divided in four major phases, \nwhich are carried out sequentially; within these phases, a number of iterations are \nperformed. The four phases of the RUP are as follows:","metadata":{"id":642}}],["5e5bce74-d274-484b-ab30-1773b10ee84a",{"pageContent":"which are carried out sequentially; within these phases, a number of iterations are \nperformed. The four phases of the RUP are as follows:\n§\tInception. In this first phase, the goal is to achieve concurrence among proj-\nect stakeholders. During this phase the scope of the project and a business \narchitecture are defined. Also, a candidate architecture is established. This \nphase is the equivalent to the pre-sales phase discussed previously.\n§\tElaboration. In the second phase, the goal is to baseline the architecture of \nthe system and to produce architectural prototypes.\n§\tConstruction. In the third phase, the goal is to incrementally develop the \nsystem from the architecture that was defined in the previous phase.\n§\tTransition. In the fourth phase, the goal is to ensure that the system is ready \nfor delivery. The system is transitioned from the development environment \nto its final operation environment.\nWe could argue that, from the elaboration phase until the end of the project,","metadata":{"id":643}}],["aa35b03a-a81e-49cf-bd8e-0c1d4c602855",{"pageContent":"for delivery. The system is transitioned from the development environment \nto its final operation environment.\nWe could argue that, from the elaboration phase until the end of the project, \nRUP  intrinsically  follows  the  iteration  0  approach  described  earlier.  RUP  also  \nwww.EBooksWorld.ir\n200 Chapter 9—The Architecture Design Process in the Organization\nprovides some guidance with respect to architectural design, although this guid-\nance is far less detailed than that offered by ADD. As a consequence, ADD can \nbe  used  as  a  complement  to  the  RUP.  ADD  iterations  can  be  performed  during  \ninception  to  establish  the  candidate  architecture  by  following  the  approach  de-\nscribed  in  Section  9.1.1.  Furthermore,  during  the  elaboration  phase,  the  initial  \narchitecture is taken as a starting point for performing additional design iterations \nuntil an architecture that can be baselined is produced. During construction, ad-","metadata":{"id":644}}],["778e6938-87f1-4e2a-ae21-151996055864",{"pageContent":"architecture is taken as a starting point for performing additional design iterations \nuntil an architecture that can be baselined is produced. During construction, ad-\nditional ADD iterations may be performed as part of the development iterations.\n9.1.2.3 Team Software Process\nThe Team  Software  Process  (TSP)  is  a  development  process  that  strongly  em-\nphasizes  quality  and  measurement.  A  TSP  software  project  proceeds  through  a  \nseries  of  development  cycles,  where  each  cycle  begins  with  a  planning  process  \ncalled a launch and ends with a closing process called a postmortem. Within each \ndevelopment  cycle,  activities  belonging  to  different  phases  can  be  performed.  \nThese phases include requirements (REQ), high-level design (HLD), implemen-\ntation (IMPL), and testing (TEST). The REQ phase of TSP focuses on producing \na complete system requirements specification (SRS) document. The main goal of","metadata":{"id":645}}],["d35f472a-a014-4fd3-9385-5101d958d26b",{"pageContent":"tation (IMPL), and testing (TEST). The REQ phase of TSP focuses on producing \na complete system requirements specification (SRS) document. The main goal of \nthe HLD phase is to produce a high-level design that will guide product imple-\nmentation. This high-level design must define the components (i.e., modules) that \nconstitute the system and that have to be designed and developed independently \nfollowing  the  Personal  Software  Process  (PSP)  in  the  IMPL  phase.  Finally,  the  \nTEST  phase  focuses  on  performing  integration  and  system  testing  and  on  pre-\nparing  the  delivery  of  the  system.  Note  that  the  life-cycle  model  of  a  particular  \nproject  (Waterfall,  incremental)  is  defined  by  the  phases  that  are  performed  in  \neach development cycle: An iterative project will typically include activities from \nall four phases in a single development cycle.\nThe  TSP  does  not  give  full  consideration  to  software  architecture  develop-","metadata":{"id":646}}],["31c81576-930a-4d40-8eac-dae2090fe1d6",{"pageContent":"all four phases in a single development cycle.\nThe  TSP  does  not  give  full  consideration  to  software  architecture  develop-\nment. For instance, none of the roles defined in the TSP is that of software architect. \nThere is also no emphasis on quality attributes in the REQ phase. Furthermore, the \nprocess script for the HLD phase (see Table 9.1) does not provide detailed guidance \non how to design the system architecture. These issues can, however, be addressed \nby introducing ADD, and other architectural practices, into TSP.\nADD can be used in the context of TSP in a straightforward way. In step 1 of \nthe HLD script, ADD can be used to produce the overall product design concept, \nsimilar to what was discussed for the pre-sales process. Furthermore, in each de-\nvelopment  cycle,  one  or  more  ADD  iterations  can  be  performed  (steps  4  and  5  \nof  the  HLD  script).  Also,  the  HLD  phase  should  consider  a  separation  between","metadata":{"id":647}}],["9a8f19cd-3f09-41a5-9070-5131f13b898a",{"pageContent":"velopment  cycle,  one  or  more  ADD  iterations  can  be  performed  (steps  4  and  5  \nof  the  HLD  script).  Also,  the  HLD  phase  should  consider  a  separation  between  \narchitectural design and element interaction design (discussed in Section 2.2.2). \nA TSP development cycle can involve a few ADD iterations followed by the ele-\nment interaction design activities that include identification of elements and their \ninterfaces.  These  interfaces  are  later  used  in  the  development  phase  (IMPL)  for  \nperforming detailed design and development of the elements.\nwww.EBooksWorld.ir\n9.1 Architecture Design and the Development Life Cycle 201\nTABLE 9.1 Summary of TSP High-Level Design (HLD) Script Steps\nStepActivitiesSummary\n  1Structural designAn overall product design concept is produced. It \nincludes the system architectural components and \nthe product components, principal functions, and \ninterfaces.\n  2Development \nstrategy\nA development strategy is established. The strategy","metadata":{"id":648}}],["176520e8-4eec-4de6-a27d-e6267a623844",{"pageContent":"includes the system architectural components and \nthe product components, principal functions, and \ninterfaces.\n  2Development \nstrategy\nA development strategy is established. The strategy \nincludes the sequence of component development and \nintegration and the reuse and testing strategies.\n  3High-level design \nstrategy\nIn this step, a decision is made about whether to design \nthe system in a single design cycle or in multiple cycles \n(focusing, for example, on one layer at a time).\n  4First cycle designThe requirements are reviewed and the class \ndefinitions, relationships, and transition diagrams are \nproduced.\n  5Subsequent \ndesign cycles\nDesign issues from previous cycles are assessed \nand the current design is reviewed. Additional class \ndefinitions, relationships, and transition diagrams are \nproduced.\n  6Integration and \nsystem test \nstrategies\nStrategies for testing are established.\n  7System design \nspecification \n(SDS)\nA design document is produced.\n  8Design \nwalkthrough","metadata":{"id":649}}],["f86ca79d-082d-4c5d-ad6a-a326ad5f2383",{"pageContent":"produced.\n  6Integration and \nsystem test \nstrategies\nStrategies for testing are established.\n  7System design \nspecification \n(SDS)\nA design document is produced.\n  8Design \nwalkthrough\nA walk-through of the high-level design is performed \nwith different stakeholders.\n  9Design inspectionThe materials produced as a result of this phase are \ninspected.\n10SDS baselineThe design specification is put into a baseline.\n11PostmortemA postmortem of the phase is performed.\n9.1.2.4 DevOps\nDevOps is a natural outgrowth of the Agile mindset. DevOps refers to a set of prac-\ntices that help achieve continuous delivery of software. Such practices are intended \nto  reduce  the  time  between  making  a  change  to  a  system  and  the  change  being  \nplaced into normal production, while ensuring high quality. This term intentionally \nblurs  the  distinction  between  “development”  and  “operations”.  While  DevOps  is  \nnot inherently tied to architectural practices, if architects do not consider DevOps","metadata":{"id":650}}],["c656cda2-ed62-4717-8197-4bc3d75455de",{"pageContent":"blurs  the  distinction  between  “development”  and  “operations”.  While  DevOps  is  \nnot inherently tied to architectural practices, if architects do not consider DevOps \nas  they  design,  build,  and  evolve  the  system,  then  critical  activities  such  as  con-\ntinuous  build  integration,  automated  test  execution,  high  availability,  and  scalable  \nperformance  will  be  more  challenging  and  less  efficient.  By  embracing  DevOps,  \nsmall  iterations  are  supported  and  encouraged,  creating  an  environment  where  \nwww.EBooksWorld.ir\n202 Chapter 9—The Architecture Design Process in the Organization\nAgile spikes are easy to create, deploy, and test, thereby providing crucial feedback \nto the architect.\nFor example, a tightly coupled architecture can become a barrier to contin-\nuous integration because even small changes may require a rebuild of the entire \nsystem,  which  limits  the  number  of  builds  possible  in  a  day.  To  fully  automate","metadata":{"id":651}}],["9dfd6756-7868-49d3-a5f8-cf7cc3b40bd1",{"pageContent":"uous integration because even small changes may require a rebuild of the entire \nsystem,  which  limits  the  number  of  builds  possible  in  a  day.  To  fully  automate  \ntesting, the system needs to provide architectural (system-wide) test capabilities \nsuch as interfaces to record, play back, and control system state. To support high \navailability, the system must be self-monitoring, requiring architectural capabili-\nties such as self-test, ping/echo, heartbeat, monitor, hot spares, and so forth.\nIn large-scale systems, DevOps can be achieved only with architectural sup-\nport.  Any  ad  hoc  or  manual  process  would  put  the  growth  and  success  of  such  \na system at risk. Adopting the DevOps approach requires a small change in the \nmindset  of  an  architect.  Instead  of  just  designing  the  system,  you  now  need  to  \nthink about the design of the entire deployment pipeline. Is the pipeline easy to","metadata":{"id":652}}],["30fd440a-2241-4a88-9c18-512fb9677b48",{"pageContent":"mindset  of  an  architect.  Instead  of  just  designing  the  system,  you  now  need  to  \nthink about the design of the entire deployment pipeline. Is the pipeline easy to \nchange, and can these changes be deployed at the click of a button? Is the pipe-\nline easy to scale? Is it easy to test? Fortunately, there are good answers to all of \nthese questions, and they do not require a distinct mindset or strategy. ADD can \nhelp  design  a  system  to  achieve  DevOps  goals,  in  exactly  the  same  ways  and  \nemploying  exactly  the  same  design  primitives  as  in  design  for  any  other  driver.  \nThe different aspects that need to be considered to allow DevOps to be performed \nsuccessfully can be included as part of the system drivers, either as architectural \nconcerns  or  as  quality  attributes.  The  design  concepts  that  help  us  to  achieve  \nmodifiability or testability or scalability or high availability in a system can also","metadata":{"id":653}}],["33078e78-dcc1-40ca-aceb-6f285d4afb02",{"pageContent":"concerns  or  as  quality  attributes.  The  design  concepts  that  help  us  to  achieve  \nmodifiability or testability or scalability or high availability in a system can also \nbe applied to the deployment pipeline. To slightly misquote Gertrude Stein, “Ar-\nchitecture is architecture is architecture”.\n9.2 Organizational Aspects\nIn addition to the choice of a specific development method and the introduction \nof  a  design  method  such  as  ADD  into  this  method,  other  aspects  of  the  design  \nprocess  can  be  supported  by  a  software  development  organization  to  facilitate  \ndesign activities. Here we briefly discuss some of these aspects.\n9.2.1 Designing as an Individual or as a Team\nIn large and complex projects, it seems straightforward that an architecture team \nshould be responsible for performing the design. Even in smaller projects, how-\never,  you  may  find  that  having  more  than  one  person  participate  in  the  design","metadata":{"id":654}}],["9c0af075-cf3a-4676-9639-f12b6e4b3c86",{"pageContent":"should be responsible for performing the design. Even in smaller projects, how-\never,  you  may  find  that  having  more  than  one  person  participate  in  the  design  \nprocess  yields  important  advantages.  You  can  decide  if  only  one  person  is  the  \narchitect  and  the  others  are  observers  (as  in  the  practice  of  pair  programming)  \nwww.EBooksWorld.ir\n9.2 Organizational Aspects 203\nor if the group actively collaborates on design decisions (although even here we \nrecommend that you have one lead architect).\nThere are various benefits from this approach:\n§\tTwo (or more) heads can be better than one, particularly if the design \nproblem that you are trying to solve is different from ones that you have \naddressed before.\n§\tDifferent people can have different areas of expertise that are useful in the \ndesign of the architecture. For example, you might have distinct software \nand infrastructure architects, or people who specialize in different domains","metadata":{"id":655}}],["f4ac7b75-e648-434a-b911-5b23936425dc",{"pageContent":"design of the architecture. For example, you might have distinct software \nand infrastructure architects, or people who specialize in different domains \nor different types of design concepts.\n§\tDesign decisions are reflected upon and reviewed as they are being made \nand, as a consequence, can be corrected immediately.\n§\tLess experienced people can participate in the design process, which can be \nan excellent mentoring practice.\nYou should, however, be aware of certain difficulties with this approach:\n§\tDesign by committee can be complicated if agreement is not achieved in \na reasonable time frame. The search for consensus can lead to “analysis \nparalysis”.\n§\tThe cost of design increases and, in many cases, the time for design also \nincreases.\n§\tManaging the logistics can be complex, because this approach requires the \nregular availability of the group of people.\n§\tYou may encounter personality and political conflicts, resulting in resent-","metadata":{"id":656}}],["04788715-8f01-47df-997f-ed12691bb08a",{"pageContent":"§\tManaging the logistics can be complex, because this approach requires the \nregular availability of the group of people.\n§\tYou may encounter personality and political conflicts, resulting in resent-\nment or hurt feelings or in design decisions being heavily influenced by the \nperson who shouts longest and loudest (“design by bullying”).\n9.2.2 Using a Design Concepts Catalog in Your Organization\nDesign concepts are used in the design process to satisfy drivers (see Section 2.5). \nIn  general,  drivers  can  be  seen  as  recurring  design  problems.  Whether  it  is  the  \nconcern  of  structuring  an  application,  allocating  functionality,  or  satisfying  a  \nparticular  quality  attribute,  these  drivers  have  most  certainly  been  addressed  in  \nother systems previously. Furthermore, people have taken the time to document \nways to address these design problems or to develop components that serve this \npurpose. As we saw in Section 3.4, the selection of design concepts is one of the","metadata":{"id":657}}],["ebd4fef2-a29f-4774-aa62-91315bb7f178",{"pageContent":"ways to address these design problems or to develop components that serve this \npurpose. As we saw in Section 3.4, the selection of design concepts is one of the \nmost challenging aspects of the design process. This problem is exacerbated by \nthe fact that information is scattered in many places: Architects usually need to \nconsult several pattern and tactics catalogs and do extensive research to find the \ndesign concepts that can be considered and used.\nOne  possible  way  to  resolve  this  issue  is  the  creation  of  design  concepts  \ncatalogs. These catalogs group collections of design concepts for particular ap-\nplication domains. Such catalogs are intended to facilitate the identification and \nwww.EBooksWorld.ir\n204 Chapter 9—The Architecture Design Process in the Organization\nselection  of  design  concepts  when  performing  design.  They  are  also  useful  in  \nenhancing  consistency  in  the  designs  across  the  organization.  For  example,  de-","metadata":{"id":658}}],["149ca3d4-b16c-4715-af88-07027e3023ca",{"pageContent":"selection  of  design  concepts  when  performing  design.  They  are  also  useful  in  \nenhancing  consistency  in  the  designs  across  the  organization.  For  example,  de-\nsigners may be required to use the technologies in a particular catalog as much \nas possible because this facilitates estimation, reduces learning curves, and may \nlead to opportunities for reuse. Catalogs can also be useful for training purposes.\nAn example of a design concepts catalog appears in Appendix A. This cata-\nlog is oriented toward the design of enterprise applications. A similar catalog for \nthe Big Data domain could be created from the technology families and specific \ntechnologies illustrated in Figure 2.10 (Section 2.5.5).\nThe  creation  of  these  catalogs  involves  considerable  effort  and,  once  cre-\nated,  they  should  be  maintained  as  new  design  concepts,  and  particularly  new  \ntechnologies, are introduced or removed in the organization. This effort is worth-","metadata":{"id":659}}],["9a9a4162-7b9c-46a2-a4af-0e23769b174a",{"pageContent":"ated,  they  should  be  maintained  as  new  design  concepts,  and  particularly  new  \ntechnologies, are introduced or removed in the organization. This effort is worth-\nwhile, however, as these catalogs are a valuable organizational asset.\n9.3    Summary\nIn  this  chapter  we  discussed  how  ADD  can  be  used  in  relation  to  several  orga-\nnizational  aspects.  ADD  can  be  used  from  the  project’s  inception,  when  a  pre-\nsales  proposal  is  developed,  to  facilitate  estimation  using  standard  components.  \nAs the project evolves, ADD can be used in conjunction with any modern soft-\nware development life-cycle method. In general, ADD is a valuable complement \nto  life-cycle  methods  that  do  not  provide  detailed  guidance  on  how  to  perform  \narchitectural design.\nWe also briefly reviewed some related concerns, such as the composition of \nthe  design  team  and  the  development  of  organizational  assets,  such  as  a  design","metadata":{"id":660}}],["8e7dacc6-1aae-4564-94c3-75e5cda66361",{"pageContent":"architectural design.\nWe also briefly reviewed some related concerns, such as the composition of \nthe  design  team  and  the  development  of  organizational  assets,  such  as  a  design  \nconcepts catalog, that are useful during the design process.\n9.4 Further Reading\nOrganizational structure and its influences on software architecture are addressed \nin the field of enterprise architecture management. Enterprise architecture frame-\nworks  are  discussed  in  F.  Ahlemann  et  al.  (Eds.),  Strategic  Enterprise  Archi-\ntecture  Management:  Challenges,  Best  Practices,  and  Future  Developments, \nSpringer-Verlag Berlin Heidelberg, 2012.\nA  nice  set  of  articles  looking  at  the  relationship  between  architecture  and  \nAgile methods can be found in the April 2010 IEEE Software magazine special \nissue on this topic.\nA  number  of  studies  have  looked  at  how  architecture  and  agility  meth-\nods  complement  and  support  each  other,  such  as  S.  Bellomo,  I.  Gorton,  and","metadata":{"id":661}}],["03498e70-10c5-4f83-8f64-182a523fa814",{"pageContent":"issue on this topic.\nA  number  of  studies  have  looked  at  how  architecture  and  agility  meth-\nods  complement  and  support  each  other,  such  as  S.  Bellomo,  I.  Gorton,  and  \nwww.EBooksWorld.ir\n9.4 Further Reading 205\nR.  Kazman,  “Insights  from  15  Years  of  ATAM  Data:  Towards  Agile  Architec-\nture”, IEEE Software, September/October 2015, and S. Bellomo, R. Nord, and I. \nOzkaya, “A Study of Enabling Factors for Rapid Fielding: Combined Practices to \nBalance Speed and Stability”, Proceedings of ICSE 2013, 982–991, 2013.\nBarry Boehm and Richard Turner have taken an empirical look at the topic \nof  the  relationship  between  agility  and  “discipline”  (not  just  architecture)  in  \ntheir book Balancing Agility and Discipline: A Guide for the Perplexed (Boston: \nAddison-Wesley, 2004).\nThe  practice  of  creating  architectural  “spikes”  as  a  means  of  resolving  \nuncertainty  in  Agile  sprints  is  discussed  in  T.  C.  N.  Graham,  R.  Kazman,  and","metadata":{"id":662}}],["abae19bb-c7a0-438b-9029-48235e6f6a10",{"pageContent":"Addison-Wesley, 2004).\nThe  practice  of  creating  architectural  “spikes”  as  a  means  of  resolving  \nuncertainty  in  Agile  sprints  is  discussed  in  T.  C.  N.  Graham,  R.  Kazman,  and  \nC.  Walmsley,  “Agility  and  Experimentation:  Practical  Techniques  for  Resolv-\ning Architectural Tradeoffs”, Proceedings  of  the  29th  International  Conference  \non  Software  Engineering  (ICSE  29),  (Minneapolis,  MN),  May  2007.  A  general  \ndiscussion of spikes can be found at https://www.scrumalliance.org/community/\narticles/2013/march/spikes-and-the-effort-to-grief-ratio.\nMany  practitioners  and  researchers  have  thought  deeply  about  how  Agile  \nmethods and architectural practices fit together. Some of the best examples of this \nthinking can be found in the following sources:\n§\tS. Brown. Software Architecture for the Developers. LeanPub, 2013.\n§\tJ. Bloomberg. The Agile Architecture Revolution. Wiley CIO, 2013.","metadata":{"id":663}}],["7b011b4c-527c-41fc-a6b4-7a6508850611",{"pageContent":"thinking can be found in the following sources:\n§\tS. Brown. Software Architecture for the Developers. LeanPub, 2013.\n§\tJ. Bloomberg. The Agile Architecture Revolution. Wiley CIO, 2013.\n§\tDean Leffingwell. “Scaled Agile Framework”. http://scaledagileframework.\ncom/\n§\tA. Cockburn. “Walking Skeleton”. http://alistair.cockburn.us/\nWalking+skeleton\n§\t“Manifesto for Agile Software Development”. http://agilemanifesto.org/\n§\tScott Ambler and Mark Lines. “Scaling Agile Software Development: Dis-\nciplined Agility at Scale”. http://disciplinedagileconsortium.org/Resources/\nDocuments/ScalingAgileSoftwareDevelopment.pdf\nAn extensive treatment of estimation techniques, including estimation using \nstandard components, is given in S. McConnell, Software Estimation: Demystify-\ning the Black Art, Microsoft Press, 2006.\nAn overview of the Team Software Process can be found in W. Humphrey, \nThe Team Software Process\nSM\n (TSP\nSM\n), Technical Report CMU/SEI-2000-TR-023,","metadata":{"id":664}}],["51e30c8e-d7bc-404b-b140-963d690c16e7",{"pageContent":"ing the Black Art, Microsoft Press, 2006.\nAn overview of the Team Software Process can be found in W. Humphrey, \nThe Team Software Process\nSM\n (TSP\nSM\n), Technical Report CMU/SEI-2000-TR-023, \nNovember 2000. Extensive details about TSP can be found in the different books \nwritten by Humphrey about this process.\nThe integration of ADD 2.0 (as well as other architecture development meth-\nods) with RUP, is discussed in R. Kazman, P. Kruchten, R. Nord, and J. Tomayko, \n“Integrating  Software-Architecture-Centric  Methods  into  the  Rational  Unified  \nProcess”, Technical Report CMU/SEI-2004-TR-011, July 2004.\nThere  are  now  several  excellent  books  on  the  topic  of  DevOps,  such  \nas  L.  Bass,  I.  Weber,  and  L.  Zhu,  DevOps:  A  Software  Architect’s  Perspec-\ntive,  Addison-Wesley,  2015.  A  set  of  architectural  tactics  for  DevOps  was  de-\nscribed  in  H-M  Chen,  R.  Kazman,  S.  Haziyev,  V.  Kropov,  and  D.  Chtchourov,  \nwww.EBooksWorld.ir","metadata":{"id":665}}],["7ac1155c-9550-4ab4-9cc1-6d849afd2504",{"pageContent":"tive,  Addison-Wesley,  2015.  A  set  of  architectural  tactics  for  DevOps  was  de-\nscribed  in  H-M  Chen,  R.  Kazman,  S.  Haziyev,  V.  Kropov,  and  D.  Chtchourov,  \nwww.EBooksWorld.ir\n206 Chapter 9—The Architecture Design Process in the Organization\n“Architectural Support for DevOps in a Neo-Metropolis BDaaS Platform”, IEEE \n34th Symposium on Reliable Distributed Systems Workshop (SRDSW), Montreal, \nCanada, September 2015.\nConsiderable  attention  has  been  given  to  the  problem  of  architecture  \nknowledge  representation  and  management.  For  a  good  overview  of  this  area,  \nsee P. Kruchten, P. Lago, and H. Van Vliet, “Building Up and Reasoning About \nArchitectural Knowledge”, in Quality of Software Architectures, Springer, 2006. \nFor a perspective on tools for architecture knowledge management, see A. Tang, \nP. Avgeriou, A. Jansen, R. Capilla, and M. Ali Babar, “A Comparative Study of \nArchitecture Knowledge Management Tools”, Journal of Systems and Software,","metadata":{"id":666}}],["b8c69941-f8c3-4097-926d-f549a1fdc11b",{"pageContent":"P. Avgeriou, A. Jansen, R. Capilla, and M. Ali Babar, “A Comparative Study of \nArchitecture Knowledge Management Tools”, Journal of Systems and Software, \n83(3):352–370, 2010.\nwww.EBooksWorld.ir\n207\n10\nFinal Words\nIn this chapter we reflect, once again, on the nature of design and why we need \nmethods for design. This is, after all, the major point of this book! And we leave \nyou with a few words about where to go with the information and skills that you \nhave gleaned from reading this book.\n10.1 On the Need for Methods\nGiven that you have prevailed and reached this final chapter, we can assume that \nyou  are  committed  to  being  a  professional  software  architect.  Being  a  profes-\nsional means that you can perform (at least) adequately and repeatedly in all sorts \nof contexts. To achieve this level of performance, you need methods.\nWe all need methods when we are performing complex tasks that have se-\nrious consequences if we get them wrong. Consider this: Jet pilots and surgeons","metadata":{"id":667}}],["aeddf4be-b886-47b2-a4cb-6c584f5cfda0",{"pageContent":"We all need methods when we are performing complex tasks that have se-\nrious consequences if we get them wrong. Consider this: Jet pilots and surgeons \nare two of the most highly trained groups of professionals in the world, and yet \nthey  use  checklists  and  standardized  procedures  for  every  important  task  that  \nthey perform. Why? Because the consequences of making a mistake are serious. \nYou probably will not be designing the architectures for systems that have life-\nand-death consequences. Even so, the systems that you do design, particularly if \nthey are large and complex, may very well have consequences for the health and \nwell-being of your organization. If you are designing a throwaway prototype or a \nwww.EBooksWorld.ir\n208 Chapter 10—Final Words\ntrivial system, perhaps an explicit architecture design step may be omitted. If you \nare designing the nth variant of a system that you have created over and over in","metadata":{"id":668}}],["88d7a84a-3c69-4e72-ade9-a14d10457559",{"pageContent":"208 Chapter 10—Final Words\ntrivial system, perhaps an explicit architecture design step may be omitted. If you \nare designing the nth variant of a system that you have created over and over in \nthe past, perhaps architecture design is little more than a cut-and-paste from your \nprior experiences.\nBut  if  the  system  you  are  charged  with  creating  or  evolving  is  nontrivial  \nand if there is risk associated with its creation, then you owe it to yourself, you \nowe it to your organization, and you owe it to your profession to do the best job \nthat you can in this most critical step in the software development life cycle. To \nachieve that goal, you need a method. Methods help to ensure uniformity, consis-\ntency, and completeness. Methods help you take the right steps and ask the right \nquestions.\nOf course, no method can substitute for proper training and education. No one \nwould  trust  a  novice  pilot  at  the  controls  of  a  787  or  a  first-year  medical  student","metadata":{"id":669}}],["e560bf65-ac47-4ec1-a148-bccfdea53133",{"pageContent":"questions.\nOf course, no method can substitute for proper training and education. No one \nwould  trust  a  novice  pilot  at  the  controls  of  a  787  or  a  first-year  medical  student  \nwielding a scalpel in an operating theater, armed only with a method or a checklist. \nA method, however, is a key to producing high-quality results repeatedly. And this \nis, after all, what we all desire as software engineering professionals.\nFred Books, writing about the design process, said:\nAny systematization of the design process is a great step forward compared to “Let’s \njust start coding, or building”. It provides clear steps for planning a design project. \nIt  furnishes  clearly  definable  milestones  for  planning  a  schedule  and  for  judging  \nprogress.  It  suggests  project  organization  and  staffing.  It  helps  communication  \nwithin  the  design  team,  giving  everyone  a  single  vocabulary  for  the  activities.  It","metadata":{"id":670}}],["64b84813-3948-4cfe-9efe-e55e23b707aa",{"pageContent":"progress.  It  suggests  project  organization  and  staffing.  It  helps  communication  \nwithin  the  design  team,  giving  everyone  a  single  vocabulary  for  the  activities.  It  \nwonderfully helps communication between the team and its manager, and between \nthe manager and other stakeholders. It is readily teachable to novices. It tells novices \nfacing their first design assignments where to begin.\nDesign  is  just  too  important  to  be  left  to  chance.  And  there  needs  to  be  a  \nbetter way of getting good at design than “shoot yourself in the foot repeatedly”. \nAs the Nobel Prize–winning scientist Herbert Simon wrote in 1969, “Design . . . \nis the core of all professional training; it is the principal mark that distinguishes \nthe professions from the sciences. Schools of engineering, as well as schools of \narchitecture, business, education, law, and medicine, are all centrally concerned \nwith the process of design”. Simon went on to say that lack of professional com-","metadata":{"id":671}}],["8d595273-3dff-4d8f-ab10-60d7b4b455da",{"pageContent":"architecture, business, education, law, and medicine, are all centrally concerned \nwith the process of design”. Simon went on to say that lack of professional com-\npetence is caused by the relative neglect of design in universities’ curricula. This \ntrend is, we are happy to note, gradually reversing, but nearly 50 years later it is \nstill a cause for concern.\nIn this book we have provided you with a road-tested method—ADD 3.0—\nfor doing architectural design. Methods are useful in that they provide guidance \nfor  the  novice  and  reassurance  for  the  expert.  Like  any  good  method,  ADD  3.0  \nhas a set of steps, and these steps have been updated somewhat from prior ver-\nsions of ADD. But just as important, we have focused on the broader architecture \nlife cycle and shown how some changes to the design process can help make your \nlife as an architect better, and provide you with better outcomes. For example, we \nwww.EBooksWorld.ir\n10.2 Next Steps 209","metadata":{"id":672}}],["f2f85de5-b206-4a02-8ba8-5dd04bea151f",{"pageContent":"life cycle and shown how some changes to the design process can help make your \nlife as an architect better, and provide you with better outcomes. For example, we \nwww.EBooksWorld.ir\n10.2 Next Steps 209\nhave expanded the set of inputs that you need to think about to include things like \ndesign purpose and architectural concerns. This broader view helps you create an \narchitecture that not only meets your customer’s requirements, but also is aligned \nwith the business needs of your team and your organization. In addition, we have \nshown that design can and should be guided by a “design concepts catalog”—a \ncorpus of reusable architectural knowledge consisting of reference architectures, \npatterns,  tactics,  and  externally  developed  components  such  as  frameworks  and  \ntechnology  families.  By  cataloging  these  concepts,  design  can  be  made  more  \npredictable and repeatable. Finally, we have argued that design should be docu-","metadata":{"id":673}}],["18529eb8-19b6-421c-bee3-fbfba4b84a37",{"pageContent":"technology  families.  By  cataloging  these  concepts,  design  can  be  made  more  \npredictable and repeatable. Finally, we have argued that design should be docu-\nmented, perhaps informally in sketches, and should be accompanied by a consis-\ntent practice of analyzing the decisions made.\nIf we are to conceive of ourselves as software engineers, we need to take the \ntitle  of  “engineer”  seriously.  No  mechanical  or  electrical  or  structural  engineer  \nwould commit significant resources to a design that was not based on sound princi-\nples and components, or that was not analyzed and documented. We think that soft-\nware  engineering  in  general,  and  software  architecture  specifically,  should  strive  \nfor similar goals. We are not “artistes”, for whom creativity is paramount; we are \nengineers, so predictability and repeatability should be our most cherished goal.\n10.2 Next Steps\nWhere should you go from here? We see four answers to this question. One an-","metadata":{"id":674}}],["e0d07f6d-774c-45f8-92d3-39aa1cdd05a3",{"pageContent":"engineers, so predictability and repeatability should be our most cherished goal.\n10.2 Next Steps\nWhere should you go from here? We see four answers to this question. One an-\nswer focuses on what you can do as an individual to hone your skills and experi-\nence as an architect. The second answer revolves around how you might engage \nyour  colleagues  to  think  more  consciously  about  architecture  design.  The  third  \nanswer is where your organization can go with a more explicit commitment to ar-\nchitecture design. And the fourth answer is about how you can contribute to your \ncommunity, and to the larger community of software architects.\nOur advice to you, as an individual, about how to proceed is simple: prac-\ntice. Like any other complex skill worth having, your skill as an architect will not \ncome immediately, but your confidence should increase steadily. “Fake it till you \nmake it” is the best advice that we can give. Having a method that you can con-","metadata":{"id":675}}],["3c78a55a-ecf3-40c9-af19-58162c66424b",{"pageContent":"come immediately, but your confidence should increase steadily. “Fake it till you \nmake it” is the best advice that we can give. Having a method that you can con-\nsult, and a ready supply of common design concepts, gives you a solid foundation \non which to “fake it” and learn.\nTo help you practice your skills and to engage your colleagues, we have de-\nveloped an architecture game. This game, which is called “Smart Decisions”, can \nbe found at http://www.smartdecisionsgame.com. It simulates the architecture de-\nsign process using ADD 3.0 and promotes learning about it in a fun, pressure-free \nway. The game is currently focused on the Big Data Analytics \napplication domain, \nsimilar to the extended design example in Chapter 5, but it can be easily adapted \nto other application domains.\nwww.EBooksWorld.ir\n210 Chapter 10—Final Words\nYou  might  also  think  about  next  steps  to  be  taken  in  your  organization.","metadata":{"id":676}}],["19fb0654-ff55-4dcc-9148-d29fdc598158",{"pageContent":"to other application domains.\nwww.EBooksWorld.ir\n210 Chapter 10—Final Words\nYou  might  also  think  about  next  steps  to  be  taken  in  your  organization.  \nYou  can  be  an  agent  for  change.  Even  if  your  company  does  not  “believe  in”  \narchitecture,  you  can  still  practice  many  of  the  ideas  embodied  in  this  book  \nand in ADD. Ensure that your requirements are clear by insisting on response \ngoals  for  your  requirements.  Even  when  facing  tight  deadlines  and  schedule  \npressures, try to get agreement on the major architectural design concepts being \nemployed. Do quick, informal design reviews with colleagues, huddled around \na whiteboard, and ask yourself reflective questions. None of these “next steps” \nneeds to be daunting or hugely time-consuming. And we believe—and our in-\ndustrial  experience  has  shown—that  they  will  be  self-reinforcing.  Better  de-\nsigns will lead to better outcomes, which will lead you and your group and your","metadata":{"id":677}}],["a643a5e3-8d00-4f9d-bc0f-8499754d713c",{"pageContent":"dustrial  experience  has  shown—that  they  will  be  self-reinforcing.  Better  de-\nsigns will lead to better outcomes, which will lead you and your group and your \norganization to want to do more of the same.\nFinally,  you  can  contribute  to  your  local  software  engineering  community,  \nand even to the worldwide community of software architects. You could, for ex-\nample,  play  the  architecture  game  in  a  local  software  engineering  meetup  and  \nthen  share  your  e\nxperiences.  You  could  contribute  case  studies  about  your  suc-\ncesses  and  failures  as  an  architect  with  real-world  projects.  We  strongly  believe  \nthat e\nxample is the best way to teach and while we have provided three case stud-\nies in this book, more is always better. Self-publishing is easy in today’s web.\nHappy architecting!\n10.3 Further Reading\nThe long quotation by Fred Books in this chapter comes from his thought-provoking","metadata":{"id":678}}],["26b49068-0bb2-4e78-b89c-bab0d44f2922",{"pageContent":"Happy architecting!\n10.3 Further Reading\nThe long quotation by Fred Books in this chapter comes from his thought-provoking \nbook The Design of Design: Essays from a Computer Scientist, Pearson, 2010.\nMany of the ideas in this chapter, in this book, and in the field of software \narchitecture in general can be traced back to Herbert Simon’s seminal book on \nthe science of design: The Sciences of the Artificial, MIT Press, 1969.\nwww.EBooksWorld.ir\n211\nA\nA Design Concepts \nCatalog\nThis chapter presents an excerpt from a catalog that groups design concepts that \nare  associated  with  the  domain  of  enterprise  applications,  such  as  the  one  pre-\nsented in the case study in Chapter 4. As opposed to traditional catalogs that list \njust  a  single  type  of  design  concept,  such  as  pattern  catalogs,  the  catalog  pre-\nsented here groups different varieties of related design concepts. In this case, the \ncatalog includes a selection of reference architectures, deployment patterns, de-","metadata":{"id":679}}],["de57e667-c1dc-461c-b445-60f9545384d0",{"pageContent":"sented here groups different varieties of related design concepts. In this case, the \ncatalog includes a selection of reference architectures, deployment patterns, de-\nsign patterns, tactics, and externally developed components (frameworks). Also, \nthe design concepts that are included in this catalog are gathered from different \nsources, reflecting what occurs in real-life design. The design concepts are pre-\nsented in a very succinct way, and the reader looking for more detail should refer \nto the original sources using the references provided at the end of the chapter.\nA.1 Reference Architectures\nReference architectures provide a blueprint for structuring an application (see \nSection 2.5.1). This section is based on the catalog in the Microsoft Application \nArchitecture Guide.\nwww.EBooksWorld.ir\n212 Appendix A—A Design Concepts Catalog\nA.1.1 Web Applications\nThis web application is typically initiated from a web browser that communicates","metadata":{"id":680}}],["0e1a301a-2d7f-4b52-8382-6d1cbcf74a9e",{"pageContent":"Architecture Guide.\nwww.EBooksWorld.ir\n212 Appendix A—A Design Concepts Catalog\nA.1.1 Web Applications\nThis web application is typically initiated from a web browser that communicates \nwith a server using the HTTP protocol. The bulk of the application resides on the \nserver,  and  its  architecture  is  typically  composed  of  three  layers:  the  presenta-\ntion, business, and data layers. The presentation layer contains modules that are \nresponsible for managing user interaction. The business layer contains modules \nthat  handle  aspects  related  to  the  business  logic.  The  data  layer  contains  mod-\nules  that  manage  data  that  is  stored  either  locally  or  remotely.  In  addition,  cer-\ntain  functionality  that  is  common  to  modules  across  the  layers  is  organized  as  \ncross-cutting  concerns.  This  cross-cutting  functionality  includes  aspects  related  \nto security, logging, and exception management. Figure A.1 presents the compo-","metadata":{"id":681}}],["4e4c4a32-bc4a-48b8-9b4d-9b35108140e3",{"pageContent":"cross-cutting  concerns.  This  cross-cutting  functionality  includes  aspects  related  \nto security, logging, and exception management. Figure A.1 presents the compo-\nnents associated with the modules in web applications.\nThe following table summarizes the responsibilities of the components \npresent in this reference architecture:\nComponent NameResponsibility\nBrowserA web browser running on the client machine.\nUser interfaceThese components are responsible for receiving user \ninteractions and presenting information to the users. They \ncontain UI elements such as buttons and text fields.\nUI process logicThese components are responsible for managing the control \nflow of the application’s use cases. They are responsible \nfor other aspects such as data validation, orchestrating \ninteractions with the business logic, and providing data coming \nfrom the business layer to the user interface components.\nApplication facadeThis component is optional. It provides a simplified interface","metadata":{"id":682}}],["d1350c39-83e1-43f8-a865-065c2dee0f10",{"pageContent":"from the business layer to the user interface components.\nApplication facadeThis component is optional. It provides a simplified interface  \n(a facade) to the business logic components.\nBusiness workflowThese components are responsible for managing (long-\nrunning) business processes, which may involve the execution \nof multiple use cases.\nBusiness logicThese components are responsible for retrieving and \nprocessing application data and applying business rules on \nthis data.\nBusiness entitiesThese components represent the entities from the business \ndomain and their associated business logic.\nData accessThese components encapsulate persistence mechanisms \nand provide common operations used to retrieve and store \ninformation.\nHelpers and utilitiesThese components contain functionality common to other \nmodules in the data layer but not specific to any of them.\nService agentsThese components abstract communication mechanisms \nused to transfer data to external services.","metadata":{"id":683}}],["1f03f958-abd2-438f-a92c-bfd21db7a653",{"pageContent":"modules in the data layer but not specific to any of them.\nService agentsThese components abstract communication mechanisms \nused to transfer data to external services.\nSecurityThese components include cross-cutting functionality \nthat handles security aspects such as authorization and \nauthentication.\nwww.EBooksWorld.ir\nA.1 Reference Architectures 213\nComponent NameResponsibility\nOperation  \nmanagement\nThese components include cross-cutting functionality such \nas exception management, logging, and instrumentation and \nvalidation.\nCommunicationThese components include cross-cutting functionality that \nhandles communication mechanisms across layers and \nphysical tiers.\nFIGURE A.1 Web Application reference architecture (Key: UML)\nwww.EBooksWorld.ir\n214 Appendix A—A Design Concepts Catalog\nYou should consider using this type of application when:\n§\tYou do not require a rich user interface.\n§\tYou do not want to deploy the application by installing anything on the cli-\nent machine","metadata":{"id":684}}],["d29ccee4-519c-4aba-9cac-bdc59a4796d1",{"pageContent":"You should consider using this type of application when:\n§\tYou do not require a rich user interface.\n§\tYou do not want to deploy the application by installing anything on the cli-\nent machine\n§\tYou require portability of the user interface.\n§\tYour application needs to be accessible over the Internet.\n§\tYou want to use a minimum of client-side resources.\nA.1.2 Rich Client Applications\nRich  client  applications  are  installed  and  run  on  a  user’s  machine.  Because  \nthe  application  runs  on  the  user’s  machine,  its  user  interface  can  provide  a  \nhigh-performance, interactive, and rich user experience. A rich client application \nmay operate in stand-alone, connected, occasionally connected, or disconnected \nmode. When connected, it typically communicates with remote services provided \nby other applications.\nRich  client  application  modules  are  structured  in  three  main  layers  or  in  a  \ncross-cutting  grouping,  similar  to  a  web  application  (see  Section  A.1.1).  Rich","metadata":{"id":685}}],["580bd82a-9452-4156-9f34-2917d514f136",{"pageContent":"Rich  client  application  modules  are  structured  in  three  main  layers  or  in  a  \ncross-cutting  grouping,  similar  to  a  web  application  (see  Section  A.1.1).  Rich  \nclient applications can be “thin” or “thick.” Thin-client applications consist pri-\nmarily of presentation logic, which obtains user data and sends it to a server for \nprocessing.  Thick-client  applications  contain  business  and  data  logic  and  typi-\ncally connect to a data storage server only to exchange information that needs to \nbe  persisted  remotely.  Figure  A.2  presents  the  components  associated  with  the  \nmodules in rich client applications.\nYou should consider using this type of application when:\n§\tYou want to deploy your application on the users’ machines.\n§\tYou want your application to support intermittent or no network \nconnectivity.\n§\tYou want your application to be highly interactive and responsible.\n§\tYou want to leverage the user’s machine resources (such as a graphics \ncard).","metadata":{"id":686}}],["9b8e95a7-ff75-4bef-926a-22f847a4d631",{"pageContent":"connectivity.\n§\tYou want your application to be highly interactive and responsible.\n§\tYou want to leverage the user’s machine resources (such as a graphics \ncard).\nSince  these  applications  are  deployed  on  the  user’s  machine,  they  are  less  \nportable and deployment and updating is more complicated. A range of technolo-\ngies to facilitate their installation are available, however.\nwww.EBooksWorld.ir\nA.1 Reference Architectures 215\nFIGURE A.2 Rich Client Application reference architecture (Key: UML)\nA.1.3 Rich Internet Applications\nRich Internet applications (RIAs) typically run inside a browser and may be de-\nveloped using code that is executed by the browser such as Asynchronous Java-\nScript  and  XML  (AJAX).  RIAs  may  also  run  inside  a  browser  plug-in,  such  as  \nSilverlight. These applications are more complex than standard web applications \nwww.EBooksWorld.ir\n216 Appendix A—A Design Concepts Catalog","metadata":{"id":687}}],["e8c410d2-b8d9-42d1-ada5-7a1d15507988",{"pageContent":"Silverlight. These applications are more complex than standard web applications \nwww.EBooksWorld.ir\n216 Appendix A—A Design Concepts Catalog\nand support rich user interaction and business logic. They are, however, typically \nrestricted with respect to accessing local resources because of security concerns.\nTypical RIAs are structured using the same three layers and modules found \nin  web  applications  (see  Section  A.1.1).  In  RIAs,  some  business  logic  may  be  \nexecuted on the client machine, and some data may be stored locally. Like rich \nclient applications, RIAs may range from relatively thin to quite thick clients.\nThe  following  table  summarizes  the  responsibilities  of  the  components  of  \nthis reference architecture (shown in Figure A.3) that are not present in the Web \nApplication reference architecture:\nComponent \nNameResponsibility\nPresentationResponsible for managing user interaction (represents both UI \ncomponents and UI process logic components).","metadata":{"id":688}}],["e5cee66f-05ae-477f-8303-8683fbc324f1",{"pageContent":"Application reference architecture:\nComponent \nNameResponsibility\nPresentationResponsible for managing user interaction (represents both UI \ncomponents and UI process logic components).\nRich UI engineResponsible for rendering user interface elements inside the \nplug-in execution container.\nBusiness \nprocessing\nResponsible for managing business logic on the client side.\nService interfacesResponsible for exposing services that are consumed by the \ncomponents that run on the browser.\nMessage typesResponsible for managing the types of messages that are \nexchanged between the client part and the server part of the \napplication.\nYou should consider using this type of application when:\n§\tYou want your application to have a rich user interface but still run inside a \nbrowser.\n§\tYou want to perform some of the processing on the client side.\n§\tYou want to deploy and update your application in a simple manner, with-\nout having to perform installations on the user machine.","metadata":{"id":689}}],["fe0c0437-9bc1-4687-8671-4fe5a9dd6744",{"pageContent":"§\tYou want to perform some of the processing on the client side.\n§\tYou want to deploy and update your application in a simple manner, with-\nout having to perform installations on the user machine.\nHowever, there are some limitations associated with this type of application:\n§\tAccess to local resources can be limited, because the application may run \nin a sandbox.\n§\tLoading time is non-negligible.\n§\tPlug-in execution environments may not be available in all platforms.\nwww.EBooksWorld.ir\nA.1 Reference Architectures 217\nFIGURE A.3 Rich Internet Application reference architecture (Key: UML)\nwww.EBooksWorld.ir\n218 Appendix A—A Design Concepts Catalog\nA.1.4 Mobile Applications\nA  mobile  application  is  typically  executed  on  a  handheld  device  and  usually  \nworks in collaboration with a support infrastructure that resides remotely. These \napplications are structured using modules and layers similar to those found in a","metadata":{"id":690}}],["c8f6fff0-7cb8-448b-bab9-2381342d11d0",{"pageContent":"works in collaboration with a support infrastructure that resides remotely. These \napplications are structured using modules and layers similar to those found in a \nweb  application  (see  Section  A.1.1),  although  many  of  the  components  derived  \nfrom  these  modules  may  be  optional  depending  on  whether  a  thin-client  or  a  \nthick-client  approach  is  followed.  As  shown  in  Figure  A.4,  at  a  minimum,  the  \ncomponents  responsible  for  user  interaction  are  typically  present.  Communica-\ntion  with  the  support  infrastructure  is  frequently  unreliable,  and  these  applica-\ntions normally include some type of local data store that is periodically synchro-\nnized with data in the support infrastructure.\nYou should consider using this type of application when:\n§\tYou want your application to run in a handheld device.\n§\tThe network connectivity is unreliable, so the application needs to run in \nboth offline and occasionally connected modes.","metadata":{"id":691}}],["4ba268bd-8bc2-426f-a75b-87f9cd2727d3",{"pageContent":"§\tYou want your application to run in a handheld device.\n§\tThe network connectivity is unreliable, so the application needs to run in \nboth offline and occasionally connected modes.\nHowever, there is a substantial limitation associated with this type of application:\n§\tResources on the handheld device may be limited.\nA.1.5 Service Applications\nService  applications  are  non-interactive  applications  that  expose  functionality  \nthrough public interfaces (i.e., services). Services may be invoked by service con-\nsumer components remotely or from the same machine in which the service ap-\nplication is running. Services can be defined using a description language such as \nthe Web Services Description Language (WSDL); operations are invoked using \nXML-based message schemas that are transferred over a transport channel. As a \nconsequence, services promote interoperability.\nSimilar to the other types of reference architectures, service applications are","metadata":{"id":692}}],["fe356d10-2ad8-4697-b0a1-1c55769ca468",{"pageContent":"consequence, services promote interoperability.\nSimilar to the other types of reference architectures, service applications are \nstructured  using  layers  (Figure  A.5).  These  applications  are  not  interactive,  so  \nthe presentation layer is not needed. It is replaced by a service layer that contains \ncomponents  responsible  for  exposing  the  services  and  exchanging  information,  \nsimilar to the server part of RIAs (see Section A.1.3).\nwww.EBooksWorld.ir\nA.1 Reference Architectures 219\nFIGURE A.4 Mobile Application reference architecture (Key: UML)\nwww.EBooksWorld.ir\n220 Appendix A—A Design Concepts Catalog\nFIGURE A.5 Service Application reference architecture (Key: UML)\nwww.EBooksWorld.ir\nA.2 Deployment Patterns 221\nYou should consider using this type of application when:\n§\tYour application is not used by humans but rather by other systems and, as \na consequence, does not have a user interface.\n§\tYour application and the clients should be loosely coupled.","metadata":{"id":693}}],["7755f7c4-a5a6-4525-9f6e-27311c31500a",{"pageContent":"§\tYour application is not used by humans but rather by other systems and, as \na consequence, does not have a user interface.\n§\tYour application and the clients should be loosely coupled.\nExcept in cases where services are consumed by applications that reside in \nthe same machine, network connectivity is required for the clients to communi-\ncate with the service application.\nA.2 Deployment Patterns\nDeployment patterns provide guidance on how to structure the system from a phys-\nical standpoint (see Section 2.5.3). Good decisions with respect to the deployment \nof the software system are essential to achieve important quality attributes such as \nperformance,  usability,  availability,  and  security.  This  section  is  a  summary  from  \nthe catalog included in the Microsoft Application Architecture Guide.\nA.2.1 Nondistributed Deployment\nIn  nondistributed  deployment,  all  of  the  components  from  the  modules  in  the","metadata":{"id":694}}],["48bc79d7-43aa-4f9f-a0f5-032d1cc2241e",{"pageContent":"the catalog included in the Microsoft Application Architecture Guide.\nA.2.1 Nondistributed Deployment\nIn  nondistributed  deployment,  all  of  the  components  from  the  modules  in  the  \ndifferent  layers  reside  on  a  single  server  except  for  data  storage  functionality  \n(Figure  A.6).  Because  the  components  communicate  locally,  this  may  improve  \nperformance due to the lack of network communication delays. However, perfor-\nmance may be affected by other aspects of the system, such as resource conten-\ntion. Also, this type of application must support the peak usage of the largest con-\nsumers  of  system  resources.  Scalability  and  maintainability  may  be  negatively  \naffected because the same physical hardware is shared by all of the components.\nFIGURE A.6 Nondistributed deployment example (Key: UML)\nwww.EBooksWorld.ir\n222 Appendix A—A Design Concepts Catalog\nA.2.2 Distributed Deployment\nIn a distributed deployment, the components of the application reside on separate","metadata":{"id":695}}],["36a04adb-8c81-47c7-952d-c161876ce9f5",{"pageContent":"www.EBooksWorld.ir\n222 Appendix A—A Design Concepts Catalog\nA.2.2 Distributed Deployment\nIn a distributed deployment, the components of the application reside on separate \nphysical  tiers  (Figure  A.7).  Typically,  the  components  associated  with  specific  \nlayers are deployed in different tiers. Tiers can be configured differently to best \nmeet the requirements of the components that it hosts.\nDistributed  deployment  facilitates  scalability  but  the  addition  of  tiers  also  \nbrings  additional  costs,  network  latency,  complexity,  and  deployment  effort.  \nMore tiers may also be added to promote security. Different security policies may \nbe applied according to the particular tier, and firewalls may be placed between \nthe  tiers.  The  following  subsections  describe  various  alternatives  of  distributed  \ndeployment that can be used in conjunction with the reference architectures from \nSection A.1.\nFIGURE A.7 Distributed deployment example (Key: UML)","metadata":{"id":696}}],["bb6f0269-160c-45a2-8333-7755daf17faf",{"pageContent":"deployment that can be used in conjunction with the reference architectures from \nSection A.1.\nFIGURE A.7 Distributed deployment example (Key: UML)\nTwo-Tier Deployment (Client-Server)\nTwo-tier  deployment  is  the  most  basic  layout  for  distributed  deployment.  The  \nclient and the server are usually deployed on different physical tiers, as shown in \nFigure A.8.\nFIGURE A.8 Two-tier deployment pattern (Key: UML)\nwww.EBooksWorld.ir\nA.2 Deployment Patterns 223\nThree-Tier Deployment\nIn three-tier deployment, the application is deployed in a tier that is separate from \nthe one that hosts the database, as shown in Figure A.9. This is a very common \nphysical layout for web applications.\nFIGURE A.9 Three-tier deployment pattern (Key: UML)\nFour-Tier Deployment\nIn four-tier deployment, shown in Figure A.10, the web server and the application \nserver are deployed in different tiers. This separation is usually done to improve \nsecurity, as the web server may reside in a publicly accessible network while the","metadata":{"id":697}}],["df354433-4d64-4b96-a927-054027b349cf",{"pageContent":"server are deployed in different tiers. This separation is usually done to improve \nsecurity, as the web server may reside in a publicly accessible network while the \napplication resides in a protected network. Additionally, firewalls may be placed \nbetween the tiers.\nFIGURE A.10 Four-tier deployment pattern (Key: UML)\nA.2.3 Performance Patterns: Load-Balanced Cluster\nIn  the  Load-Balanced  Cluster  pattern,  the  application  is  deployed  on  multiple  \nservers that share the workload, as shown in Figure A.11. Client requests are re-\nceived  by  a  load  balancer,  which  redirects  them  to  the  various  servers  accord-\ning  to  their  current  load.  The  different  application  servers  can  process  several  \nrequests concurrently, which results in performance improvements.\nwww.EBooksWorld.ir\n224 Appendix A—A Design Concepts Catalog\nFIGURE A.11 Load-balanced cluster deployment pattern (Key: UML)\nA.3 Architectural Design Patterns","metadata":{"id":698}}],["3c6bd5ef-5471-4297-8dd4-4442ccc5a2f4",{"pageContent":"www.EBooksWorld.ir\n224 Appendix A—A Design Concepts Catalog\nFIGURE A.11 Load-balanced cluster deployment pattern (Key: UML)\nA.3 Architectural Design Patterns\nThis section includes architectural design patterns (see Section 2.5.2) used in the \ncase study in Chapter 4. The patterns presented here are based on the book  Pa t-\ntern-Oriented  Software  Architecture:  A  Pattern  Language  for  Distributed  Com-\nputing, Volume 4. The numbers in parentheses [e.g., Domain Model (182)] indi-\ncate the page in the book where the pattern is documented.\nNote that we are using a home-grown notation for the patterns here, which \nis common in the patterns community. We define the symbols in a legend accom-\npanying the first diagram (Layers) and use these symbols throughout this section.\nA.3.1 Structural Patterns\nThese patterns are used to structure the system but they provide less detail than \nthe reference architectures.\nwww.EBooksWorld.ir\nA.3 Architectural Design Patterns 225\nNameLayers\nProblem and \ncontext","metadata":{"id":699}}],["04de6e6e-fba0-4662-bb3a-7f5cd67c1d8b",{"pageContent":"These patterns are used to structure the system but they provide less detail than \nthe reference architectures.\nwww.EBooksWorld.ir\nA.3 Architectural Design Patterns 225\nNameLayers\nProblem and \ncontext\nWhen transforming a Domain Model (182) into a set of modules \nthat can be allocated to teams, [...] we need to support several \nconcerns: the independent development of the modules, the \nindependent evolution of the modules, the interaction among the \nmodules.\nSolutionDefine two or more layers for the software under development, \nwhere each layer has a distinct and specific responsibility. To make \nthe layering more effective, the interactions between the layers \nshould be highly constrained. The strictest layering, as shown \nbelow, allows only unidirectional dependencies and forbids layer-\nbridging.\nStructure\nConsequences \nand related \npatterns\nTypically, each self-contained and coherent responsibility within \na layer is realized as a separate domain object. Domain objects","metadata":{"id":700}}],["a61df673-e327-4d42-9106-ee5da26e3804",{"pageContent":"bridging.\nStructure\nConsequences \nand related \npatterns\nTypically, each self-contained and coherent responsibility within \na layer is realized as a separate domain object. Domain objects \nare the containers (modules) that can be developed and evolved \nindependently. \nNameDomain Object \nProblem and \ncontext\nWhen realizing a Domain Model (182) in terms of Layers (185), \na key concern is to decouple self-contained and cohesive \napplication responsibilities.\nSolutionEncapsulate each distinct, nontrivial piece of application \nfunctionality in a self-contained building block called a domain \nobject.\ncontinues\nwww.EBooksWorld.ir\n226 Appendix A—A Design Concepts Catalog\nNameDomain Object \nStructure\nConsequences \nand related \npatterns\nThe partitioning of an application’s responsibilities into domain \nobjects is based on one or more granularity criteria. There can \nbe different types of domain objects that encapsulate business \nfeatures, domain concepts, or infrastructure elements. For exam-","metadata":{"id":701}}],["9886e5ac-82a8-45fa-a902-618907edf712",{"pageContent":"objects is based on one or more granularity criteria. There can \nbe different types of domain objects that encapsulate business \nfeatures, domain concepts, or infrastructure elements. For exam-\nple, domain objects might be a function such as an income tax \ncalculation or a currency conversion, or a domain concept such \nas a bank account or a user. Domain objects can also aggregate \nother domain objects.\nWhen designing domain objects, you need to distinguish an \nExplicit Interface (281), which exports some functionality, from its \nEncapsulated Implementation (313), which realizes that function-\nality. The separation of interface and implementation is the key \nto modularization. It minimizes coupling—each domain object \ndepends only on explicit interfaces, not on encapsulated imple-\nmentations. This makes it possible to create and evolve a domain \nobject implementation independently from other domain objects. \nA.3.2 Interface Partitioning\nNameExplicit Interface\nProblem and \ncontext","metadata":{"id":702}}],["1a78f060-d15b-4590-b091-9cb1f4498a30",{"pageContent":"mentations. This makes it possible to create and evolve a domain \nobject implementation independently from other domain objects. \nA.3.2 Interface Partitioning\nNameExplicit Interface\nProblem and \ncontext\nWhen designing Layers (185) and their constituent Domain Ob-\njects (208), an important concern is how to properly create compo-\nnent (module) interfaces.\nA module is a self-contained unit of functionality (and a self- \ncontained unit of deployment) with a published interface. Clients \ncan build upon existing modules as building blocks when providing \ntheir own functionality. Direct access to the module’s implementa-\ntion might make clients dependent on the module’s internals, which \nultimately increases coupling and erodes the ability of the applica-\ntion to evolve.\nSolutionSeparate the explicit interface of a module from its implementa-\ntion. Export the explicit interface to the clients of the module, but \nkeep its implementation private.\nwww.EBooksWorld.ir\nA.3 Architectural Design Patterns 227","metadata":{"id":703}}],["fa8f537b-21cb-46c8-b108-de4767c48770",{"pageContent":"tion. Export the explicit interface to the clients of the module, but \nkeep its implementation private.\nwww.EBooksWorld.ir\nA.3 Architectural Design Patterns 227\nNameExplicit Interface\nStructure\nConsequences \nand related \npatterns\nA call from the client through an explicit interface will be forwarded \nto the implementation, but the client code will depend only on the \npublic interface, not on the implementation.\nAn explicit interface therefore enforces the separation of the \ncomponent’s interface from its implementation. This separation \nmeans that a component’s implementation may be modified and \nthe clients that use it will be unaffected, so long as the interfaces \nare unchanged.\nNameProxy\nProblem and \ncontext\nWhen specifying an Explicit Interface (281), we often want to avoid \naccessing services of a component implementation directly, as \nthese services may change or even be unknown until execution \ntime.\nMost modern software systems consist of cooperating compo-","metadata":{"id":704}}],["bfbf7249-64e8-4617-941c-bc0f079029b3",{"pageContent":"accessing services of a component implementation directly, as \nthese services may change or even be unknown until execution \ntime.\nMost modern software systems consist of cooperating compo-\nnents, some of which you create and others that you do not. \nYour components access and use the services provided by other \ncomponents. It may be impractical or even impossible to access \nthe services of a component directly—for example, because the \nimplementation resides on a remote server. \nSolutionEncapsulate all the details of interacting with the component within \na surrogate—called the proxy—and let clients communicate via \nthe proxy rather than directly with the subject component.\nStructure\nConsequences \nand related \npatterns\nA proxy frees both the client and the subjects from implementing \ncomponent-specific housekeeping functionality. It is also transpar-\nent to clients whether they are connected with the real subject com-\nponent or its proxy, because both publish an identical interface. The","metadata":{"id":705}}],["ca441750-daf3-4592-819f-880005b74a94",{"pageContent":"ent to clients whether they are connected with the real subject com-\nponent or its proxy, because both publish an identical interface. The \ndrawbacks of a proxy are additional execution time added to each \nclient interaction (although, unless your application is highly sensi-\ntive to latency, this additional overhead is likely inconsequential).\nwww.EBooksWorld.ir\n228 Appendix A—A Design Concepts Catalog\nA.3.3    Concurrency\nNameHalf-Sync/Half-Async\nProblem and \ncontext\nWhen developing concurrent software, a critical concern is to \nensure that concurrent programming is relatively straightforward \nwithout sacrificing runtime efficiency.\nConcurrent software typically performs both asynchronous and \nsynchronous processing of service requests. Asynchrony is used \nto process low-level service requests (such as events) efficiently, \nwhereas synchronous processing is used to simplify the processing \nof application services. To benefit from both programming models, it","metadata":{"id":706}}],["e64d3ef3-00fb-46a5-820d-98d8881f5451",{"pageContent":"whereas synchronous processing is used to simplify the processing \nof application services. To benefit from both programming models, it \nis essential to coordinate both kinds of processing.\nSolutionDecompose the services of concurrent software into two separate \nstreams or “layers”—synchronous and asynchronous—and add a \nqueueing “layer” to mediate communication between them. \nStructure\nConsequences \nand related \npatterns\nThis pattern allows you to process complex service requests, such \nas domain functionality or database queries, synchronously in \nseparate threads. Similarly, lower-level system services, such as \nprotocol handlers that respond to hardware interrupts, are handled \nasynchronously. In cases where services in the synchronous layer \nneed to communicate with services in the asynchronous layer, \nthey may exchange messages via the queueing layer.\nThe Half-Sync/Half-Async arrangement employs Layers (185) \nto keep the three distinct execution and communication models","metadata":{"id":707}}],["3e744782-3c41-49e8-8c49-507bc5ebfe0d",{"pageContent":"they may exchange messages via the queueing layer.\nThe Half-Sync/Half-Async arrangement employs Layers (185) \nto keep the three distinct execution and communication models \nencapsulated and hence independent from one another.\nwww.EBooksWorld.ir\nA.3 Architectural Design Patterns 229\nA.3.4 Database Access\nNameData Mapper (Data Access Object [DAO])\nProblem and \ncontext\nWhen designing a Database Access Layer (538), we need to \ninsulate applications from the details of how data is represented in \npersistent storage, such as the specific SQL queries to use.\nObject-oriented applications and relational databases use different \nabstractions for representing data. However, many applications \nneed to transfer data between these two “worlds.” It is desirable to \nkeep the object-oriented domain model ignorant of the relational \ndatabase schema. In this way, changes to one domain model will \nbe less likely to ripple to the other. \nSolutionIntroduce a data mapper for each type of persistent application","metadata":{"id":708}}],["b3289d48-17f7-4a8c-8c5b-2ab97282c23e",{"pageContent":"database schema. In this way, changes to one domain model will \nbe less likely to ripple to the other. \nSolutionIntroduce a data mapper for each type of persistent application \nobject. The responsibility of this mapper is to transfer data from \nthe objects to the database, and vice versa.\nStructure\nConsequences \nand related \npatterns\nA data mapper is a mediator that moves data between an \nobject-oriented domain model and a relational database. A client \ncan use the data mapper to store or retrieve application data \nin the database. The data mapper performs any needed data \ntransformations and maintains consistency between the two \nrepresentations.\nWhen a data mapper is used, in-memory objects do not even need \nto know that a database is present. Hence, they require no SQL \ncode and can have complete ignorance of the database schema. \nIn addition, the relational database schema and the object-\noriented domain model can evolve independently. This provides","metadata":{"id":709}}],["e2831579-87ce-4da3-a2bb-408b0d3d46a0",{"pageContent":"code and can have complete ignorance of the database schema. \nIn addition, the relational database schema and the object-\noriented domain model can evolve independently. This provides \nan additional benefit that accrues to any abstraction interface: It \nsimplifies unit testing, by allowing mappers to databases to be \nreplaced by mock objects that support in-memory testing.\nThe data mapper makes application objects simpler and reduces \ntheir external dependencies, making them easier to evolve. \nThere are two potential drawbacks to the Data Mapper pattern, \nhowever: (1) Changes in either the application object model or the \ndatabase schema may require changes to a data mapper; and (2) \nthe additional level of indirection introduces overhead, and hence \nlatency, to every data access, which might be problematic for \nsystems with hard real-time deadlines, for example. \nwww.EBooksWorld.ir\n230 Appendix A—A Design Concepts Catalog\nA.4   Tactics","metadata":{"id":710}}],["5acf36a5-b200-4c84-ad47-6f84352a1676",{"pageContent":"latency, to every data access, which might be problematic for \nsystems with hard real-time deadlines, for example. \nwww.EBooksWorld.ir\n230 Appendix A—A Design Concepts Catalog\nA.4   Tactics\nTactics  were  presented  in  Section  2.5.4.  Here  we  present  a  summarized  catalog  \nof tactics for seven commonly encountered quality attributes. This catalog comes \nfrom the book Software Architecture in Practice.\nA.4.1 Availability Tactics\nFigure A.12 summarizes the tactics to achieve availability.\nDetect Faults\nPrevent Faults\nPing / Echo\nRemoval from\nService\nMonitor\nTransactions\nPredictive\nModel\nRecover from Faults\nHeartbeat\nPreparation\nand Repair\nReintroduction\nActive\nRedundancy\nPassive\nRedundancy\nSpare\nEscalating\nRestart\nException\nHandling\nShadow\nNon-Stop\nForwarding\nState\nResynchronization\nException\nPrevention\nFault\nFault\nMasked\nor\nRepair\nMade\nTimestamp\nSanity\nChecking\nCondition\nMonitoring\nVoting\nException\nDetection\nSelf-Test\nRollback\nSoftware\nUpgrade\nRetry\nIgnore Faulty\nBehavior\nDegradation\nReconfiguration\nIncrease\nCompetence Set","metadata":{"id":711}}],["335441d4-4d86-46f0-849d-55749e3bd012",{"pageContent":"Fault\nFault\nMasked\nor\nRepair\nMade\nTimestamp\nSanity\nChecking\nCondition\nMonitoring\nVoting\nException\nDetection\nSelf-Test\nRollback\nSoftware\nUpgrade\nRetry\nIgnore Faulty\nBehavior\nDegradation\nReconfiguration\nIncrease\nCompetence Set\nAvailability Tactics\nFIGURE A.12 Availability tactics\nwww.EBooksWorld.ir\nA.4   Tactics 231\nDetect Faults\n§\tPing/echo: An asynchronous request/response message pair exchanged \nbetween nodes is used to determine reachability and the round-trip delay \nthrough the associated network path.\n§\tMonitor: A component is used to monitor the state of health of other parts \nof the system. A system monitor can detect failure or congestion in the net-\nwork or other shared resources, such as from a denial-of-service attack.\n§\tHeartbeat: A periodic message exchange occurs between a system monitor \nand a process being monitored.\n§\tTimestamp: Detect incorrect sequences of events, primarily in distributed \nmessage-passing systems.\n§\tSanity checking: Check the validity or reasonableness of a component’s oper-","metadata":{"id":712}}],["5c26fbc0-d522-470a-b185-3e7cca72abb1",{"pageContent":"§\tTimestamp: Detect incorrect sequences of events, primarily in distributed \nmessage-passing systems.\n§\tSanity checking: Check the validity or reasonableness of a component’s oper-\nations or outputs; typically based on a knowledge of the internal design, the \nstate of the system, or the nature of the information under scrutiny.\n§\tCondition monitoring: Check conditions in a process or device, or validates \nassumptions made during the design.\n§\tVoting: Check that replicated components are producing the same results. \nComes in various flavors, such as replication, functional redundancy, ana-\nlytic redundancy.\n§\tException detection: Detect a system condition that alters the normal flow \nof execution, such as a system exception, parameter fence, parameter typ-\ning, or timeout.\n§\tSelf-test: Procedure for a component to test itself for correct operation.\nRecover from Faults (Preparation and Repair)\n§\tActive redundancy (hot spare): All nodes in a protection group receive and","metadata":{"id":713}}],["139c74e8-7f8f-4c7c-b1f6-bd805c6a9602",{"pageContent":"§\tSelf-test: Procedure for a component to test itself for correct operation.\nRecover from Faults (Preparation and Repair)\n§\tActive redundancy (hot spare): All nodes in a protection group receive and \nprocess identical inputs in parallel, allowing redundant spare(s) to maintain \nsynchronous state with the active node(s).\n§\tPassive redundancy (warm spare): Only the active members of the protec-\ntion group process input traffic; one of their duties is to provide the redun-\ndant spare(s) with periodic state updates.\n§\tSpare (cold spare): Redundant spares of a protection group remain out of \nservice until a failover occurs, at which point a power-on-reset procedure is \ninitiated on the redundant spare prior to its being placed in service.\n§\tException handling: Deal with the exception by reporting it or handling it, \npotentially masking the fault by correcting the cause of the exception and \nretrying.\n§\tRollback: Revert to a previous known good state, referred to as the “roll-\nback line.”","metadata":{"id":714}}],["30fe2f4e-c2b4-4d16-b586-82503e86db40",{"pageContent":"potentially masking the fault by correcting the cause of the exception and \nretrying.\n§\tRollback: Revert to a previous known good state, referred to as the “roll-\nback line.”\n§\tSoftware upgrade: Perform in-service upgrades to executable code images \nin a non-service-affecting manner.\n§\tRetry: When a failure is transient, retrying the operation may lead to success.\nwww.EBooksWorld.ir\n232 Appendix A—A Design Concepts Catalog\n§\tIgnore faulty behavior: Ignore messages sent from a source when it is de-\ntermined that those messages are spurious.\n§\tDegradation: Maintain the most critical system functions in the presence of \ncomponent failures, dropping less critical functions.\n§\tReconfiguration: Reassign responsibilities to the resources that continue to \nfunction, while maintaining as much functionality as possible.\nRecover from Faults (Reintroduction)\n§\tShadow: Operate a previously failed or in-service upgraded component in a \n“shadow mode” for a predefined time prior to reverting the component back","metadata":{"id":715}}],["7f0f3d76-7b12-4227-804c-488cdfb82c8c",{"pageContent":"Recover from Faults (Reintroduction)\n§\tShadow: Operate a previously failed or in-service upgraded component in a \n“shadow mode” for a predefined time prior to reverting the component back \nto an active role.\n§\tState resynchronization: Passive redundancy; state information is sent from \nactive to standby components, in this partner tactic to active redundancy.\n§\tEscalating restart: Recover from faults by varying the granularity of the \ncomponent(s) restarted and minimizing the level of service affected.\n§\tNon-stop forwarding: Functionality is split into supervisory and data \nvariants. If a supervisor fails, a router continues forwarding packets along \nknown routes while protocol information is recovered and validated.\nPrevent Faults\n§\tRemoval from service: Temporarily place a system component in an out-of-\nservice state for the purpose of mitigating potential system failures.\n§\tTransactions: Bundle state updates so that asynchronous messages exchanged","metadata":{"id":716}}],["3731c67b-d7c7-4a92-ac49-e0ee04a15212",{"pageContent":"service state for the purpose of mitigating potential system failures.\n§\tTransactions: Bundle state updates so that asynchronous messages exchanged \nbetween distributed components are atomic, consistent, isolated, and durable.\n§\tPredictive model: Monitor the state of health of a process to ensure that the \nsystem is operating within nominal parameters; take corrective action when \nconditions are detected that are predictive of likely future faults.\n§\tException prevention: Prevent system exceptions from occurring by masking \na fault, or prevent them via smart pointers, abstract data types, and wrappers.\n§\tIncrease competence set: Design a component to handle more cases—\nfaults—as part of its normal operation.\nA.4.2 Interoperability Tactics\nFigure A.13 summarizes the tactics to achieve interoperability.\nwww.EBooksWorld.ir\nA.4   Tactics 233\nInteroperability Tactics\nLocate\nManage Interfaces\nDiscover\nService\nOrchestrate\nTailor Interface\nRequest\nCorrectly\nHandled\nInformation\nExchange\nRequest","metadata":{"id":717}}],["b641fd1b-2acc-4934-893e-3c804f3e29c1",{"pageContent":"www.EBooksWorld.ir\nA.4   Tactics 233\nInteroperability Tactics\nLocate\nManage Interfaces\nDiscover\nService\nOrchestrate\nTailor Interface\nRequest\nCorrectly\nHandled\nInformation\nExchange\nRequest\nFIGURE A.13 Interoperability tactics\nLocate\n§\tDiscover service: Locate a service by searching a known directory service. \nThere may be multiple levels of indirection in this location process—that is, \na known location may point to another location that in turn can be searched \nfor the service.\nManage Interfaces\n§\tOrchestrate: Use a control mechanism to coordinate, manage, and sequence \nthe invocation of services. Orchestration is used when systems must interact \nin a complex fashion to accomplish a complex task.\n§\tTailor interface: Add or remove capabilities to an interface such as transla-\ntion, buffering, or data smoothing.\nA.4.3 Modifiability Tactics\nFigure A.14 summarizes the tactics to achieve modifiability.\nwww.EBooksWorld.ir\n234 Appendix A—A Design Concepts Catalog\nModifiability Tactics\nIncrease\nCohesion\nReduce\nCoupling","metadata":{"id":718}}],["39a3f0d6-61ab-470f-b4e2-af220fbe5566",{"pageContent":"A.4.3 Modifiability Tactics\nFigure A.14 summarizes the tactics to achieve modifiability.\nwww.EBooksWorld.ir\n234 Appendix A—A Design Concepts Catalog\nModifiability Tactics\nIncrease\nCohesion\nReduce\nCoupling\nSplit Module\nEncapsulate\nUse an\nIntermediary\nChange\nArrives\nChange Made\nwithin Time \nand Budget\nReduce Size\nof a Module\nIncrease\nSemantic\nCoherence\nRestrict\nDependencies\nRefactor\nAbstract Common\nServices\nDefer\nBinding\nFIGURE A.14 Modifiability tactics\nReduce Size of a Module\n§\tSplit module: If the module being modified includes a great deal of capa-\nbility, the modification costs will likely be high. Refining the module into \nseveral smaller modules should reduce the average cost of future changes.\nIncrease Cohesion\n§\tIncrease semantic coherence: If the responsibilities A and B in a module \ndo not serve the same purpose, they should be placed in different modules. \nThis may involve creating a new module or moving a responsibility to an \nexisting module.\nReduce Coupling","metadata":{"id":719}}],["7b4a9fdc-04ad-44ab-bff2-b05bbc1d96c4",{"pageContent":"do not serve the same purpose, they should be placed in different modules. \nThis may involve creating a new module or moving a responsibility to an \nexisting module.\nReduce Coupling\n§\tEncapsulate: Encapsulation introduces an explicit interface to a module. \nThis interface includes an API and its associated responsibilities, such as \n“perform a syntactic transformation on an input parameter to an internal \nrepresentation.”\n§\tUse an intermediary: Given a dependency between responsibility A and \nresponsibility B (for example, carrying out A first requires carrying out B), \nthe dependency can be broken by using an intermediary.\nwww.EBooksWorld.ir\nA.4   Tactics 235\n§\tRestrict dependencies: Restrict the modules that a given module interacts \nwith or depends on.\n§\tRefactor: Refactoring is undertaken when two modules are affected by the \nsame change because they are (at least partial) duplicates of each other.\n§\tAbstract common services: When two modules provide not quite the same","metadata":{"id":720}}],["6ac42576-8e6e-47b7-8a5f-3bf8eb378045",{"pageContent":"same change because they are (at least partial) duplicates of each other.\n§\tAbstract common services: When two modules provide not quite the same \nbut similar services, it may be cost-effective to implement the services just \nonce in a more general (abstract) form.\nDefer Binding\n§\tDefer binding: Allow decisions to be bound after development time.\nA.4.4 Performance Tactics\nFigure A.15 summarizes the tactics to achieve performance.\nPerformance Tactics\nControl Resource DemandManage Resources\nManage sampling rate\nEvents \nArrive\nResponse \nGenerated \nwithin \nTime \nConstraints\nLimit event response\nPrioritize events\nReduce overhead\nBound execution times\nIncrease resource \nefficiency\nIncrease resources\nIntroduce concurrency\nMaintain multiple \ncopies of computations\nMaintain multiple \ncopies of data\nBound queue sizes\nSchedule resources\nFIGURE A.15 Performance tactics\nwww.EBooksWorld.ir\n236 Appendix A—A Design Concepts Catalog\nControl Resource Demand\n§\tManage sampling rate: If it is possible to reduce the sampling frequency at","metadata":{"id":721}}],["1cec2f7d-fc11-4ec2-867e-c6b204ce56e2",{"pageContent":"FIGURE A.15 Performance tactics\nwww.EBooksWorld.ir\n236 Appendix A—A Design Concepts Catalog\nControl Resource Demand\n§\tManage sampling rate: If it is possible to reduce the sampling frequency at \nwhich a stream of data is captured, then demand can be reduced, albeit typ-\nically with some loss of fidelity.\n§\tLimit event response: Process events only up to a set maximum rate, there-\nby ensuring more predictable processing when the events are actually \nprocessed.\n§\tPrioritize events: If not all events are equally important, you can impose a \npriority scheme that ranks events according to how important it is to service \nthem.\n§\tReduce overhead: The use of intermediaries (important for modifiability) \nincreases the resources consumed in processing an event stream; removing \nthem improves latency.\n§\tBound execution times: Place a limit on how much execution time is used to \nrespond to an event.\n§\tIncrease resource efficiency: Improving the algorithms used in critical areas \nwill decrease latency.","metadata":{"id":722}}],["8739698e-882f-4339-9d29-b948b914cd6a",{"pageContent":"§\tBound execution times: Place a limit on how much execution time is used to \nrespond to an event.\n§\tIncrease resource efficiency: Improving the algorithms used in critical areas \nwill decrease latency.\nManage Resources\n§\tIncrease resources: Faster processors, additional processors, additional \nmemory, and faster networks all have the potential to reduce latency.\n§\tIncrease concurrency: If requests can be processed in parallel, the blocked \ntime can be reduced. Concurrency can be introduced by processing differ-\nent streams of events on different threads or by creating additional threads \nto process different sets of activities.\n§\tMaintain multiple copies of computations: The purpose of replicas is to \nreduce the contention that would occur if all computations took place on a \nsingle server.\n§\tMaintain multiple copies of data: Keep copies of data (with one potentially \nbeing a subset of the other) on storage with different access speeds.","metadata":{"id":723}}],["ecc99a39-ff5b-4b24-bbbf-f983cfe13a55",{"pageContent":"single server.\n§\tMaintain multiple copies of data: Keep copies of data (with one potentially \nbeing a subset of the other) on storage with different access speeds.\n§\tBound queue sizes: Control the maximum number of queued arrivals and \nconsequently the resources used to process the arrivals.\n§\tSchedule resources: When there is contention for a resource, the resource \nmust be scheduled.\nA.4.5 Security Tactics\nFigure A.16 summarizes the tactics to achieve security.\nwww.EBooksWorld.ir\nA.4   Tactics 237\nSecurity Tactics\nResist Attacks\nAttack\nSystem \nDetects,\nResists, \nReacts,\nor Recovers\nDetect Attacks\nRecover\nfrom Attacks\nReact to\nAttacks\nDetect\nIntrusion\nDetect Service\nDenial\nVerify Message\nIntegrity\nDetect Message\nDelay\nMaintain\nAudit Trail\nRestore\nSee\nAvailability\nRevoke\nAccess\nck\nt\nmpu\nLo\nCoe\nr\nInform\nActors\nEncrypt Data\nLimit Exposure\nChange Default\nSettings\nSeparate\nEntities\nIdentify\nActors\nAuthenticate\nActors\nAuthorize\nActors\nLimit Access\nValidate Input\nFIGURE A.16 Security tactics\nDetect Attacks","metadata":{"id":724}}],["58e4cd54-718a-4fa5-a857-22106e1fba8e",{"pageContent":"mpu\nLo\nCoe\nr\nInform\nActors\nEncrypt Data\nLimit Exposure\nChange Default\nSettings\nSeparate\nEntities\nIdentify\nActors\nAuthenticate\nActors\nAuthorize\nActors\nLimit Access\nValidate Input\nFIGURE A.16 Security tactics\nDetect Attacks\n§\tDetect intrusion: Compare network traffic or service request patterns with-\nin a system to a set of signatures or known patterns of malicious behavior \nstored in a database.\n§\tDetect service denial: Compare the pattern or signature of network traffic \ncoming into a system to historic profiles of known denial-of-service attacks.\n§\tVerify message integrity: Use techniques such as checksums or hash values \nto verify the integrity of messages, resource files, deployment files, and \nconfiguration files.\n§\tDetect message delay: By checking the time that it takes to deliver a mes-\nsage, it is possible to detect suspicious timing behavior.\nResist Attacks\n§\tIdentify actors: Identify the source of any external input to the system.\n§\tAuthenticate actors: Ensure that an actor (user or a remote computer) is","metadata":{"id":725}}],["06b3eb3d-0025-45c0-8a01-5b8147722f96",{"pageContent":"Resist Attacks\n§\tIdentify actors: Identify the source of any external input to the system.\n§\tAuthenticate actors: Ensure that an actor (user or a remote computer) is \nactually who or what it purports to be.\n§\tAuthorize actors: Ensure that an authenticated actor has the rights to access \nand modify either data or services.\nwww.EBooksWorld.ir\n238 Appendix A—A Design Concepts Catalog\n§\tLimit access: Control what and who may access which parts of a system, \nsuch as processors, memory, and network connections.\n§\tLimit exposure: Reduce the probability of a successful attack, or restrict \nthe amount of potential damage—for example, by concealing facts about \na system (“security by obscurity”) or by dividing and distributing critical \nresources (“don’t put all your eggs in one basket”).\n§\tEncrypt data: Apply some form of encryption to data and to \ncommunication.\n§\tValidate input: Validate input from a user or an external system before ac-\ncepting it in the system.","metadata":{"id":726}}],["a23dc478-9493-49a6-8823-e3fc1931fa28",{"pageContent":"§\tEncrypt data: Apply some form of encryption to data and to \ncommunication.\n§\tValidate input: Validate input from a user or an external system before ac-\ncepting it in the system.\n§\tSeparate entities: Use physical separation on different servers attached to \ndifferent networks, virtual machines, or an “air gap.”\n§\tChange default settings: Force the user to change settings assigned by \ndefault.\nReact to Attacks\n§\tRevoke access: Limit access to sensitive resources, even for normally legiti-\nmate users and uses, if an attack is suspected.\n§\tLock computer: Limit access to a resource if there are repeated failed at-\ntempts to access it.\n§\tInform actors: Notify operators, other personnel, or cooperating systems \nwhen an attack is suspected or detected.\nRecover from Attacks\nIn  addition  to  the  availability  tactics  for  recovery  of  failed  resources,  an  audit  \nmay be performed to recover from attacks.\n§\tMaintain Audit Trail: Keep a record of user and system actions and their","metadata":{"id":727}}],["68517374-2a18-4cda-b03d-2c757dc5ea2f",{"pageContent":"may be performed to recover from attacks.\n§\tMaintain Audit Trail: Keep a record of user and system actions and their \neffects, to help trace the actions of, and to identify, an attacker.\nA.4.6 Testability Tactics\nFigure A.17 summarizes the tactics to achieve testability.\nwww.EBooksWorld.ir\nA.4   Tactics 239\nTestability Tactics\nControl and Observe\nSystem State\nLimit Complexity\nSpecialized\nInterfaces\nLimit Structural\nComplexity\nLimit\nNondeterminism\nTests\nExecuted\nFaults\nDetected\nRecord/\nPlayback\nLocalize State\nStorage\nSandbox\nExecutable\nAssertions\nAbstract Data\nSources\nFIGURE A.17 Testability tactics\nControl and Observe System State\n§\tSpecialized interfaces: Control or capture variable values for a component \neither through a test harness or through normal execution.\n§\tRecord/playback: Capture information crossing an interface and use it as \ninput for further testing.\n§\tLocalize state storage: To start a system, subsystem, or module in an arbi-","metadata":{"id":728}}],["34123d00-0379-4abd-9f0a-230c32df2fba",{"pageContent":"§\tRecord/playback: Capture information crossing an interface and use it as \ninput for further testing.\n§\tLocalize state storage: To start a system, subsystem, or module in an arbi-\ntrary state for a test, it is most convenient if that state is stored in a single \nplace.\n§\tAbstract data sources: Abstracting the interfaces lets you substitute test \ndata more easily.\n§\tSandbox: Isolate the system from the real world to enable experimentation \nthat is unconstrained by the worry about having to undo the consequences \nof the experiment.\n§\tExecutable assertions: Assertions are (usually) hand-coded and placed at \ndesired locations to indicate when and where a program is in a faulty state.\nwww.EBooksWorld.ir\n240 Appendix A—A Design Concepts Catalog\nLimit Complexity\n§\tLimit structural complexity: Avoid or resolve cyclic dependencies between \ncomponents, isolate and encapsulate dependencies on the external environ-\nment, and reduce dependencies between components in general.","metadata":{"id":729}}],["7d90afbb-203a-417b-8bd8-a3634244693a",{"pageContent":"components, isolate and encapsulate dependencies on the external environ-\nment, and reduce dependencies between components in general.\n§\tLimit nondeterminism: Find all the sources of non-determinism, such as \nunconstrained parallelism, and weed them out as far as possible.\nA.4.7 Usability Tactics\nFigure A.18 summarizes the tactics to achieve usability.\nSupport User Initiative\n§\tCancel: The system must listen for the cancel request; the command being \ncanceled must be terminated; resources used must be freed; and collaborat-\ning components must be informed.\n§\tPause/resume: Temporarily free resources so that they may be reallocated \nto other tasks.\n§\tUndo: Maintain a sufficient amount of information about system state so \nthat an earlier state may be restored at the user’s request.\n§\tAggregate: Aggregate lower-level objects into a group, so that a user opera-\ntion may be applied to the group, freeing the user from the drudgery.\nUser\nRequest\nUser Given\nAppropriate\nFeedback and\nAssistance\nUsability Tactics","metadata":{"id":730}}],["1c4a4252-81c1-4191-bfdb-3fbe1d9e8ea7",{"pageContent":"tion may be applied to the group, freeing the user from the drudgery.\nUser\nRequest\nUser Given\nAppropriate\nFeedback and\nAssistance\nUsability Tactics\nSupport User\nInitiative\nSupport System\nInitiative\nCancel\nMaintain User  Model\nMaintain System Model\nUndo\nPause/Resume\nAggregate\nMaintain Task Model\nFIGURE A.18 Usability tactics\nwww.EBooksWorld.ir\nA.5 Externally Developed Components 241\nSupport System Initiative\n§\tMaintain task model: Determine the context so the system can have some \nidea of what the user is attempting and provide assistance.\n§\tMaintain user model: Explicitly represent the user’s knowledge of the sys-\ntem, the user’s behavior in terms of expected response time, and other char-\nacteristics of the system.\n§\tMaintain system model: The system maintains an explicit model of itself. \nThis tactic is used to determine expected system behavior so that appropri-\nate feedback can be given to the user.\nA.5 Externally Developed Components","metadata":{"id":731}}],["b616c4fc-f5dd-4031-9405-7e2b85977639",{"pageContent":"This tactic is used to determine expected system behavior so that appropri-\nate feedback can be given to the user.\nA.5 Externally Developed Components\nExternally  developed  components,  including  frameworks,  were  discussed  in  \nSection  2.5.5.  Here  we  present  a  small  sample  of  Java  frameworks  used  in  the  \ncase study in Chapter 4. Each framework is described very briefly and is associ-\nated with particular technology families, patterns, and tactics. Full details for the \ndifferent frameworks can be found by visiting the URL that is provided.\nA.5.1 Spring Framework\nFramework \nNameSpring Framework\nTechnology \nfamily\nDependency injection and aspect-oriented programming (AOP) \ncontainer\nLanguageJava\nURLhttp://projects.spring.io/spring-framework/\nPurposeThe application framework allows the objects that form an \napplication to be connected. It also supports different concerns \nthrough AOP.\nOverviewThe Spring container connects standard Java objects, or POJOs","metadata":{"id":732}}],["786bd546-b421-4c47-b794-60f493b014e3",{"pageContent":"application to be connected. It also supports different concerns \nthrough AOP.\nOverviewThe Spring container connects standard Java objects, or POJOs \n(Plain Old Java Objects), by using information from an XML file \ncalled “Application Context” or annotations in the Java code. This is \nthe “Inversion of Control and Dependency Injection” pattern, since \nobject dependencies are injected by the container.\nThe framework supports several aspects using AOP which are \nintroduced as proxies between the Java objects when the container \nconnects them. Supported aspects include:\n ■\nSecurity\n ■\nTransaction management\n ■\nPublishing object interfaces so the objects can be accessed re-\nmotely—for example, via Web Services\n(continues)\nwww.EBooksWorld.ir\n242 Appendix A—A Design Concepts Catalog\nFramework \nNameSpring Framework\nStructure\nThis diagram represents how two objects are connected by two \nimportant elements in the framework: the Spring container and the \napplication context. (Key: UML)\nImplemented \ndesign \npatterns and","metadata":{"id":733}}],["8dd72d30-cfee-4d0d-9127-e4a15814053d",{"pageContent":"Structure\nThis diagram represents how two objects are connected by two \nimportant elements in the framework: the Spring container and the \napplication context. (Key: UML)\nImplemented \ndesign \npatterns and \ntactics\nPatterns\n ■\nInversion of Control and Dependency Injection\n ■\nFactory\n ■\nProxy\nTac t i c s\n ■\nAvailability: Transactions\n ■\nTestability: Abstract data sources (separate interface and \nimplementation)\nBenefits\n ■\nExcellent tool support\n ■\nSimple integration with other frameworks such as web UI (Spring \nMVC, JSF), and persistence (JPA, Hibernate, iBatis) and integra-\ntion (JMS)\nLimitations\n ■\nApache License 2.0\n ■\nComplex framework\nwww.EBooksWorld.ir\nA.5 Externally Developed Components 243\nA.5.2 Swing Framework\nFramework \nNameSwing Framework\nTechnology \nfamily\nLocal user interface\nLanguageJava\nURLhttp://docs.oracle.com/javase/tutorial/uiswing/index.html\nPurposeFramework to support the creation of portable local (non-web) user \ninterfaces.\nOverviewThe Swing framework provides a library of user interface","metadata":{"id":734}}],["3c865863-816d-461a-8223-87ff02b1a318",{"pageContent":"PurposeFramework to support the creation of portable local (non-web) user \ninterfaces.\nOverviewThe Swing framework provides a library of user interface \ncomponents, including JFrame (windows), JMenu, JTree, JButton, \nJList, and JTable, among others. These components are built \naround the Model View Controller and Observer patterns.\nComponents such as JTables are views and controllers, and each \nhas a corresponding model class (e.g., TableModel).\nComponents allow observers (called “listeners”) to be registered \nto manage different events. For example, JButtons allow \nActionListeners to be registered as observers so that when the \nbutton is clicked, a callback method (actionPerformed) is \ninvoked.\nStructure\nThis diagram represents a small fraction of the framework’s classes (Key: UML)\nImplemented \ndesign \npatterns and \ntactics\nPatterns:\n ■\nModel View Controller\n ■\nObserver\n ■\nOthers such as Composite and Iterator\nBenefits\n ■\nPortable (can run on any operating system)\n ■\nPart of Java API\n ■\nGood tool support\nLimitations","metadata":{"id":735}}],["0c31cd46-0cf3-436c-a037-4963ac8a0480",{"pageContent":"tactics\nPatterns:\n ■\nModel View Controller\n ■\nObserver\n ■\nOthers such as Composite and Iterator\nBenefits\n ■\nPortable (can run on any operating system)\n ■\nPart of Java API\n ■\nGood tool support\nLimitations\n ■\nSlower than using native UI elements\n ■\nNot the same look and feel as native UI elements\nwww.EBooksWorld.ir\n244 Appendix A—A Design Concepts Catalog\nA.5.3    Hibernate Framework\nFramework \nNameHibernate\nTechnology \nfamily\nObject-oriented to relational mapper\nLanguageJava\nURL                      http://hibernate.org/\nPurposeSimplify persistence of objects in a relational database.\nOverviewHibernate allows objects to be easily persisted in a relational data-\nbase (and it supports different   dataLLLbase en  gines).    Object-relational \nmapping rules are described declaratively in an XML file called \nhibernate.cfg or using annotations in the classes whose objects \nneed to be persisted.\nHibernate supports transactions and provides a query language \ncalled HQL (Hibernate Query Language) that is used to retrieve","metadata":{"id":736}}],["3c4280d8-bc10-4152-a3bf-7c8a47a30180",{"pageContent":"need to be persisted.\nHibernate supports transactions and provides a query language \ncalled HQL (Hibernate Query Language) that is used to retrieve \nobjects from the database. Hibernate utilizes multilevel caching \nschemes to improve performance. It also provides mechanisms \nto allow lazy acquisition of dependent objects to improve perfor-\nmance and reduce resource consumption. These mechanisms are \nconfigured declaratively in the configuration files.\nStructure\nThis diagram represents an entity that is persisted to a database \nby the Hibernate runtime using the information in the configuration \nfile (Key: UML)\nImplemented \ndesign patterns \nand tactics\nPatterns:\n ■\nData Mapper\n ■\nResource Cache\n ■\nLazy Acquisition\nTac t i c s :\n ■\nAvailability: Transactions\n ■\nPerformance: Maintain multiple copies of data (cache)\nwww.EBooksWorld.ir\nA.6    Summary 245\nFramework \nNameHibernate\nBenefits\n ■\nGreatly simplifies the persistence of objects in relational \ndatabase\nLimitations\n ■\nComplex API\n ■","metadata":{"id":737}}],["9735d392-a21b-4832-bbc3-9c43bd4dd85f",{"pageContent":"www.EBooksWorld.ir\nA.6    Summary 245\nFramework \nNameHibernate\nBenefits\n ■\nGreatly simplifies the persistence of objects in relational \ndatabase\nLimitations\n ■\nComplex API\n ■\nSlower than JDBC (Java Database Connectivity)\n ■\nDifficult to map to legacy database schemas\nA.5.4 Java Web Start Framework\nFramework \nNameJava Web Start Framework\nTechnology \nfamily\nDeployment mechanism\nLanguageJava\nURLhttp://docs.oracle.com/javase/tutorial/deployment/webstart/\nPurposeProvide a platform-independent, secure, and robust deployment \ntechnology. \nOverviewBy using a web browser, end users can start standard (non-\napplet) Java applications, and Java Web Start ensures they are \nrunning the latest version. To launch an application, users click a \nlink on a page. If this is the first time the application is used, Java \nWeb Start downloads the application. If the application has been \npreviously used, Java Web Start verifies that the local copy is the \nlatest version and launches it or downloads the newest version.","metadata":{"id":738}}],["84b88c07-20c2-45e3-9ab4-0b6de330d809",{"pageContent":"Web Start downloads the application. If the application has been \npreviously used, Java Web Start verifies that the local copy is the \nlatest version and launches it or downloads the newest version.\nStructureNot available\nImplemented \ndesign patterns \nand tactics\nTac t i c s :\n ■\nSecurity: Limit access (sandbox)\n ■\nPerformance: Maintain multiple copies of data (cache)\nBenefits\n ■\nApplications run in a sandbox but can read and write to local files.\n ■\nBecause the application is cached, once it has been downloaded \nstartup time is greatly reduced.\nLimitations\n ■\nFirst launch may take some time\nA.6    Summary\nIn this appendix we presented a design concepts catalog for the application do-\nmain of enterprise applications. Catalogs such as this one can become useful or-\nganizational assets, and we can readily imagine catalogs for other application do-\nmains such as Big Data (which we employ in Chapter 5) or mobile development.\nwww.EBooksWorld.ir\n246 Appendix A—A Design Concepts Catalog","metadata":{"id":739}}],["9c4ed19c-100e-4ef0-94f2-6f5524594f11",{"pageContent":"mains such as Big Data (which we employ in Chapter 5) or mobile development.\nwww.EBooksWorld.ir\n246 Appendix A—A Design Concepts Catalog\nThe  catalog  presented  here  is  not  intended  to  be  exhaustive,  as  it  contains  \nonly the design concepts used in the Chapter 4 case study. A real catalog, how-\never,  would  contain  a  larger  number  of  design  concepts  with  more  detailed  de-\nscriptions and would be a valuable asset in a software development organization.\nA.7 Further Reading\nReference  architectures  and  deployment  patterns  are  taken  from  Microsoft,  Ap-\nplication Architecture Guide (2nd ed.), October 2009.\nThe  tactics  catalog  is  derived  primarily  from  L.  Bass,  P.  Clements,  and  \nR. Kazman, Software Architecture in Practice (3rd ed.), 2012. Some of these tac-\ntics were earlier described in: F. Bachmann, L. Bass, and R. Nord, “Modifiabil-\nity  Tactics”,  SEI/CMU  Technical  Report  CMU/SEI-2007-TR-002,  2007,  and  J.","metadata":{"id":740}}],["9f5161e8-3ba6-4772-89f0-1edbeb1dd7de",{"pageContent":"tics were earlier described in: F. Bachmann, L. Bass, and R. Nord, “Modifiabil-\nity  Tactics”,  SEI/CMU  Technical  Report  CMU/SEI-2007-TR-002,  2007,  and  J.  \nScott  and  R.  Kazman,  “Realizing  and  Refining  Architectural  Tactics:  Availabil-\nity”, CMU/SEI-2009-TR-006, 2009.\nThe  architectural  patterns  are  taken  from  R.  Buschmann,  K.  Henney,  and  \nD. Schmidt, Pattern-Oriented Software Architecture, Volume 4, Wiley, 2007.\nThe Spring framework is discussed in C. Walls, Spring in Action (4th ed.), \nManning Publications, 2014.\nThe  Swing  framework  is  discussed  in  J.  Elliot,  R.  Eckstein,  D.  Wood,  and  \nB. Cole, Java Swing (2nd ed.), O’Reilly Media, 2002.\nThe Hibernate framework is discussed in C. Bauer and G. King, Java Per-\nsistence with Hibernate, Manning Publications, 2015.\nwww.EBooksWorld.ir\n247\nB\nTactics-Based \nQuestionnaires\nThis  appendix  provides  a  set  of  tactics-based  questionnaires  for  the  seven  most","metadata":{"id":741}}],["2d18352e-4239-4c98-8a20-d15fa979da46",{"pageContent":"sistence with Hibernate, Manning Publications, 2015.\nwww.EBooksWorld.ir\n247\nB\nTactics-Based \nQuestionnaires\nThis  appendix  provides  a  set  of  tactics-based  questionnaires  for  the  seven  most  \nimportant  quality  attributes:  availability,  interoperability,  modifiability,  perfor-\nmance,  security,  testability,  and  usability.  How  do  we  know  that  these  are  the  \nseven most important ones? This decision was based on an analysis of the qual-\nity  attributes  that  were  elicited  from  stakeholders  in  more  than  15  years  of  SEI  \nATAM data. \nIn  addition  to  these  “top  seven”,  we  include  a  tactics-based  questionnaire  \nfor  DevOps,  which  is  a  combination  of  tactics  from  modifiability,  availability,  \nperformance, and testability, to illustrate how simple it is to tailor such question-\nnaires for your own use.\nB.1 Using the Questionnaires\nThese questionnaires could be used by an analyst, who poses each question, in turn,","metadata":{"id":742}}],["4d0521f7-2bd5-4f35-b990-731216bf2f44",{"pageContent":"naires for your own use.\nB.1 Using the Questionnaires\nThese questionnaires could be used by an analyst, who poses each question, in turn, \nto the architect and records the responses, as a means of conducting a lightweight \narchitecture review. Alternatively, the questionnaires could be employed as a set of \nreflective questions, that you could, on your own, use to examine your architecture.\nIn either case, to use these questionnaires, simply follow these four steps:\nwww.EBooksWorld.ir\n248 Appendix B—Tactics-Based Questionnaires\n1. For each tactics question, fill the “Supported” column with Y if the tactic is \nsupported in the architecture and with N otherwise. The tactic name in the \n“Tactics Question” column appears in bold.\n2. If the answer in the “Supported” column is Y, then in the “Design Decisions \nand Location” column describe the specific design decisions made to support \nthe tactic and enumerate where these decisions are manifested (located) in","metadata":{"id":743}}],["740ddef6-a0d2-4261-aca4-d73028b0361c",{"pageContent":"and Location” column describe the specific design decisions made to support \nthe tactic and enumerate where these decisions are manifested (located) in \nthe architecture. For example, indicate which code modules, frameworks, or \npackages implement this tactic.\n3. In the “Risk” column, indicate the anticipated/experienced difficulty or risk \nof implementing the tactic using a (H = high, M = medium, L = low) scale. \nFor example, a tactic that was of medium difficulty or risk to implement (or \nwhich is anticipated to be of medium difficulty, if it has not yet been imple-\nmented) would be labeled M.\n4. In the “Rationale” column, describe the rationale for the design decisions made \n(including a decision to not use this tactic). Briefly explain the implications of \nthis decision. For example, you might explain the rationale and implications of \nthe decision in terms of the effort on cost, schedule, evolution, and so forth.\nB.2    Availability\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign","metadata":{"id":744}}],["8f0ebd60-2d7e-4ca1-b341-009022fcf782",{"pageContent":"the decision in terms of the effort on cost, schedule, evolution, and so forth.\nB.2    Availability\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Detect \nfaults\nDoes the system use \nping/echo to detect a \nfailure of a component or \nconnection, or network \ncongestion? \n2Does the system use a \ncomponent to monitor \nthe state of health of other \nparts of the system? A \nsystem monitor can de-\ntect failure or congestion \nin the network or other \nshared resources, such \nas from a denial-of-ser-\nvice attack.\n3Does the system use a \nheartbeat—a periodic \nmessage exchange be-\ntween a system monitor \nand a process—to detect \na failure of a component \nor connection, or network \ncongestion?\n \n \n4Does the system use a \ntime stamp (as in section \nA.4.1) to detect incorrect \nsequences of events in \ndistributed systems?\n \nwww.EBooksWorld.ir\nB.2    Availability 249\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions","metadata":{"id":745}}],["b687089a-2813-4054-b43c-f641abf60e14",{"pageContent":"sequences of events in \ndistributed systems?\n \nwww.EBooksWorld.ir\nB.2    Availability 249\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n5Does the system do \nany sanity checking: \nchecking the validity or \nreasonableness of a \ncomponent’s operations \nor outputs?\n \n6Does the system do \ncondition monitoring, \nchecking conditions in a \nprocess or device, or vali-\ndating assumptions made \nduring the design?\n \n7Does the system use \nvoting to check that \nreplicated components \nare producing the same \nresults? The replicated \ncomponents may be iden-\ntical replicas, functionally \nredundant, or analytically \nredundant.\n \n8Do you use exception de-\ntection to detect a system \ncondition that alters the \nnormal flow of execution \n(e.g., system exception, \nparameter fence, parame-\nter typing, timeout)?\n \n9Can the system do a \nself-test to test itself for \ncorrect operation?\n \n10Recover \nfrom faults \n(prepara-\ntion and \nrepair)\nDoes the system employ \nactive redundancy (hot","metadata":{"id":746}}],["5cbc5be6-f7a0-4fec-9f65-e3774abf54f0",{"pageContent":"ter typing, timeout)?\n \n9Can the system do a \nself-test to test itself for \ncorrect operation?\n \n10Recover \nfrom faults \n(prepara-\ntion and \nrepair)\nDoes the system employ \nactive redundancy (hot \nspare)? In active redun-\ndancy, all nodes in a pro-\ntection group (a group of \nnodes where one or more \nnodes are “active”, with \nthe remainder serving as \nredundant spares) receive \nand process identical \ninputs in parallel, allowing \nredundant spares to main-\ntain synchronous state \nwith the active node(s).\n11Does the system employ \npassive redundancy \n(warm spare)? In passive \nredundancy, only the \nactive members of the \nprotection group process \ninput traffic; one of their \nduties is to provide the \nredundant spare(s) with \nperiodic state updates.\n(continues)\nwww.EBooksWorld.ir\n250 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n12Does the system employ \nspares (cold spares)? \nHere redundant spares \nof a protection group","metadata":{"id":747}}],["e8734597-ed0c-430c-846e-5a3649ad5d7e",{"pageContent":"#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n12Does the system employ \nspares (cold spares)? \nHere redundant spares \nof a protection group \nremain out of service until \na failover occurs, at which \npoint a power-on-reset \nprocedure is initiated \non the redundant spare \nprior to its being placed in \nservice.\n13Does the system employ \nexception handling to \ndeal with faults? Typically \nthe handling involves \neither reporting the fault \nor handling it, potentially \nmasking the fault by cor-\nrecting the cause of the \nexception and retrying.\n \n14Does the system employ \nrollback, so that it can re-\nvert to a previously saved \ngood state (the “rollback \nline”) in the event of a \nfault?\n15Can the system perform \nin-service software \nupgrades to execut-\nable code images in a \nnon-service-affecting \nmanner?\n16Does the system system-\natically retry in cases \nwhere the component or \nconnection failure may be \ntransient?\n17Can the system simply \nignore faulty behavior","metadata":{"id":748}}],["aca6474e-222d-41c0-8b20-8da2e81ea072",{"pageContent":"non-service-affecting \nmanner?\n16Does the system system-\natically retry in cases \nwhere the component or \nconnection failure may be \ntransient?\n17Can the system simply \nignore faulty behavior \n(e.g., ignore messages \nsent from a source when \nit is determined that those \nmessages are spurious)?\n18Does the system have \na policy of degradation \nwhen resources are com-\npromised, maintaining \nthe most critical system \nfunctions in the presence \nof component failures, \nand dropping less critical \nfunctions?\nwww.EBooksWorld.ir\nB.2    Availability 251\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n19Does the system have \nconsistent policies and \nmechanisms for recon-\nfiguration after failures, \nreassigning responsi-\nbilities to the resources \nleft functioning, while \nmaintaining as much \nfunctionality as possible?\n20Recover \nfrom faults \n(reintro-\nduction)\nCan the system operate \na previously failed or \nin-service upgraded \ncomponent in a “shadow \nmode” for a predefined","metadata":{"id":749}}],["5d7ff462-815c-4adb-994e-5ddb8217a94e",{"pageContent":"maintaining as much \nfunctionality as possible?\n20Recover \nfrom faults \n(reintro-\nduction)\nCan the system operate \na previously failed or \nin-service upgraded \ncomponent in a “shadow \nmode” for a predefined \ntime prior to reverting the \ncomponent back to an \nactive role?\n21If the system uses active \nor passive redundancy, \ndoes it also employ state \nresynchronization, to \nsend state information \nfrom active to standby \ncomponents?\n22Does the system employ \nescalating restart—\nthat is, does it recover \nfrom faults by varying \nthe granularity of the \ncomponent(s) restarted \nand minimizing the level \nof service affected?\n23Can message process-\ning and routing portions \nof the system employ \nnonstop (as in section \nA .4.1)  forwarding, where \nfunctionality is split into \nsupervisory and data \nplanes? In this case, if a \nsupervisor fails, a router \ncontinues forwarding \npackets along known \nroutes while protocol \ninformation is recovered \nand validated.\n \n24Prevent \nfaults\nCan the system remove \ncomponents from ser-","metadata":{"id":750}}],["16b83cd0-9a58-4e37-91df-42825a3c150e",{"pageContent":"supervisor fails, a router \ncontinues forwarding \npackets along known \nroutes while protocol \ninformation is recovered \nand validated.\n \n24Prevent \nfaults\nCan the system remove \ncomponents from ser-\nvice, temporarily placing \na system component in \nan out-of-service state, \nfor the purpose of miti-\ngating potential system \nfailures? \n(continues)\nwww.EBooksWorld.ir\n252 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n25Does the system employ \ntransactions—bundling \nstate updates so that \nasynchronous  mes sages \nexchanged between \ndistributed components \nare atomic, consistent, \nisolated, and durable?\n26Does the system use \na predictive model \nto monitor the state of \nhealth of a component to \nensure that the system is \noperating within nominal \nparameters? When condi-\ntions are detected that are \npredictive of likely future \nfaults, the model initiates \ncorrective action.\n27Does the system pre-\nvent exceptions from","metadata":{"id":751}}],["ce363a71-8dd1-4199-841a-021651590e61",{"pageContent":"operating within nominal \nparameters? When condi-\ntions are detected that are \npredictive of likely future \nfaults, the model initiates \ncorrective action.\n27Does the system pre-\nvent exceptions from \noccurring by, for example, \nmasking a fault, using \nsmart pointers, abstract \ndata types, or wrappers?\n28Has the system been \ndesigned to increase \nits competence set, for \nexample by designing a \ncomponent to handle more \ncases—faults—as part of \nits normal operation?\nB.3    Interoperability\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1LocateDoes the system have \na way to discover ser-\nvices (typically through \na directory service)?\n2Manage \ninterfaces\nDoes the system have a \nway to orchestrate the \nactivities of services? \nThat is, does it have a \ncontrol mechanism to \ncoordinate, manage, \nand sequence the invo-\ncation of services?\nwww.EBooksWorld.ir\nB.4    Modifiability 253\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation","metadata":{"id":752}}],["ffcad2ec-3d6f-4a1d-8e2f-798273c89246",{"pageContent":"coordinate, manage, \nand sequence the invo-\ncation of services?\nwww.EBooksWorld.ir\nB.4    Modifiability 253\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n3Does the system have \na way to tailor inter-\nfaces? For example, \ncan it add or remove \ncapabilities to an inter-\nface such as transla-\ntion, buffering, or data \nsmoothing?\n \nB.4    Modifiability\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Reduce \nsize of a \nmodule\nDo you make modules \nsimpler by splitting the \nmodule? For example, \nif you have a large, \ncomplex module, can \nyou split it into two (or \nmore) smaller, simpler \nmodules?\n2Increase \ncohesion\nDoes the system \nconsistently support \nincreasing semantic \ncoherence? For exam-\nple, if responsibilities in \na module do not serve \nthe same purpose, they \nshould be placed in \ndifferent modules. This \nmay involve creating a \nnew module or moving \na responsibility to an \nexisting module. \n3Reduce \ncoupling","metadata":{"id":753}}],["e84ed565-fc5a-4fce-b23d-62cb9097c075",{"pageContent":"a module do not serve \nthe same purpose, they \nshould be placed in \ndifferent modules. This \nmay involve creating a \nnew module or moving \na responsibility to an \nexisting module. \n3Reduce \ncoupling\nDoes the system con-\nsistently encapsulate \nfunctionality? This typ-\nically involves isolating \nthe functionality under \nscrutiny and introducing \nan explicit interface to it.\n(continues)\nwww.EBooksWorld.ir\n254 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n4Does the system consis-\ntently use an interme-\ndiary to keep modules \nfrom being too tightly \ncoupled? For example, \nif A calls concrete func-\ntionality C, you might in-\ntroduce an abstraction B \nthat mediates between \nA and C. \n5Do you restrict de-\npendencies between \nmodules in a systematic \nway? Or is any system \nmodule free to interact \nwith any other module?\n6When two or more \nunrelated modules \nchange together—that \nis, when they are \nregularly affected by the","metadata":{"id":754}}],["c0d4d29f-e64c-4553-801f-2ebcd3a6e024",{"pageContent":"modules in a systematic \nway? Or is any system \nmodule free to interact \nwith any other module?\n6When two or more \nunrelated modules \nchange together—that \nis, when they are \nregularly affected by the \nsame changes—do you \nregularly refactor the \nfunctionality to isolate \nthe shared functionality \nas common code in a \ndistinct module?\n \n7Does the system \nabstract common \nservices, in cases \nwhere you are providing \nsev eral similar services? \nFor example, this \ntechnique is often used \nwhen you want your \nsystem to be portable \nacross operating sys-\ntems, hardware, or other \nenvironment variations.\n8Defer \nbinding\nDoes the system \nregularly defer binding \nof important function-\nality so that it can be \nreplaced later in the life \ncycle, perhaps even \nby end users? For \nexample, do you use \nplug-ins, add-ons, or \nuser scripting to extend \nthe functionality of the \nsystem?\nwww.EBooksWorld.ir\nB.5    Performance 255\nB.5    Performance\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)\nRisk\nDesign \nDecisions \nand \nLocation\nRationale and","metadata":{"id":755}}],["6a14f90b-4f9c-4311-b06e-6eac9abb5c3e",{"pageContent":"the functionality of the \nsystem?\nwww.EBooksWorld.ir\nB.5    Performance 255\nB.5    Performance\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)\nRisk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Control \nresource \ndemand\nIf your inputs are a \ncontinuous stream of \ndata, does the system \nmanage the sampling \nrate? That is, is it pos-\nsible to sample the data \nat varying rates (with \nconcomitant changes in \naccuracy/fidelity)?\n2Does the system mon-\nitor and limit its event \nresponse? Does the \nsystem limit the number \nof events it responds \nto in a time period, to \nensure predictable \nresponses for the \nevents that are actually \nserviced?\n \n3Given that you may \nhave more requests for \nservice than available \nresources, does the sys-\ntem prioritize events?\n4Does the system \nreduce the overhead \nof responding to service \nrequests by, for exam-\nple, removing interme-\ndiaries or co-locating \nresources?\n \n5Does the system \nmonitor and bound \nexecution time? \nMore generally, do \nyou bound the amount \nof any resource (e.g.,","metadata":{"id":756}}],["ab928191-78b1-46c8-99b4-1b213739c741",{"pageContent":"requests by, for exam-\nple, removing interme-\ndiaries or co-locating \nresources?\n \n5Does the system \nmonitor and bound \nexecution time? \nMore generally, do \nyou bound the amount \nof any resource (e.g., \nmemory, CPU, storage, \nbandwidth, connections, \nlocks) expended in \nresponse to requests for \nservices? \n6Do you increase \nresource efficiency? \nFor example, do you \nregularly improve the \nefficiency of algorithms \nin critical areas, to \ndecrease latency and \nimprove throughput?\n(continues)\nwww.EBooksWorld.ir\n256 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)\nRisk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n7Manage \nresources\nCan the system \nseamlessly increase \nresources (e.g., CPU, \nmemory, network band-\nwidth)?\n8Can the system intro-\nduce concurrency? \nFor example, does it \nsupport the seamless \naddition of parallel pro-\ncessing streams so that \nmore requests for ser-\nvices can be processed \nconcurrently?\n \n9Does the system main-\ntain multiple copies of","metadata":{"id":757}}],["b6c7d547-3e5f-4613-9cb2-afc737ea35b8",{"pageContent":"For example, does it \nsupport the seamless \naddition of parallel pro-\ncessing streams so that \nmore requests for ser-\nvices can be processed \nconcurrently?\n \n9Does the system main-\ntain multiple copies of \ndata (e.g., by replicating \ndatabases or using \ncaches) to decrease \ncontention for frequently \naccessed data?\n10Does the system main-\ntain multiple copies of \ncomputations (e.g., by \nkeeping a pool of serv-\ners in a server farm) to \ndecrease contention \nfor frequently ac-\ncessed computational \nresources?\n \n11Does the system bound \nqueue sizes? That is, \ndo you limit the number \nof events placed in \na queue, waiting for \nservices?\n \n12Does the system sched-\nule resources, particu-\nlarly scarce resources, \nso that they may be \nallocated according to \nan explicit scheduling \npolicy?\nwww.EBooksWorld.ir\nB.6    Security 257\nB.6    Security\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Detecting \nattacks\nDoes the system sup-\nport the detection of \nintrusions? An example","metadata":{"id":758}}],["72713bb7-76d1-42fd-9ea5-1146339e277e",{"pageContent":"#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Detecting \nattacks\nDoes the system sup-\nport the detection of \nintrusions? An example \nis comparing network \ntraffic or service request \npatterns within a system \nto a set of signatures or \nknown patterns of mali-\ncious behavior stored in \na database.\n2Does the system \nsupport the detection \nof denial-of-service \nattacks? An example is \nthe comparison of the \npattern or signature of \nnetwork traffic coming \ninto a system to historic \nprofiles of known deni-\nal-of-service attacks.\n3Does the system \nsupport the verification \nof message integrity? \nAn example is the use \nof techniques such as \nchecksums or hash val-\nues to verify the integrity \nof messages, resource \nfiles, deployment files, \nand configuration files.\n4Does the system \nsupport the detection \nof message delays? \nAn example is checking \nthe time that it takes to \ndeliver a message.\n5Resisting \nattacks\nDoes the system sup-\nport the identification","metadata":{"id":759}}],["697c9321-ee7d-4fd5-8b1f-c5fdf21cb290",{"pageContent":"4Does the system \nsupport the detection \nof message delays? \nAn example is checking \nthe time that it takes to \ndeliver a message.\n5Resisting \nattacks\nDoes the system sup-\nport the identification \nof actors? An example \nis identifying the source \nof any external input to \nthe system.\n6Does the system sup-\nport the authentication \nof actors? An example \nis ensuring that an actor \n(a user or a remote com-\nputer) is actually who or \nwhat it purports to be.\n(continues)\nwww.EBooksWorld.ir\n258 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n7Does the system support \nthe authorization of \nactors? An example \nis ensuring that an \nauthenticated actor has \nthe rights to access and \nmodify either data or \nservices. \n8Does the system support \nlimiting access? An ex-\nample is controlling what \nand who may access \nwhich parts of a system, \nsuch as processors, \nmemory, and network \nconnections.\n \n9Does the system support \nlimiting exposure? An","metadata":{"id":760}}],["d09d7597-6402-4d10-918b-4c3d0b995fe0",{"pageContent":"limiting access? An ex-\nample is controlling what \nand who may access \nwhich parts of a system, \nsuch as processors, \nmemory, and network \nconnections.\n \n9Does the system support \nlimiting exposure? An \nexample is reducing the \nprobability of a success-\nful attack, or restricting \nthe amount of potential \ndamage, by concealing \nfacts about a system \n(“security by obscurity”) \nor dividing and distrib-\nuting critical resources \n(“don’t put all your eggs \nin one basket”).\n10Does the system sup-\nport data encryption? \nAn example is to apply \nsome form of encryption \nto data and to commu-\nnication.\n11Does the system \nvalidate input in a \nconsistent, system-wide \nway? An example is the \nuse of a security frame-\nwork or validation class \nto perform actions such \nas filtering, canonical-\nization, and escaping of \nexternal input.\nwww.EBooksWorld.ir\nB.6    Security 259\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n12Does the system design \nconsider the separation","metadata":{"id":761}}],["a41e2a1f-ddbd-4957-963a-f7f4a56cd465",{"pageContent":"www.EBooksWorld.ir\nB.6    Security 259\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n12Does the system design \nconsider the separation \nof entities? An example \nis the physical separa-\ntion of different servers \nattached to different \nnetworks, the use of \nvirtual machines, or an \n“air gap”.\n \n13Does the system \nsupport changes in the \ndefault settings? An \nexample is forcing the \nuser to change settings \nassigned by default.\n \n14Reacting \nto attacks\nDoes the system sup-\nport revoking access? \nAn example is limiting \naccess to sensitive \nresources, even for nor-\nmally legitimate users \nand uses, if an attack is \nsuspected.\n15Does the system sup-\nport locking access? \nAn example is limiting \naccess to a resource if \nthere are repeated failed \nattempts to access it.\n16Does the system sup-\nport informing actors? \nAn example is notifying \noperators, other person-\nnel, or cooperating sys-\ntems when an attack is \nsuspected or detected. \n17Recover-\ning from \nattacks","metadata":{"id":762}}],["2852bd1f-a790-49cb-ac46-0a77b21b39c1",{"pageContent":"16Does the system sup-\nport informing actors? \nAn example is notifying \noperators, other person-\nnel, or cooperating sys-\ntems when an attack is \nsuspected or detected. \n17Recover-\ning from \nattacks\nDoes the system \nsupport maintaining an \naudit trail? An example \nis keeping a record of \nuser and system actions \nand their effects, to help \ntrace the actions of, and \nto identify, an attacker\nwww.EBooksWorld.ir\n260 Appendix B—Tactics-Based Questionnaires\nB.7   Testability\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Control \nand \nobserve \nsystem \nstate\nDoes the system or the \nsystem components \nprovide specialized \ninterfaces to facilitate \ntesting and monitoring?\n2Does the system \nprovide mechanisms \nthat allow information \nthat crosses an interface \nto be recorded so that \nit can be used later \nfor testing purposes \n(record/playback)?\n3Is the state of the \nsystem, subsystem, \nor modules stored in a \nsingle place to facilitate \ntesting (localized state \nstorage)?","metadata":{"id":763}}],["55bfa298-124c-406a-bf21-bf624259d97d",{"pageContent":"it can be used later \nfor testing purposes \n(record/playback)?\n3Is the state of the \nsystem, subsystem, \nor modules stored in a \nsingle place to facilitate \ntesting (localized state \nstorage)?\n4Can you abstract data \nsources—for example, \nby abstracting inter-\nfaces? Abstracting \nthe interfaces lets you \nsubstitute test data more \neasily.\n5Can the system be \nexecuted in isolation (a \nsandbox) to experiment \nor test it without worry-\ning about having to undo \nthe consequences of the \nexperiment?\n \n6Are executable asser-\ntions used in the system \ncode to indicate when \nand where a program is \nin a faulty state?\n \n7Limit \ncomplexity\nIs the system designed \nin such a way that \nstructural complexity \nis limited? Examples \ninclude avoiding cyclic \ndependencies, reducing \ndependencies, and us-\ning techniques such as \ndependency injection.\n \nwww.EBooksWorld.ir\nB.8    Usability 261\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n8Does the system include \nfew or no (i.e., limited)","metadata":{"id":764}}],["df7b5d4e-b034-4c62-b8d0-346237018fc4",{"pageContent":"www.EBooksWorld.ir\nB.8    Usability 261\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n8Does the system include \nfew or no (i.e., limited) \nsources of nondeter-\nminism? This helps \nto limit the behavioral \ncomplexity that comes \nwith unconstrained par-\nallelism, which in turn \nsimplifies testing.\nB.8    Usability\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n1Support-\ning user \ninitiative\nDoes the system \nsupport operation can-\nceling?\n2Does the system \nsupport operation \nundoing?\n3Does the system \nsupport operations to \nbe paused and later \nresumed? Examples are \npausing the download of \na file in a web browser \nand allowing the user to \nretry an incomplete (and \nfailed) download.\n4Does the system \nsupport operations to \nbe applied to groups of \nobjects (aggregation)? \nFor example, does it \nallow you to see the \ncumulative size of a \nnumber of files that \nare selected in a file \nbrowser window?\n \n(continues)","metadata":{"id":765}}],["6f572522-ad49-4434-84fd-0435f54f3432",{"pageContent":"be applied to groups of \nobjects (aggregation)? \nFor example, does it \nallow you to see the \ncumulative size of a \nnumber of files that \nare selected in a file \nbrowser window?\n \n(continues)\nwww.EBooksWorld.ir\n262 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale and \nAssumptions\n5Support \nsystem \ninitiative\nDoes the system \nprovide assistance to \nthe user based on the \ntasks that he or she is \nperforming (by main-\ntaining a task model)? \nExamples include:\n ■\nValidation of input data\n ■\nDrawing user attention \nto changes in the UI\n ■\nMaintaining UI \nconsistency\n ■\nAdding toolbars and \nmenus to help users \nfind functionality pro-\nvided by the UI\n ■\nUsing wizards or other \ntechniques to guide \nusers in performing \nkey user scenarios\n6Does the system \nsupport adjustments to \nthe UI with respect to \nthe class of users (by \nmaintaining a user \nmodel)? Examples \ninclude supporting UI \ncustomization (including \nlocalization) and sup-\nporting accessibility.","metadata":{"id":766}}],["3d0e68df-9b43-4c9a-bfe7-36bf92b54d2e",{"pageContent":"support adjustments to \nthe UI with respect to \nthe class of users (by \nmaintaining a user \nmodel)? Examples \ninclude supporting UI \ncustomization (including \nlocalization) and sup-\nporting accessibility.\n \n7Does the system \nprovide appropriate \nfeedback to the user \nbased on the system \ncharacteristics (by \nmaintaining a system \nmodel)? Examples \ninclude:\n ■\nAvoiding blocking the \nuser while handling \nlong-running requests\n ■\nProviding feedback on \naction progress (i.e., \nprogress bars)\n ■\nDisplaying user-\nfriendly errors without \nexposing sensitive \ndata by managing \nexceptions\n ■\nAdjusting the UI with \nrespect to screen size \nand resolution \nwww.EBooksWorld.ir\nB.9    DevOps 263\nB.9    DevOps\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale \nand \nAssumptions\n1Testability: \ncontrol and \nobserve \nsystem \nstate\nDoes the system or the \nsystem components \nprovide specialized \ninterfaces to facilitate \ntesting and monitoring?\n2Does the system \nprovide mechanisms \nthat allow information","metadata":{"id":767}}],["2256b904-a211-4522-9d1d-429eb3330586",{"pageContent":"control and \nobserve \nsystem \nstate\nDoes the system or the \nsystem components \nprovide specialized \ninterfaces to facilitate \ntesting and monitoring?\n2Does the system \nprovide mechanisms \nthat allow information \nthat crosses an interface \nto be recorded so that \nit can be used later \nfor testing purposes \n(record/playback)?\n3Can the system be \nexecuted in isolation (a \nsandbox) to experiment \nor test it without worry-\ning about having to undo \nthe consequences of the \nexperiment?\n \n4Perfor-\nmance: \nmanage \nresources \nCan the system \nseamlessly increase \nresources (e.g., CPU, \nmemory, network band-\nwidth)?\n5Can the system intro-\nduce concurrency? \nFor example, does it \nsupport the seamless \naddition of parallel pro-\ncessing streams so that \nmore requests for ser-\nvices can be processed \nconcurrently?\n6Does the system main-\ntain multiple copies of \ndata (e.g., by replicating \ndatabases or using \ncaches) to decrease \ncontention for frequently \naccessed data?\n(continues)\nwww.EBooksWorld.ir\n264 Appendix B—Tactics-Based Questionnaires\n#","metadata":{"id":768}}],["204cc75e-2fd7-411c-b7a2-e264ef804a3a",{"pageContent":"data (e.g., by replicating \ndatabases or using \ncaches) to decrease \ncontention for frequently \naccessed data?\n(continues)\nwww.EBooksWorld.ir\n264 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale \nand \nAssumptions\n7Does the system main-\ntain multiple copies \nof computations (e.g., \nby keeping a pool of \nservers in a server \nfarm) to decrease \ncontention for frequently \naccessed computational \nresources?\n \n8Does the system sched-\nule resources, particu-\nlarly scarce resources, \nso that they may be \nallocated according to \nan explicit scheduling \npolicy?\n9Perfor-\nmance: \ncontrol \nresource \ndemand\nDoes the system \nreduce overhead of \nresponding to service \nrequests by, for exam-\nple, removing interme-\ndiaries or co-locating \nresources?\n \n10If your inputs are a \ncontinuous stream of \ndata, does the system \nmanage the sampling \nrate?\nThat is, is it possible for \nyou to sample the data \nat varying rates (with \nconcomitant changes in \naccuracy/fidelity)?","metadata":{"id":769}}],["e90192ed-f788-47ac-86fe-fbec7a446b7b",{"pageContent":"continuous stream of \ndata, does the system \nmanage the sampling \nrate?\nThat is, is it possible for \nyou to sample the data \nat varying rates (with \nconcomitant changes in \naccuracy/fidelity)?\n11Does the system \nmonitor and limit its \nevent response? That \nis, does the system limit \nthe number of events \nit responds to in a \ntime period, to ensure \npredictable responses \nfor the events that are \nactually serviced?\n \n12Given that you may \nhave more requests for \nservice than available \nresources, does the sys-\ntem prioritize events?\nwww.EBooksWorld.ir\nB.9    DevOps 265\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale \nand \nAssumptions\n13Modifiabil-\nity: reduce \ncoupling\nDoes the system con-\nsistently encapsulate \nfunctionality? This typ-\nically involves isolating \nthe functionality under \nscrutiny and introducing \nan explicit interface to it.\n \n14Does the system \nabstract common \nservices, in cases \nwhere you are providing \nsev eral similar services? \nFor example, this","metadata":{"id":770}}],["d10a8504-1b58-4196-ace4-594907d9a256",{"pageContent":"the functionality under \nscrutiny and introducing \nan explicit interface to it.\n \n14Does the system \nabstract common \nservices, in cases \nwhere you are providing \nsev eral similar services? \nFor example, this \ntechnique is often used \nwhen you want your \nsystem to be portable \nacross operating sys-\ntems, hardware, or other \nenvironment variations.\n15Modifiabil-\nity: defer \nbinding\nDoes the system \nregularly defer binding \nof important function-\nality so that it can be \nreplaced later in the life \ncycle, perhaps even \nby end users? For \nexample, do you use \nplug-ins, add-ons, or \nuser scripting to extend \nthe functionality of the \nsystem?\n16Availability: \ndetect \nfaults\nDoes the system use a \ncomponent to moni-\ntor the state of health \nof other parts of the \nsystem? A system mon-\nitor can detect failure \nor congestion in the \nnetwork or other shared \nresources, such as \nfrom a denial-of-service \nattack.\n17Do you use exception \ndetection to detect a \nsystem condition that \nalters the normal flow of \nexecution (e.g., system","metadata":{"id":771}}],["b5e7cc43-3bb2-488e-9c0b-5633f576b231",{"pageContent":"network or other shared \nresources, such as \nfrom a denial-of-service \nattack.\n17Do you use exception \ndetection to detect a \nsystem condition that \nalters the normal flow of \nexecution (e.g., system \nexception, parameter \nfence, parameter typing, \ntimeout)?\n(continues)\nwww.EBooksWorld.ir\n266 Appendix B—Tactics-Based Questionnaires\n#\nTactics \nGroupTactics Question\nSupported? \n(Y/N)Risk\nDesign \nDecisions \nand \nLocation\nRationale \nand \nAssumptions\n18Does the system use \nvoting to check that \nreplicated components \nare producing the same \nresults? The replicated \ncomponents may be \nidentical replicas, func-\ntionally redundant, or \nanalytically redundant.\n19Availability: \nrecover \nfrom faults \n(prepara-\ntion and \nrepair)\nDoes the system employ \nrollback, so that it can \nrevert to a previously \nsaved good state (the \n“rollback line”) in the \nevent of a fault?\n20Does the system employ \nactive redundancy \n(hot spare)? In active \nredundancy, all nodes \nin a protection group (a \ngroup of nodes where \none or more nodes \nare “active”, with the","metadata":{"id":772}}],["d6b0453a-4931-4e41-9759-71886b32d811",{"pageContent":"event of a fault?\n20Does the system employ \nactive redundancy \n(hot spare)? In active \nredundancy, all nodes \nin a protection group (a \ngroup of nodes where \none or more nodes \nare “active”, with the \nremainder serving as re-\ndundant spares) receive \nand process identical \ninputs in parallel, allow-\ning redundant spares to \nmaintain synchronous \nstate with the active \nnode(s).\n21Does the system have \nconsistent policies \nand mechanisms for \nreconfiguration after \nfailures, reassigning \nresponsibilities to the \nresources left function-\ning, while maintaining \nas much functionality as \npossible?\n22Does the system employ \nexception handling \nto deal with faults? \nTypically, the handling \ninvolves either reporting \nthe fault or handling it, \npotentially masking the \nfault by correcting the \ncause of the exception \nand retrying.\nwww.EBooksWorld.ir\nB.10 Further Reading 267\nB.10 Further Reading\nThe tactics catalog from which the questionnaires are derived can be found in L. Bass,","metadata":{"id":773}}],["10d97444-c0d1-40fc-80fc-1fdf10ba437e",{"pageContent":"cause of the exception \nand retrying.\nwww.EBooksWorld.ir\nB.10 Further Reading 267\nB.10 Further Reading\nThe tactics catalog from which the questionnaires are derived can be found in L. Bass, \nP. Clements, and R. Kazman, Software Architecture in Practice (3rd ed.), 2012.\nAn  analysis  of  quality  attribute  data  from  SEI  ATAMs,  showing  which  \nqualities  are  the  most  common  in  practice,  can  be  found  in  I.  Ozkaya,  L.  Bass,  \nR. Sangwan, and R. Nord, “Making Practical Use of Quality Attribute Informa-\ntion”, IEEE  Software,  March/April  2008,  and  in  a  later  study  by  S.  Bellomo,  \nI.  Gorton,  and  R.  Kazman,  “Insights  from  15  Years  of  ATAM  Data:  Towards  \nAgile Architecture”, IEEE Software, 32:5, 38-45, September/October 2015.\nThe  set  of  DevOps  tactics  was  developed  and  presented  in  H-M  Chen,  \nR. Kazman, S. Haziyev, V. Kropov, and D. Chtchourov, “Architectural Support for \nDevOps in a Neo-Metropolis BDaaS Platform”, IEEE 34th Symposium on Reliable","metadata":{"id":774}}],["7d83b8db-07af-43ee-abaf-6263344b91be",{"pageContent":"R. Kazman, S. Haziyev, V. Kropov, and D. Chtchourov, “Architectural Support for \nDevOps in a Neo-Metropolis BDaaS Platform”, IEEE 34th Symposium on Reliable \nDistributed Systems Workshop (SRDSW), Montreal, Canada, September 2015.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n269\nGlossary\nActive Reviews for Intermediate Design (ARID) method A method in \nwhich the architecture design (or part of it) is presented to a group of review-\ners—typically the engineers who will use the design. After the presentation, a set \nof scenarios is selected. The reviewers attempt to use the elements in the archi-\ntecture to satisfy the scenarios. The reviewers are asked to write code or pseudo-\ncode or to create sequence diagrams for the purpose of identifying interfaces. \nThis method can be used in preparation for element interaction design.\nADD See Attribute Driven Design method.\nADL See Architecture Description Language.","metadata":{"id":775}}],["3d118a21-9fd5-47cf-95ae-b879ecd6050e",{"pageContent":"This method can be used in preparation for element interaction design.\nADD See Attribute Driven Design method.\nADL See Architecture Description Language.\nAnalysis The process of breaking a complex entity into its constituent parts as \na means of understanding it. Analysis is used at different moments in the design \nprocess; for example, the inputs are analyzed to make design decisions and the \nresulting architecture is also analyzed to gauge if it is appropriate to satisfy its \nassociated drivers.\nApplication framework A reusable software element, constructed out of pat-\nterns and tactics, that provides generic functionality addressing recurring domain \nand quality attribute concerns across a broad range of applications. Also called a \nframework.\nArchitectural concern An additional aspect that needs to be considered as \npart of architectural design but that is not expressed as a traditional requirement. \nExamples include general concerns, such as creating an overall system structure,","metadata":{"id":776}}],["269ecc78-9c52-4514-ba30-97822a931e7c",{"pageContent":"part of architectural design but that is not expressed as a traditional requirement. \nExamples include general concerns, such as creating an overall system structure, \nand more specific concerns, such as managing exceptions or generating logs. \nOther architectural concerns include internal requirements, which are seldom \nexpressed by customers, and issues resulting from analysis activities, such as \narchitectural evaluations.\nArchitectural design The activity of making decisions to translate ideas from \nthe world of needs (architectural drivers) to the world of solutions, in terms of \nstructures.\nwww.EBooksWorld.ir\n270 Glossary \nArchitectural drivers The design purpose, architecturally significant require-\nments, and architectural concerns that serve as an input to the design process. \nThese considerations are critical to the success of the system and, as such, they \ndrive and shape the architecture.\nArchitectural evaluation A technique to analyze and assess the value of \narchitectural decisions.","metadata":{"id":777}}],["947908fa-df0e-41cd-81ea-5348c4194bfc",{"pageContent":"drive and shape the architecture.\nArchitectural evaluation A technique to analyze and assess the value of \narchitectural decisions.\nArchitectural pattern See Patterns (Architectural and Design).\nArchitecturally significant requirement (ASR) A system requirement that \nhas a particular importance with respect to the software architecture. ASRs in-\nclude quality attributes, primary functional requirements, and constraints.\nArchitecture Description Language (ADL) A notation to document an archi-\ntecture. ADLs typically employ both a graphical notation and a (formally defined) \ntextual notation to describe an architecture—primarily the computational (runtime) \ncomponents and interactions among them—and its properties.\nArchitecture Tradeoff Analysis Method (ATAM) An established method for \nanalyzing architectures, driven by scenarios. Its purpose is to assess the conse-\nquences of architectural decisions in light of quality attribute requirements and \nbusiness goals.","metadata":{"id":778}}],["6b6f88d1-f918-4fe5-824b-7fa8b4113938",{"pageContent":"analyzing architectures, driven by scenarios. Its purpose is to assess the conse-\nquences of architectural decisions in light of quality attribute requirements and \nbusiness goals.\nARID See Active Reviews for Intermediate Design method.\nASR See Architecturally significant requirement.\nATAM See Architecture Tradeoff Analysis Method.\nAttribute-Driven Design (ADD) method An iterative architecture design \nmethod that takes drivers as inputs and produces an architecture. In each iteration, \nstructures are produced by refining elements identified in previous iterations. \nThese structures are created primarily from design concepts, which are selected \nand instantiated to address a subset of the drivers that are selected for the iteration.\nBig Design Up Front (BDUF) The (now largely discredited) practice of at-\ntempting to do all of the architectural design at the beginning of a project. It is \nusually associated with a waterfall software development life cycle.","metadata":{"id":779}}],["65a66fb3-9480-427f-be67-226d1e7bd628",{"pageContent":"tempting to do all of the architectural design at the beginning of a project. It is \nusually associated with a waterfall software development life cycle.\nBrownfield development Software development that builds upon an existing \nasset. Contrast with greenfield development.\nConstraint A decision over which the architect has little or no control. It may \nbe either technical or organizational.\nCost Benefit Analysis Method (CBAM) A method that associates costs, ben-\nefits, and schedule implications with strategies chosen to make improvements in \nan architecture. This method is used to rank the strategies, as a means of finding \nan optimal set of strategies to implement in the next iteration.\nwww.EBooksWorld.ir\nGlossary 271\nDesign concept The building blocks from which the structures that make up \nthe architecture are created. Different types of design concepts exist, including \nreference architectures, deployment patterns, architectural patterns, tactics, tech-","metadata":{"id":780}}],["78f88f8b-0b78-4389-9983-f84c9f8541d4",{"pageContent":"the architecture are created. Different types of design concepts exist, including \nreference architectures, deployment patterns, architectural patterns, tactics, tech-\nnology families, and externally developed components (such as frameworks).\nDesign concepts catalog A collection of design concepts for a particular ap-\nplication domain.\nDesign decision A decision that is made during the design process, including \nthe selection of a design concept and the instantiation of the selected design \nconcept.\nDesign iteration A group of design decisions through which a subset of the \ndrivers is transformed into structures. One or more design iterations are per-\nformed within a design round.\nDesign pattern See Patterns (Architectural and Design).\nDesign purpose The reason why the architecture design is performed. For \nexample, the design may be performed for estimation during pre-sales, prototyp-\ning, or development purposes.\nDesign round The architecture design activities performed within a develop-","metadata":{"id":781}}],["79cd75c7-5438-4d51-ae96-deb25880d0c2",{"pageContent":"example, the design may be performed for estimation during pre-sales, prototyp-\ning, or development purposes.\nDesign round The architecture design activities performed within a develop-\nment cycle if an iterative development model is used, or the entire set of archi-\ntecture design activities if a waterfall model is used.\nDeployment pattern A pattern that provides a model for how to physically \nstructure the system to deploy it.\nDevelopment cycle The development of a project increment (i.e., a project \niteration).\nDevOps A portmanteau word, combining “development” and “operations”. \nDevOps stands in contrast to earlier forms of running a software project, in \nwhich development teams developed software and then “tossed it over the wall” \nto operations. In DevOps, the two teams work closely together and adopt pro-\ncesses, tools, and architectures to make it easier to rapidly modify, build, test, \nrelease, and monitor software.\nElement (in definition of software architecture) One of the parts that com-","metadata":{"id":782}}],["f7b38e5f-b843-40ea-b6d9-05d307d9e1c7",{"pageContent":"cesses, tools, and architectures to make it easier to rapidly modify, build, test, \nrelease, and monitor software.\nElement (in definition of software architecture) One of the parts that com-\npose the structures of the architecture. Elements may exist at runtime or develop-\nment time or they may exist physically. Elements are connected by relations.\nElement interaction design The identification of the modules and their as-\nsociated interfaces to support the nonprimary use cases. This is typically per-\nformed using sequence diagrams according to the decisions made during archi-\ntectural design.\nElement internals design The internal design of the elements identified as \npart of element interaction design, so as to satisfy the element’s interface.\nwww.EBooksWorld.ir\n272 Glossary \nExternally developed component A design concept that is concrete in nature \nand that is not built as part of the system development, but rather is acquired","metadata":{"id":783}}],["28b6b65e-d50d-4f59-b92d-3a18fe40f7a8",{"pageContent":"www.EBooksWorld.ir\n272 Glossary \nExternally developed component A design concept that is concrete in nature \nand that is not built as part of the system development, but rather is acquired \nand reused. Such components include application frameworks, products, and \nplatforms.\nGreenfield development Software development that begins with little or no \nlegacy code base to build upon.\nInstantiation The process of adapting a design concept to the particular \nproblem being addressed. It involves creating elements and relations, and as-\nsociating responsibilities with the elements, from the selected design concept. \nInstantiation can also refer to configuration when design concepts are externally \ndeveloped components.\nInterface The externally visible properties of elements that establish a con-\ntractual specification that allows elements to collaborate and exchange informa-\ntion, via relations.\nMarketecture A single-page, typically informal, representation of a software","metadata":{"id":784}}],["3d283faa-fd83-46f0-ab80-d681e4f01e86",{"pageContent":"tractual specification that allows elements to collaborate and exchange informa-\ntion, via relations.\nMarketecture A single-page, typically informal, representation of a software \nsystem architecture. This representation is aimed primarily at nontechnical \npeople, and is used to present a system vision.\nMinimum viable product (MVP) An evolutionary prototype with only those \ncore features that allow the product to be deployed. It emphasizes hypothesis \ntesting by fielding the product with real users and collecting usage data that then \nhelps to confirm or reject the hypothesis.\nPatterns (architectural and design) Conceptual solutions to recurring design \nproblems that exist in a defined context. When they are used to address an archi-\ntectural driver, they are “architectural patterns”; when their use has just a local \ninfluence—for example, when used to perform element internals design—they \nare “design patterns”.\nPlatform A complete infrastructure upon which to build and execute \napplications.","metadata":{"id":785}}],["6e0ffa4d-0018-4597-9edf-ff55dfdc63e2",{"pageContent":"influence—for example, when used to perform element internals design—they \nare “design patterns”.\nPlatform A complete infrastructure upon which to build and execute \napplications.\nPre-sales A phase in project development in which the scope of the project, a \nbusiness case, and an initial plan are established. This phase is used by the cus-\ntomers (or funders) to decide whether they want to pursue the project.\nPrimary functional requirements Functionality is the ability of the system to \ndo the work for which it was intended. Primary functionality is usually defined \nas functionality that is critical to achieve the business goals that motivate the \ndevelopment of the system.\nProduct A self-contained functional piece of software that can be integrated \ninto the system that is being designed and that requires only minor configuration \nor coding. Also called a software package.\nwww.EBooksWorld.ir\nGlossary 273\nProof of concept (PoC) A prototype that is used to quickly evaluate a tech-","metadata":{"id":786}}],["8d859716-4e21-452d-aeaf-f036855cd07b",{"pageContent":"or coding. Also called a software package.\nwww.EBooksWorld.ir\nGlossary 273\nProof of concept (PoC) A prototype that is used to quickly evaluate a tech-\nnology, thereby determining whether it can satisfy critical architecture scenarios, \nusually related to quality attributes such as performance and scalability.\nQAW See Quality Attribute Workshop.\nQuality attribute A measurable or testable property of a system that is used to \nindicate how well the system satisfies the needs of its stakeholders. Quality attri-\nbutes are orthogonal to functionality.\nQuality attribute scenario See Scenario.\nQuality Attribute Workshop (QAW) A facilitated brainstorming session in-\nvolving a group of system stakeholders in eliciting, specifying, prioritizing, and \nachieving consensus on quality attributes.\nRationale A line of reasoning and justification that led to a design decision.\nRefactoring Changing the system’s architecture or code, without affecting its \nfunctionality, to achieve different quality attribute responses.","metadata":{"id":787}}],["06cc1d9e-4fea-4660-95df-9d859bf304a6",{"pageContent":"Refactoring Changing the system’s architecture or code, without affecting its \nfunctionality, to achieve different quality attribute responses.\nReference Architecture Blueprints that provide an overall logical structure for \ntypes of applications, consisting of a reference model that is mapped onto one or \nmore architectural patterns. It has been proven in business and technical contexts, \nand typically comes with a set of supporting artifacts that facilitates its use.\nRelation (in definition of software architecture) One of the parts that com-\npose the structures of an architecture. Relations may exist at runtime or develop-\nment time or they may exist physically. Relations connect elements.\nScenario A technique to specify quality attributes that describes a stimulus \nreceived by the system and a measurable response to this stimulus. Scenarios are \ntestable, falsifiable hypotheses about the quality attribute behavior of the system","metadata":{"id":788}}],["9d9bbd6c-6651-4fc8-9b06-72526627f0f8",{"pageContent":"received by the system and a measurable response to this stimulus. Scenarios are \ntestable, falsifiable hypotheses about the quality attribute behavior of the system \nunder consideration. Completely developed scenarios are described using six \nparts, but less elaborate (“raw”) scenarios can also be described.\nSketch of a view A preliminary type of documentation that is created as part \nof the design process. The sketch can be refined to become a full-fledged view, \ntypically after the design activity has finished.\nSoftware architecture “The set of structures needed to reason about the system, \nwhich comprise software elements, relations among them, and properties of both”.\nSpike A time-boxed task that is created to answer a technical question or \ngather information.\nStructure A coherent set of software elements, relations, and properties. \nStructures are represented in views.\nTactic A proven design strategy that influences the control of a quality attri-\nbute response.\nwww.EBooksWorld.ir","metadata":{"id":789}}],["9a43d3b3-99fc-406f-95e1-860671c1b80d",{"pageContent":"Structures are represented in views.\nTactic A proven design strategy that influences the control of a quality attri-\nbute response.\nwww.EBooksWorld.ir\n274 Glossary \nTechnical debt The decisions—often called “hacks”—made in a software \nproject that trade off short-term gains, such as ease of implementation, at the \ncost of long-term sustainability of the system. By taking such shortcuts, the soft-\nware base “goes into debt”.\nTechnology family A group of technologies with common functional purposes.\nView A representation of an architectural structure. A view usually includes a \ngraphical representation of the structure and additional information that comple-\nments the information presented in the diagram.\nwww.EBooksWorld.ir\n275\nAbout the Authors\nHumberto Cervantes is a professor at Universidad Autónoma Metropolitana Iz-\ntapalapa  in  Mexico  City.  His  primary  research  interest  is  software  architecture  \nand, more specifically, the development of methods and tools to aid in the design","metadata":{"id":790}}],["0ea99679-f059-459a-83dd-2023343eb854",{"pageContent":"tapalapa  in  Mexico  City.  His  primary  research  interest  is  software  architecture  \nand, more specifically, the development of methods and tools to aid in the design \nprocess. He is active in promoting the adoption of these methods and tools in the \nsoftware industry. Since 2006, Cervantes has been a consultant for software de-\nvelopment companies in topics related to software architecture. He has authored \nnumerous  research  papers  and  popularization  articles,  and  has  also  coauthored  \none of the few books in Spanish on the topic of software architecture.\nCervantes  received  a  master’s  degree  and  a  Ph.D.  from  Université  Joseph  \nFourier in Grenoble, France. He holds the Software Architecture Professional and \nATAM Evaluator certificates from SEI. Besides software engineering, Cervantes \nenjoys spending time with his family and friends, exercising, and traveling.\nRick  Kazman  is  a  professor  at  the  University  of  Hawaii  and  a  research  scien-","metadata":{"id":791}}],["299cfaa1-e4c6-4abe-a491-44f149c1b06d",{"pageContent":"enjoys spending time with his family and friends, exercising, and traveling.\nRick  Kazman  is  a  professor  at  the  University  of  Hawaii  and  a  research  scien-\ntist  at  the  Software  Engineering  Institute  of  Carnegie  Mellon  University.  His  \nprimary  research  interests  are  software  architecture,  design  and  analysis  tools,  \nsoftware visualization, and software engineering economics. Kazman has created \nseveral  highly  influential  methods  and  tools  for  architecture  analysis,  including  \nSAAM (Software Architecture Analysis Method), ATAM (Architecture Tradeoff \nAnalysis  Method),  CBAM  (Cost–Benefit  Analysis  Method),  and  the  Dali  and  \nTitan  tools.  He  is  the  author  of  more  than  one  hundred  fifty  peer-reviewed  pa-\npers, and is coauthor of several books, including Software Architecture in Prac-\ntice,  Third  Edition  (Addison-Wesley,  2013),  Evaluating  Software  Architectures","metadata":{"id":792}}],["56f11d8b-f2ac-4ec2-8f01-341446397f7a",{"pageContent":"pers, and is coauthor of several books, including Software Architecture in Prac-\ntice,  Third  Edition  (Addison-Wesley,  2013),  Evaluating  Software  Architectures \n(Addison-Wesley, 2002), and Ultra-Large-Scale Systems (Software Engineering \nInstitute, 2006).\nKazman  received  a  B.A.  (English/music)  and  M.Math.  (computer  science)  \nfrom  the  University  of  Waterloo,  an  M.A.  (English)  from  York  University,  and  \na  Ph.D.  (computational  linguistics)  from  Carnegie  Mellon  University.  How  he  \never became a software engineering researcher is anybody’s guess. When not ar-\nchitecting or writing about architecture, Kazman may be found cycling, playing \nthe piano, practicing Tae Kwon Do and Jiu Jitsu, or (more often) flying back and \nforth between Hawaii and Pittsburgh.\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n277\nIndex\nA\nABD (Architecture-Based Design). See ADD \n(Attribute-Driven Design).\nACDM (Architecture-Centric Design \nMethod), 164–165","metadata":{"id":793}}],["1ebddcf9-3bc9-426f-9559-3047f5584b48",{"pageContent":"www.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\n277\nIndex\nA\nABD (Architecture-Based Design). See ADD \n(Attribute-Driven Design).\nACDM (Architecture-Centric Design \nMethod), 164–165\nActive Reviews for Intermediate Design \n(ARID). See ARID (Active Reviews \nfor Intermediate Design).\nADD (Attribute-Driven Design). See also \nArchitectural drivers; Methods.\nanalyzing current design, 48–49\ndefinition, 270\ndesign concepts, selecting, 47, 55\ndesign iterations, 44\nhistory of, 8–9\ninterfaces, defining, 47–48, 61–64\niterating, 49\noverview, 44\nrecording design decisions, 48, 68\nreviewing inputs, 44–46\nrounds, 44\nsketching views, 48, 65\nsteps in, 44–49\nby system type, 50. See also specific types.\nADD (Attribute-Driven Design), alternatives \nto\nACDM (Architecture-Centric Design \nMethod), 164–165\na general model of software architecture \ndesign, 161–163\nMicrosoft technique for sketching an ar-\nchitecture, 169–171\nProcess of Software Architecting, \n167–169\nRUP (Rational Unified Process), 165–166","metadata":{"id":794}}],["55eb5950-d8f6-48b9-ba43-0f5d63465043",{"pageContent":"a general model of software architecture \ndesign, 161–163\nMicrosoft technique for sketching an ar-\nchitecture, 169–171\nProcess of Software Architecting, \n167–169\nRUP (Rational Unified Process), 165–166\nviewpoints and perspectives method, \n171–173\nADD (Attribute-Driven Design), design pur-\npose, 18\nidentifying, 44\nreviewing, 48–49\nADD (Attribute-Driven Design), elements\nallocating responsibilities to, 47–48, 60\ninstantiating, 47–48, 58\nrefining, 46–47\nADD (Attribute-Driven Design), iteration \ngoals\nestablishing, 46\nreviewing, 48–49\nADL (Attribute Description Language)\ndefinition, 269\noverview, 190–191\nUML (Unified Modeling Language), 191\nAgile Manifesto, 17, 197–199\nAgile processes\nin the development lifecycle, 197–199\nenabling, 16–17\nAgreements, in architectural design, 17\nAllocating responsibilities, case studies\ngreenfield development for mature do-\nmains, 84, 91–92, 101–102\ngreenfield development for novel do-\nmains, 116, 126–128, 134–136, \n139–141\nAllocation structures, 59\nAllocation view, brownfield development","metadata":{"id":795}}],["6a142765-e139-4df4-88fb-e96f66904ca7",{"pageContent":"greenfield development for mature do-\nmains, 84, 91–92, 101–102\ngreenfield development for novel do-\nmains, 116, 126–128, 134–136, \n139–141\nAllocation structures, 59\nAllocation view, brownfield development \ncase study, 150–151\nAnalysis\nanalytic models, 176–177\nanchoring bias, 186\nback-of-the-envelope analyses, 177\nchecklists, 177\nconfirmation bias, 186\ncost of, 179–180\ndefinition, 7, 175\nexperiments, 177\noverview, 175–176\nprototyping, 177\npurpose of, 178–179\nreflective questions, 177, 186–187\nscenario-based design reviews, 187, 189. \nSee also ATAM (Architecture \nTradeoff Analysis Method).\nsimulation, 177\nsubstantiating your beliefs, 176–177\ntactics based, 180–185\ntechniques, 179–180\nthought experiments, 177\nAnalytic models, 176–177\nwww.EBooksWorld.ir\n278 Index\nAnalytical skills among architects\npracticing, 209\nprerequisites, 7\nSmart Decisions game, 209\nAnalyzing current design, case studies\nbrownfield development, 156–158\ngreenfield development for mature do-\nmains, 88–89, 99–100, 104","metadata":{"id":796}}],["4af3077c-6a95-4abf-8218-361c70fb95c1",{"pageContent":"practicing, 209\nprerequisites, 7\nSmart Decisions game, 209\nAnalyzing current design, case studies\nbrownfield development, 156–158\ngreenfield development for mature do-\nmains, 88–89, 99–100, 104\ngreenfield development for novel domains, \n118–120, 129–131, 138, 143\nAnalyzing current design, with ADD, 48–49\nAnchoring bias, 186\nApplication frameworks, 36, 269\nArchitects\nrole of, 7\nskills, 7\nskills practice, 209–210\nArchitectural analysis, 163\nArchitectural backlogs, 69–70, 163\nArchitectural concerns, case studies\nbrownfield development, 148\ngreenfield development for mature do-\nmains, 80\ngreenfield development for novel do-\nmains, 110\nArchitectural concerns, definition, 26–28, \n269\nArchitectural design. See also Design.\nachieving agreements, 17\ndefinition, 270\ndetailed, 15–16\nimportance of, 16–17\nlow level, 16\nin software architecture life-cycle, 4\nArchitectural design decisions\ncandidate decisions, 38–40\ncatalog resources, 39\ndocumenting, 39–40\noverview, 38–40\nregarding patterns, 38–39\nweb page resources, 39","metadata":{"id":797}}],["d2c49d7d-16b0-41f8-89ef-150f8236f30f",{"pageContent":"in software architecture life-cycle, 4\nArchitectural design decisions\ncandidate decisions, 38–40\ncatalog resources, 39\ndocumenting, 39–40\noverview, 38–40\nregarding patterns, 38–39\nweb page resources, 39\nArchitectural documentation. See \nDocumentation.\nArchitectural drivers\nconcerns, 26–27\nconstraints, 27–28\ndefinition, 4, 270\nderived requirements, 27\ndesign purpose, 18–19\ngeneral concerns, 26\nidentifying, 45–46\ninternal requirements, 27\nissues, 27\nprimary functionality, 25–26\nquality attributes, 19–25\nselecting, 46\nin software architecture, 13\nspecific concerns, 26\nArchitectural drivers, satisfying. See also \nStructures.\ngreenfield development for mature do-\nmains case study, 82–84, 90, 101\ngreenfield development for novel domains \ncase study, 112–115, 121–126, \n132–133, 139\noverview, 46–47\nArchitectural drivers, selecting\ngreenfield development for mature do-\nmains case study, 81, 90, 101\ngreenfield development for novel domains \ncase study, 112, 121, 131–132, 139\nArchitectural elements. See Elements.","metadata":{"id":798}}],["fd29fff1-3b62-47c7-a1b7-c7eb8e98b392",{"pageContent":"greenfield development for mature do-\nmains case study, 81, 90, 101\ngreenfield development for novel domains \ncase study, 112, 121, 131–132, 139\nArchitectural elements. See Elements.\nArchitectural evaluation\ndefinition, 270\nin a general model of software architec-\nture design, 163\nin software architecture life-cycle, 6\nArchitectural implementation/conformance \nchecking, 6\nArchitectural patterns. See Patterns.\nArchitectural styles, vs. reference architec-\ntures, 29\nArchitectural synthesis, 163\nArchitecture design process. See Design \nprocess.\nArchitecture-Based Design (ABD). See ADD \n(Attribute-Driven Design).\nArchitecture-Centric Design Method \n(ACDM), 164–165\nARID (Active Reviews for Intermediate \nDesign)\ndefining interfaces, 64–65\ndefinition, 269\nASRs (architecturally significant require-\nments), 4, 270\nATAM (Architecture Tradeoff Analysis \nMethod), 187–190, 270\nAttribute Description Language (ADL). See \nADL (Attribute Description Language).\nAttribute-Driven Design (ADD). See ADD \n(Attribute-Driven Design).","metadata":{"id":799}}],["b7432b4c-0b47-4283-8e83-042efec55991",{"pageContent":"Method), 187–190, 270\nAttribute Description Language (ADL). See \nADL (Attribute Description Language).\nAttribute-Driven Design (ADD). See ADD \n(Attribute-Driven Design).\nAvailability\nscenarios, brownfield development case \nstudy, 146\nwww.EBooksWorld.ir\nIndex 279\ntactics, 230–232\ntactics-based questionnaire, 180–185, \n248–252\nB\nBacklogs, architectural, 69–70, 163\nBack-of-the-envelope analyses, 177\nBDUF (Big Design Up Front)\ndefinition, 270\nin the development lifecycle, 197–198\nidentifying modules, 64\nBig Data case study. See Greenfield develop-\nment for novel domains case study.\nBlueprints. See Documentation; Reference \narchitectures; Sketches.\nBooch, Grady, on architectural design, 14\nBooks and publications\n“A General Model of Software Architecture \nDesign” (Hofmeister et al.), 161\nJust Enough Software Architecture \n(Fairbanks), 7\nMicrosoft Application Architecture Guide \n(Microsoft), 169, 211\nPattern-Oriented Software Architecture: A \nPattern Language for Distributed \nComputing (Buschmann et al.), 31, \n32, 41, 224","metadata":{"id":800}}],["dab81219-f450-453e-becb-4144f060c444",{"pageContent":"(Fairbanks), 7\nMicrosoft Application Architecture Guide \n(Microsoft), 169, 211\nPattern-Oriented Software Architecture: A \nPattern Language for Distributed \nComputing (Buschmann et al.), 31, \n32, 41, 224\nThe Process of Software Architecting \n(Eeles and Cripps), 167–169\n“A Rational Design Process: How and \nWhy to Fake It” (Parnas and \nClements), 2\nSoftware Architecture in Practice, 3rd ed. \n(Bass et al.), 3, 7, 8, 19, 35, 230\nSoftware Systems Architecture: Working \nwith Stakeholders Using View-\npoints and Perspectives (Rozanski \nand Woods), 171–173\nBrooks, Fred, 208\nBrownfield development, definition, 50, 270\nBrownfield development case study\nallocation view, 150–151\narchitectural concerns, 148\navailability scenarios, 146\nbusiness case, 145–148\nconstraints, 148\nexisting documentation, 149–151\nmodule view, 149–150\nperformance scenarios, 146\nquality attribute scenarios, 146, 148\nreliability scenarios, 146\nuse case model, 147\nBrownfield development case study, design \nprocess\nallocating responsibilities, 154","metadata":{"id":801}}],["e8674242-bb52-43a5-91e7-258212a81778",{"pageContent":"performance scenarios, 146\nquality attribute scenarios, 146, 148\nreliability scenarios, 146\nuse case model, 147\nBrownfield development case study, design \nprocess\nallocating responsibilities, 154\nanalyzing current design, 156–158\ndefining interfaces, 154\ndesign purpose, reviewing, 156–158\ninstantiating elements, 154\niteration goals, establishing, 152\niteration goals, reviewing, 156–158\nrecording design decisions, 154–156\nrefining elements, 152\nreviewing inputs, 152\nselecting design concepts, 152–153\nsketching views, 154–156\nsupporting new drivers, 152–158\nBusiness case, case studies\nbrownfield development, 145–148\ngreenfield development for mature do-\nmains, 75–77\ngreenfield development for novel do-\nmains, 107–108\nBuy vs. build, design concept, 35–38\nC\nCandidate decisions, 38–40\nCase studies\nbanking systems. See Brownfield devel-\nopment case study.\nBig Data. See Greenfield development for \nnovel domains case study.\ndevelopment for legacy systems. See \nBrownfield development.\nFCAPS model for network management.","metadata":{"id":802}}],["8416ab8c-a490-456c-aa60-b84a924bd26d",{"pageContent":"opment case study.\nBig Data. See Greenfield development for \nnovel domains case study.\ndevelopment for legacy systems. See \nBrownfield development.\nFCAPS model for network management. \nSee Greenfield development for \nmature domains case study.\ngreenfield development. See Greenfield \ndevelopment for mature domains \ncase study; Greenfield develop-\nment for novel domains case study.\nCatalogs of design concepts. See Design con-\ncepts catalogs.\nCBAM (Cost Benefit Analysis Method), \n55–57, 270\nC&C (component and connector) structures, \n59\nChecklists, 177\nCommunication skills, among architects, 7\nCompatibility, externally developed compo-\nnents, 38\nConcurrency, 31, 32, 228\nCone of uncertainty, 194–195\nConfirmation bias, 186\nwww.EBooksWorld.ir\n280 Index\nConstraints\non architectural drivers, 27–28\ndefinition, 28, 270\nselecting design concepts, 58\nConstraints, case studies\nbrownfield development, 148\ngreenfield development for mature do-\nmains, 79\ngreenfield development for novel do-\nmains, 110\nConstruction phase of RUP, 165, 199","metadata":{"id":803}}],["109c71bb-d490-4dbd-93bf-f2b0cb2be054",{"pageContent":"Constraints, case studies\nbrownfield development, 148\ngreenfield development for mature do-\nmains, 79\ngreenfield development for novel do-\nmains, 110\nConstruction phase of RUP, 165, 199\nCost\nof design analysis, 179–180\nestimating, 194–196\nexternally developed components, 36\nCost Benefit Analysis Method (CBAM). \nSee CBAM (Cost Benefit Analysis \nMethod).\nCripps, Peter, 167\nD\nData stream elements, refining, 131–138\nDatabase access patterns, design concepts \ncatalog, 229\nDeployment patterns\ndefinition, 271\nexample, 32–33\ninstantiating elements, 60\nDeployment patterns, design concepts \ncatalogs\ndistributed deployment, 222–223\nLoad-Balanced Cluster patterns, \n223–224\nnondistributed deployment, 221\nperformance patterns, 223–224\nDesign. See also Architectural design.\ndefinition, 11\nelement interaction, 14–15\nelement internals, 15\nhigh level, 16\noverview, 11–12\nin software architecture, 13–14\nDesign candidates, identifying, 54–55\nDesign concepts catalog\nexample, 211\ndefinition, 271\nas resources for architectural design de-\ncisions, 39","metadata":{"id":804}}],["46bbee84-7218-4104-9bf5-a8490774b47a",{"pageContent":"high level, 16\noverview, 11–12\nin software architecture, 13–14\nDesign candidates, identifying, 54–55\nDesign concepts catalog\nexample, 211\ndefinition, 271\nas resources for architectural design de-\ncisions, 39\nuses for, 203–204\nDesign concepts catalogs, architectural de-\nsign patterns\nconcurrency, 228\ndatabase access, 229\ninterface partitioning, 226–227\nLoad-Balanced Cluster patterns, 224\nPattern-Oriented Software Architecture: \nA Pattern Language for Distrib-\nuted Computing (Buschmann et \nal.), 224\nstructural patterns, 224–226\nDesign concepts catalogs, deployment \npatterns\ndistributed deployment, 222–223\nLoad-Balanced Cluster patterns, \n223–224\nnondistributed deployment, 221\nperformance patterns, 223–224\nDesign concepts catalogs, externally devel-\noped components\nHibernate framework, 244–245\nJava Web Start framework, 245\nSpring framework, 241–242\nSwing framework, 243\nDesign concepts catalogs, reference \narchitectures\nMicrosoft Application Architecture \nGuide, 211\nmobile applications, 218\nRIAs (rich Internet applications),","metadata":{"id":805}}],["59eff01c-7b92-4273-b032-6a1cae58b0d7",{"pageContent":"Spring framework, 241–242\nSwing framework, 243\nDesign concepts catalogs, reference \narchitectures\nMicrosoft Application Architecture \nGuide, 211\nmobile applications, 218\nRIAs (rich Internet applications), \n215–217\nrich client applications, 214–215\nservice applications, 218–221\nweb applications, 212–214\nDesign concepts catalogs, tactics\navailability, 230–232\ninteroperability, 232–233\nmodifiability, 233–235\nperformance, 235–236\nsecurity, 236–238\ntestability, 238–240\nusability, 240–241\nDesign concepts. See also, Reference archi-\ntectures, Design patterns, Deploy-\nment patterns, Tactics, and Externally \ndeveloped components.\nbuy vs. build, 35–38\ndefinition, 12, 271\ndesign primitives. See Tactics.\ndesign principles, 28\nexternally developed components, \n35–38\nidentifying design candidates, 54–55\noverview, 28\nreference architectures, 29, 30\nwww.EBooksWorld.ir\nIndex 281\ntypes of, 59–60\nDesign concepts, selecting\nCBAM (Cost Benefit Analysis Method), \n55–57\nconstraints, 58\ngreenfield development for mature do-\nmains, 51","metadata":{"id":806}}],["208db682-46f5-4841-8f93-b4c52b63e1a8",{"pageContent":"www.EBooksWorld.ir\nIndex 281\ntypes of, 59–60\nDesign concepts, selecting\nCBAM (Cost Benefit Analysis Method), \n55–57\nconstraints, 58\ngreenfield development for mature do-\nmains, 51\ngreenfield development for mature \ndomains case study, 82–84, \n90–91, 101\ngreenfield development for novel do-\nmains case study, 112–115, \n121–126, 132–133, 139\noverview, 47, 55\nprototyping, 57–58\nstakeholder benefits, 56\nutility, 56\nDesign decisions, recording. See Recording \ndesign decisions.\nDesign iteration goals, establishing\nbrownfield development case study, 152 \ngreenfield development for mature do-\nmains case study, 90, 101\ngreenfield development for novel do-\nmains case study, 112, 121, \n131–132, 139\nDesign iteration goals, reviewing\nbrownfield development case study, \n156–158 \ngreenfield development for mature \ndomains case study, 88–89, \n99–100, 104\ngreenfield development for novel do-\nmains case study, 118–120, \n129–131, 138, 143\nDesign iterations\ndefinition, 271\nin the design process, 44, 49\npurpose of, 50–52","metadata":{"id":807}}],["63b44a1d-11fb-41cb-b251-3745f175c49c",{"pageContent":"domains case study, 88–89, \n99–100, 104\ngreenfield development for novel do-\nmains case study, 118–120, \n129–131, 138, 143\nDesign iterations\ndefinition, 271\nin the design process, 44, 49\npurpose of, 50–52\nDesign patterns. See Patterns.\nDesign primitives. See Tactics.\nDesign principles, 28\nDesign process, alternative methods\nACDM (Architecture-Centric Design \nMethod), 164–165\na general model of software architecture \ndesign, 161–163\nMicrosoft technique for architecture and \ndesign, 169–171\nProcess of Software Architecting, \n167–169\nRUP (Rational Unified Process), 165–166\nviewpoints and perspectives method, \n171–173\nDesign process, case studies. See Brown-\nfield development case study, design \nprocess; Greenfield development for \nmature domains case study, design \nprocess; Greenfield development for \nnovel domains case study, design \nprocess.\nDesign process, elements in\nallocating responsibilities to, 47–48\ninstantiating, 47–48, 58\nrefining, 46–47\nDesign process, need for, 43–44\nDesign process, organizational aspects","metadata":{"id":808}}],["161cb4b1-7f0d-4933-9549-15b951fb600d",{"pageContent":"process.\nDesign process, elements in\nallocating responsibilities to, 47–48\ninstantiating, 47–48, 58\nrefining, 46–47\nDesign process, need for, 43–44\nDesign process, organizational aspects\ndesign concepts catalogs, 203–204\nindividual effort vs. team effort, \n202–203\nDesign process in the development lifecycle\nmajor phases, 193–194\npreliminary documentation, 196\nDesign process in the development lifecycle, \ndevelopment and operations phase\nAgile methods, 197–199\nBDUF (Big Design Up Front), 197–198\nDevOps, 201–202\nemergent approach, 197–198\nHLD (high-level design) phase of TSP, \n200–201\nIMPL (implementation) phase of TSP, \n200–201\niteration 0 approach, 199\nlaunch phase, 200\npostmortem phase, 200\nPSP (Personal Software Process), 200\nREQ (requirements) phase of TSP, \n200–201\nRUP (Rational Unified Process), \n199–200\nspikes, 199\nTEST (testing) phase, 200–201\nTSP (Team Software Process), 200–201\nWaterfall model, 197–198\nDesign purpose, definition, 271\nDesign purpose, overview, 18\nDesign purpose, reviewing","metadata":{"id":809}}],["c3829df3-ec3c-48bc-8afd-3eac827b0707",{"pageContent":"199–200\nspikes, 199\nTEST (testing) phase, 200–201\nTSP (Team Software Process), 200–201\nWaterfall model, 197–198\nDesign purpose, definition, 271\nDesign purpose, overview, 18\nDesign purpose, reviewing\ngreenfield development for mature do-\nmains case study, 88–89\ngreenfield development for novel do-\nmains case study, 118–120, \n129–131, 138, 143\nDesign rounds, 44, 271\nwww.EBooksWorld.ir\n282 Index\nDesigning\nfor existing systems. See Brownfield \ndevelopment.\nfor legacy systems. See Brownfield \ndevelopment.\nfor mature domains. See Greenfield de-\nvelopment for mature domains.\nfor novel domains. See Greenfield devel-\nopment for novel domains.\nfrom scratch. See Greenfield develop-\nment for mature domains.\nDetailed design, 15–16\nDevelopment cycle, definition, 271\nDevOps\ndefinition, 271\nin the development lifecycle, 201–202\ntactics-based questionnaire, 263–266\nDistributed deployment patterns, design \nconcepts catalog, 222–223\nDocumentation. See also Recording design \ndecisions.\narchitectural design decisions, 39–40","metadata":{"id":810}}],["d8f2f2d0-29d9-4923-88f6-e8038025f2bb",{"pageContent":"tactics-based questionnaire, 263–266\nDistributed deployment patterns, design \nconcepts catalog, 222–223\nDocumentation. See also Recording design \ndecisions.\narchitectural design decisions, 39–40\nfor legacy systems, 149–151\npurposes of, 67\nscenario based, 67–68\nin software architecture life-cycle, 5\nDocumentation, preliminary. See also \nSketches; Views.\nin the development lifecycle, 196\nrecording design decisions, 68–69\nsketching views, 65–68\nDrivers. See Architectural drivers.\nDyson, Freeman, on good engineers, 53\nE\nEeles, Peter, 167\nEinstein, Albert, on teaching by example, 2\nElaboration phase of RUP, 165–166, 199\nElement interaction design\ndefining interfaces, 64–65\ndefinition, 271\noverview, 14–15\nElement internals design, 15, 271\nElements (in software architecture)\ndefinition, 271\ninstantiating. See Instantiating elements.\nproperties, 60\nrelationships, 61\nresponsibilities, 60\nElements (in software architecture), in the \ndesign process\nallocating responsibilities to, 47–48\ninstantiating, 47–48, 58\nrefining, 46–47","metadata":{"id":811}}],["5782302f-4ab9-4ec6-ac75-76ba999eb6a6",{"pageContent":"properties, 60\nrelationships, 61\nresponsibilities, 60\nElements (in software architecture), in the \ndesign process\nallocating responsibilities to, 47–48\ninstantiating, 47–48, 58\nrefining, 46–47\nElements (in software architecture), refining\ngreenfield development for mature do-\nmains case study, 82, 90, 101\ngreenfield development for novel domains \ncase study, 112, 121, 132, 139\nEmergent approach in the development life-\ncycle, 197–198\nEstimation in the development lifecycle\ncone of uncertainty, 194–195\ncost, 194–196\nidentifying components of, 196\npre-sales phase, 194–196\nrisk, 194–195\nschedules, 194–196\nstandard components technique, 195–196\nEvaluating architecture. See Architectural \nevaluation.\nExperiments, 177\nExternal interfaces, defining, 61\nExternally developed components\napplication frameworks, 36\ncompatibility, 38\ncost, 36\ndefinition, 35, 272\nintegration, 38\nlearning curve, 38\nlicensing, 36\nmaturity, 38\noverview, 35–38\nplatforms, 36\npopularity, 38\nproblem addressed by, 36\nproducts, 36\nselecting, 36–38\nsize, 38","metadata":{"id":812}}],["4b0459e2-441e-4ca8-9ef3-dcf426c0cfd7",{"pageContent":"cost, 36\ndefinition, 35, 272\nintegration, 38\nlearning curve, 38\nlicensing, 36\nmaturity, 38\noverview, 35–38\nplatforms, 36\npopularity, 38\nproblem addressed by, 36\nproducts, 36\nselecting, 36–38\nsize, 38\nin structures, 60\nsupport for, 38\ntechnology families, 35–36, 37\ntypes of, 35–36\nExternally developed components, design \nconcepts catalog\nHibernate framework, 244–245\nJava Web Start framework, 245\nSpring framework, 241–242\nSwing framework, 243\nF\nFalsifiability of scenarios, 21\nFCAPS\naccounting management, 76 \nwww.EBooksWorld.ir\nIndex 283\nconfiguration management, 76 \nfault management, 76\nperformance management, 76\nsecurity management, case study, 76\nFCAPS model for network management. See \nGreenfield development for mature \ndomains case study.\nFrameworks, choosing for greenfield devel-\nopment for mature domains, 50\nG\n“A General Model of Software Architecture \nDesign” (Hofmeister et al.), 161\nGeneral model of software architecture \ndesign, 161–163\narchitectural analysis, 163\narchitectural evaluation, 163\narchitectural synthesis, 163","metadata":{"id":813}}],["9dac4a68-ec64-41a6-832a-52e02843f85d",{"pageContent":"Design” (Hofmeister et al.), 161\nGeneral model of software architecture \ndesign, 161–163\narchitectural analysis, 163\narchitectural evaluation, 163\narchitectural synthesis, 163\nflowchart of activities, 162\noverview, 161\nGreenfield development, definition, 272\nGreenfield development for mature \ndomains\ndefinition, 50\ndesign concepts, selecting, 51\ndesign iterations, purpose of, 50–52\ndesigning, 50–52\nframeworks, choosing, 50\nidentifying structures to support primary \nfunctionality, 51–52\nmature domains, examples, 50\nrefining structures, 52\nroadmap for, 50–52\nGreenfield development for mature domains \ncase study\naccounting management, 76\narchitectural concerns, 80\nbusiness case, 75–77\nconfiguration management, 76\nconstraints, 79\nfault management, 76\nFCAPS model for network management, \n75–77\nperformance management, 76\nquality attribute scenarios, 78–79\nsecurity management, 76\nsystem requirements, 77–80\nuse case model, 77–80\nGreenfield development for mature domains \ncase study, design process","metadata":{"id":814}}],["f22f8d66-ebd3-4bfd-8a60-537ad31c6f18",{"pageContent":"performance management, 76\nquality attribute scenarios, 78–79\nsecurity management, 76\nsystem requirements, 77–80\nuse case model, 77–80\nGreenfield development for mature domains \ncase study, design process\nallocating responsibilities, 84, 91–92, \n101–102\nanalyzing current design, 88–89, \n99–100, 104\narchitectural drivers, selecting, 81, 90, 101\ndefining interfaces, 84, 101–102\ndesign concepts, selecting, 82–84,  \n90–91, 101\ndesign purpose, reviewing, 88–89\nidentifying structures to support primary \nfunctionality, 89–99\ninputs, reviewing, 80–81\ninstantiating elements, 84, 91–92, 101–102\niteration goals, establishing, 90, 101\niteration goals, reviewing, 88–89\niterations, reviewing, 99–100, 104\noverall system structure, establishing, \n81–89\nquality attribute scenarios, 101–104\nrecording design decisions, 84–87, \n92–99, 102–103\nrefining elements, 82, 90, 101\nsatisfying architectural drivers, 82–84, \n90, 101\nsketching views, 84–87, 92–99, 102–103\nGreenfield development for novel domains\ndefinition, 50","metadata":{"id":815}}],["b33f8985-2d99-4ee4-ac22-489d4c503c7f",{"pageContent":"92–99, 102–103\nrefining elements, 82, 90, 101\nsatisfying architectural drivers, 82–84, \n90, 101\nsketching views, 84–87, 92–99, 102–103\nGreenfield development for novel domains\ndefinition, 50\nnovel domains, definition, 52\nroadmap for, 52\nGreenfield development for novel domains \ncase study\nbusiness case, 107–108\nreviewing inputs, 111–112\nGreenfield development for novel domains \ncase study, design process\nallocating responsibilities, 116, 126–128, \n134–136, 139–141\nanalyzing current design, 118–120, \n129–131, 138, 143\ndata stream elements, refining, 131–138\ndefining interfaces, 116, 126–128, 134–\n136, 139–141\ndesign concepts, selecting, 112–115, \n121–126, 132–133, 139\ndesign purpose, reviewing, 118–120, \n129–131, 138, 143\ndrivers, satisfying, 112–115, 121–126, \n132–133, 139\ndrivers, selecting, 112, 121, 131–132, 139\nelements, refining, 112, 121, 132, 139\ninstantiating architectural elements, 116, \n126–128, 134–136, 139–141\niteration goals, establishing, 112, 121, \n131–132, 139\nwww.EBooksWorld.ir\n284 Index","metadata":{"id":816}}],["a3b458bc-5c9e-4d43-a2ac-81d6ed3f2b21",{"pageContent":"elements, refining, 112, 121, 132, 139\ninstantiating architectural elements, 116, \n126–128, 134–136, 139–141\niteration goals, establishing, 112, 121, \n131–132, 139\nwww.EBooksWorld.ir\n284 Index\nGreenfield development for novel domains \ncase study, design process (cont.)\niteration goals, reviewing, 118–120, \n129–131, 138, 143\nrecording design decisions, 116–118, \n128–129, 136–137, 141–142\nreference architecture, 112–120\nserver layer, refining, 138–143\nsketching views, 116–118, 128–129, \n136–137, 141–142\nstructure of overall system, 112–120\ntechnologies, selecting, 120–131\nGreenfield development for novel domains \ncase study, system requirements\narchitectural concerns, 110\nconstraints, 110\nquality attribute scenarios, 109–110\nuse case model, 108–109\nH\nHacks. See Technical debt.\nHalf Sync/Half Async, pattern example, 32, \n228\nHelp\nregistering Designing Software Architec-\nture, xiii\nskills practice, 209–210\nHibernate framework, design concepts cata-\nlog, 244–245\nHigh-level design, 16\nHLD (high-level design) phase, 200–201\nI","metadata":{"id":817}}],["890677e1-35ca-4252-8ce2-832120eb2b58",{"pageContent":"228\nHelp\nregistering Designing Software Architec-\nture, xiii\nskills practice, 209–210\nHibernate framework, design concepts cata-\nlog, 244–245\nHigh-level design, 16\nHLD (high-level design) phase, 200–201\nI\nIMPL (implementation) phase of TSP, \n200–201\nInception phase of RUP, 165, 199\nInstantiating elements\nin ADD (Attribute-Driven Design), 47–48\noverview, 59–60\nproducing structures, 58\nInstantiating elements, case studies\ngreenfield development for mature do-\nmains, 84, 91–92, 101–102\ngreenfield development for novel do-\nmains, 116, 126–128, 134–136, \n139–141\nInstantiation, definition, 272\nIntegration, externally developed compo-\nnents, 38\nInterface partitioning, design concepts cata-\nlog, 226–227\nInterfaces, defining\nARID (Active Reviews for Intermediate \nDesign), 64–65\ncommunicating with engineers, 64–65\nin element interaction design, 64–65\nexternal, 61\ngreenfield development for mature do-\nmains case study, 84, 101–102\ngreenfield development for novel do-\nmains case study, 116, 126–128, \n134–136, 139–141\ninternal, 61–64","metadata":{"id":818}}],["70f17d49-c033-4f03-a364-56f77a0a4afc",{"pageContent":"external, 61\ngreenfield development for mature do-\nmains case study, 84, 101–102\ngreenfield development for novel do-\nmains case study, 116, 126–128, \n134–136, 139–141\ninternal, 61–64\nInterfaces, definition, 61, 272\nInternal interfaces, defining, 61–64\nInteroperability, tactics-based questionnaire, \n252\nInteroperability tactics, design concepts \ncatalog, 232–233\nInterviews. See Tactics-based questionnaires.\nIteration. See Design iteration.\nIteration 0 approach, 199\nJ\nJava Web Start framework, design concepts \ncatalog, 245\nJust Enough Software Architecture (Fair-\nbanks), 7\nK\nKanban boards, 70–71\nL\nLambda (reference) architecure, 113 \nLaunch phase of the TSP (Team Software \nProcess), 200\nLayers, pattern example, 30–31, 225\nLeadership skills, among architects, 7\nLearning curve, externally developed com-\nponents, 38\nLicensing, externally developed compo-\nnents, 36\nLoad-Balanced Cluster patterns\ndesign concepts catalog, 223–224\nexample, 32–33\nLow-level design, 16\nM\nMarketecture, definition, 272\nMature domains, examples, 50","metadata":{"id":819}}],["596e1215-cbf8-450f-9bc2-96166f0ace52",{"pageContent":"nents, 36\nLoad-Balanced Cluster patterns\ndesign concepts catalog, 223–224\nexample, 32–33\nLow-level design, 16\nM\nMarketecture, definition, 272\nMature domains, examples, 50\nMaturity, externally developed components, 38\nMethods, 207–209\nMicrosoft Application Architecture Guide \n(Microsoft), 211\nwww.EBooksWorld.ir\nIndex 285\nMicrosoft technique for architecture and \ndesign\napplication overview, creating, 169–170\narchitectural objectives, identifying, 169\ncandidate solutions, defining, 170\nkey issues, identifying, 170\nkey scenarios, identifying, 169\noverview, 169–171\nMission Thread Workshop, 19\nMobile applications, design concepts cata-\nlog, 218\nModifiability\ntactics, design concepts catalog, 233–235\ntactics-based questionnaire, 253–254\nModule structures, 59\nModule view, brownfield development case \nstudy, 149–150\nMVP (minimum viable product), 189, 272\nN\nNegotiation skills, among architects, 7\nNondistributed deployment patterns, design \nconcepts catalog, 221\nNon-risks, definition, 188\nNovel domains, definition, 52\nO","metadata":{"id":820}}],["ed936f47-91be-4cbd-b828-7ecd46f5a2e6",{"pageContent":"MVP (minimum viable product), 189, 272\nN\nNegotiation skills, among architects, 7\nNondistributed deployment patterns, design \nconcepts catalog, 221\nNon-risks, definition, 188\nNovel domains, definition, 52\nO\nOptimal solutions vs. satisficing, 14\nP\nPattern-Oriented Software Architecture: A \nPattern Language for Distributed \nComputing (Buschmann et al.), 224\nPatterns\narchitectural design decisions, 38–39, 59\nconcurrency, 228\ndatabase access, 229\ndefinition, 29, 272\ninterface partitioning, 226–227\noverview, 29–32\nstructural, design concepts catalog, \n224–226\nvs. tactics, 34\nPatterns, examples\nconcurrency, 31, 32\ndeployment, 32–33\nHalf Sync/Half Async, 32\nLayers, 30–31\nLoad Balanced Cluster, 32–33\nPatterns for architectural design, design con-\ncepts catalogs\nconcurrency, 228\ndatabase access, 229\ninterface partitioning, 226–227\nLoad-Balanced Cluster patterns, 224\nPattern-Oriented Software Architecture: A \nPattern Language for Distributed \nComputing (Buschmann et al.), 224\nstructural patterns, 224–226\nPatterns for deployment","metadata":{"id":821}}],["a8546905-a2a6-4f15-9fb9-0a5e57fc9fd8",{"pageContent":"Load-Balanced Cluster patterns, 224\nPattern-Oriented Software Architecture: A \nPattern Language for Distributed \nComputing (Buschmann et al.), 224\nstructural patterns, 224–226\nPatterns for deployment\ndefinition, 271\nexample, 32–33\ninstantiating elements, 60\nLoad-Balanced Cluster patterns, 224\nPatterns for deployment, design concepts \ncatalogs\ndistributed deployment, 222–223\nLoad-Balanced Cluster patterns, 223–224\nnondistributed deployment, 221\nperformance patterns, 223–224\nPerformance\npatterns, design concepts catalog, \n223–224\nscenarios, brownfield development case \nstudy, 146\ntactics, design concepts catalog, 235–236\ntactics example, 34–35\ntactics-based questionnaire, 185, \n255–256\nPersonal Software Process (PSP), 200\nPerspectives, definition, 171–172\nPlatform, definition, 272\nPlatforms, externally developed compo-\nnents, 36\nPOC (proof-of-concept). See Proof-of-concept.\nPopularity, externally developed compo-\nnents, 38\nPostmortem phase of the TSP (Team Soft-\nware Process), 200\nPreliminary documentation. See also","metadata":{"id":822}}],["4a27cf28-5f4c-4fc3-863a-77519965bb42",{"pageContent":"nents, 36\nPOC (proof-of-concept). See Proof-of-concept.\nPopularity, externally developed compo-\nnents, 38\nPostmortem phase of the TSP (Team Soft-\nware Process), 200\nPreliminary documentation. See also \nSketches; Views.\nin the development lifecycle, 196\nrecording design decisions, 68–69\nsketching views, 65–68\nPre-sales process\ndefinition, 16, 272\nin the development lifecycle, 194–196\nPrimary functional requirements, definition, \n272\nPrimary functionality\narchitectural drivers, 25–26\ndefinition, 25\nidentifying supporting structures, 51–52\nimportance of, 25–26\nwww.EBooksWorld.ir\n286 Index\nPrioritizing quality attributes, 19, 21, 81, \n152, 188–190. See also Utility Tree.\nProcess of Software Architecting\nbuilding a proof-of-concept, 168\ndefining architecture overview, 168\ndefining requirements, 167\ndeployment elements, outlining, 168\ndeployment models, 168\ndocumenting architecture decisions, 168\nfunction models, 168\nfunctional elements, outlining, 168\nfunctional elements, refining, 169\nidentifying reusable architecture, 168","metadata":{"id":823}}],["41fbab7c-eb74-4cf4-a43a-db62008965d5",{"pageContent":"deployment models, 168\ndocumenting architecture decisions, 168\nfunction models, 168\nfunctional elements, outlining, 168\nfunctional elements, refining, 169\nidentifying reusable architecture, 168\nlogical architecture, creating, 167\noverview, 167–169\nphysical architecture, creating, 167\nsurveying architecture assets, 168\ntasks, outlining vs. detailing, 168\ntasks, purposes of, 168–169\nverifying architecture, 168\nThe Process of Software Architecting (Eeles \nand Cripps), 167–169\nProduct, definition, 272\nProducts, externally developed components, 36\nProgress, tracking. See Tracking design \nprogress.\nProject proposals. See Pre-sales process.\nProject skills, among architects, 7\nProof-of-concept\nin ATAM analysis, 189\ndefinition, 273\nProcess of Software Architecting, 168\nRUP, 165\nPrototyping\nanalyzing the design process, 177\nin ATAM analysis, 189\nselecting design concepts, 57–58\nPSP (Personal Software Process), 200\nQ\nQAW (Quality Attribute Workshop)\ndefinition, 19, 273\noutput of, 23\npurpose of, 21\nsteps in, 21–22","metadata":{"id":824}}],["e1622a72-0a0e-487f-8365-ff97b8c448c2",{"pageContent":"in ATAM analysis, 189\nselecting design concepts, 57–58\nPSP (Personal Software Process), 200\nQ\nQAW (Quality Attribute Workshop)\ndefinition, 19, 273\noutput of, 23\npurpose of, 21\nsteps in, 21–22\nvs. Utility Tree, 24\nQuality attribute scenarios. See also \nScenarios.\ncomponents of, 20\ndefinition, 273\noverview, 20–21\nQuality attribute scenarios, case studies\nbrownfield development case study, \n146, 148\ngreenfield development for mature do-\nmains, 78–79, 101–104\ngreenfield development for novel do-\nmains, 109–110\nQuality attributes\nin architectural drivers, 19–21\nchanging, 26\ndefinition, 19, 273\nexternally developed components for, 38\nprioritizing, 19, 21, 81, 152, 188–190. \nSee also Utility Tree.\nrefactoring, 26\nQuestionnaires. See Tactics-based \nquestionnaires.\nR\n“A Rational Design Process: How and Why \nto Fake It” (Parnas and Clements), 2\nRational Unified Process (RUP). See RUP \n(Rational Unified Process).\nRationale, definition, 273\nRecording design decisions\ncreating preliminary documentation, \n68–69\noverview, 48","metadata":{"id":825}}],["2393da21-507a-456f-b623-c3314f4e690b",{"pageContent":"Rational Unified Process (RUP). See RUP \n(Rational Unified Process).\nRationale, definition, 273\nRecording design decisions\ncreating preliminary documentation, \n68–69\noverview, 48\nRecording design decisions, case studies\nbrownfield development case study, \n154–156\ngreenfield development for mature do-\nmains, 84–87, 92–99, 102–103\ngreenfield development for novel do-\nmains, 116–118, 128–129, 136–\n137, 141–142\nRefactoring\nbrownfield development, 53\ndefinition, 273\nquality attributes, 26\nReference architectures\nvs. architectural styles, 29\nbrownfield development case study, 153\ndefinition, 29, 273\ndesigning structures, 59\ngreenfield development for novel do-\nmains case study, 112–120\nLambda (reference) architecture, 113 \noverview, 29\nReference architectures, design concepts \ncatalog\nMicrosoft Application Architecture Guide \n(Microsoft), 211\nwww.EBooksWorld.ir\nIndex 287\nmobile applications, 218\nRIAs (rich Internet applications), 215–217\nrich client applications, 214–215\nservice applications, 218–221\nweb applications, 212–214","metadata":{"id":826}}],["b929dd56-c4d2-49d6-b1f9-d1e7f5172d79",{"pageContent":"(Microsoft), 211\nwww.EBooksWorld.ir\nIndex 287\nmobile applications, 218\nRIAs (rich Internet applications), 215–217\nrich client applications, 214–215\nservice applications, 218–221\nweb applications, 212–214\nRefining elements, case studies\nbrownfield development case study, 152\ngreenfield development for mature do-\nmains, 82, 90, 101\ngreenfield development for novel do-\nmains, 112, 121, 132, 139\nRefining elements, overview, 46–47\nRefining structures for greenfield develop-\nment for mature domains, 52\nReflective questions, 177, 186–187\nRelation (in software architecture), defini-\ntion, 273\nReliability scenarios, brownfield develop-\nment case study, 146\nREQ (requirements) phase of TSP, 200–201\nRequirements. See also ASRs (architectur-\nally significant requirements).\nderived, for architectural drivers, 27\ninternal, for architectural drivers, 27\nprimary functional requirements, 272\nResponsibilities, allocating\nbrownfield development case study, 154 \nto elements, 47–48\ngreenfield development for mature","metadata":{"id":827}}],["ad862fb8-999e-4614-b3a6-a164ba1aacef",{"pageContent":"internal, for architectural drivers, 27\nprimary functional requirements, 272\nResponsibilities, allocating\nbrownfield development case study, 154 \nto elements, 47–48\ngreenfield development for mature \ndomains case study, 84, 91–92, \n101–102\ngreenfield development for novel do-\nmains case study, 116, 126–128, \n134–136, 139–141\nReusing architecture or code. See \nRefactoring.\nReviewing design inputs, case studies\nbrownfield development case study, 152 \ngreenfield development for mature do-\nmains, 80–81\ngreenfield development for novel do-\nmains, 111–112\nReviewing design inputs, overview, 44–46\nReviewing iterations, \nbrownfield development case study, \n156–158 \ngreenfield development for mature do-\nmains case study, 99–100, 104\ngreenfield development for novel domains, \n118–120, 129–131, 138, 143\nRIAs (Rich Internet Applications), design \nconcepts catalog, 215–217\nRich client applications, design concepts \ncatalog, 214–215\nRisk, definition, 188\nRisk management\nanalyzing, 178\nATAM analysis, 188\nestimating, 194–195","metadata":{"id":828}}],["f92d5684-e52f-46d7-b43c-9e53c6c60514",{"pageContent":"concepts catalog, 215–217\nRich client applications, design concepts \ncatalog, 214–215\nRisk, definition, 188\nRisk management\nanalyzing, 178\nATAM analysis, 188\nestimating, 194–195\nnon-risks, definition, 188\nRounds, development, 44, 271\nRozanski, Nick, 171\nRUP (Rational Unified Process)\nconstruction phase, 165, 199\ndefining candidate architecture, 165–166\nin the development lifecycle, 199–200\nelaboration phase, 165–166, 199\ninception phase, 165, 199\noverview, 165–166\nproof-of-concept, 165\nrefining candidate architecture, 166\ntransition phase, 165, 199\nS\nSatisficing vs. optimal solutions, 14\nSatisfying architectural drivers. See Archi-\ntectural drivers, satisfying.\nScenario-based design reviews, 187, 189. \nSee also ATAM (Architecture \nTradeoff Analysis Method).\nScenario-based documentation, 67–68\nScenarios. See also Quality attribute \nscenarios.\ndefinition, 19, 273\nfalsifiability, 21\nprioritizing. See Utility Tree.\ntestability, 21\nScenarios, quality attribute, 101–104\nSchedules, estimating, 194–196","metadata":{"id":829}}],["b2378e3d-1fb6-4df0-bed7-6d0fe642bfd1",{"pageContent":"Scenarios. See also Quality attribute \nscenarios.\ndefinition, 19, 273\nfalsifiability, 21\nprioritizing. See Utility Tree.\ntestability, 21\nScenarios, quality attribute, 101–104\nSchedules, estimating, 194–196\nSecurity, tactics-based questionnaire, \n257–259\nSecurity tactics, design concepts catalog, \n236–238\nService applications, design concepts cata-\nlog, 218–221\nSimon, Herbert, 208\nSimulation, 177\nSketches, definition, 273. See also Prelimi-\nnary documentation.\nSketching an architecture, 169–171\nSketching views\ncreating preliminary documentation, \n65–68\noverview, 48\nwww.EBooksWorld.ir\n288 Index\nSketching views, case studies\nbrownfield development case study, \n154–156 \ngreenfield development for mature do-\nmains, 84–87, 92–99, 102–103\ngreenfield development for novel do-\nmains, 116–118, 128–129, 136–\n137, 141–142\nSkills practice, 209–210\nSmart Decisions game, 112, 121, 209\nSoftware architecture\ncommon issues, 4–6\ndefinition, 3, 273\nimportance of, 3–4\nSoftware architecture, life-cycle activities. \nSee also specific activities.","metadata":{"id":830}}],["f1a6c954-6bbc-44ba-a638-2d1e52250ab9",{"pageContent":"Smart Decisions game, 112, 121, 209\nSoftware architecture\ncommon issues, 4–6\ndefinition, 3, 273\nimportance of, 3–4\nSoftware architecture, life-cycle activities. \nSee also specific activities.\narchitectural design, 4\narchitectural documentation, 5\narchitectural evaluation, 6\narchitectural implementation/ \nconformance checking, 6\nASRs (architecturally significant require-\nments), 4\nSoftware Architecture in Practice, 3rd ed. \n(Bass et al.), 3, 7, 8, 19, 35, 230\nSoftware Systems Architecture: Working with \nStakeholders Using Viewpoints and \nPerspectives (Rozanski and Woods), \n171–173\nSpikes, 199, 273\nSpring framework, design concepts catalog, \n241–242\nStakeholder benefits, selecting design con-\ncepts, 56\nStandard components technique for estima-\ntion, 195–196\nStructural patterns, design concepts catalog, \n224–226\nStructure of overall system, establishing\ngreenfield development for mature do-\nmains case study, 81–89\ngreenfield development for novel do-\nmains case study, 112–120\nStructures\nallocation, 59","metadata":{"id":831}}],["93faf110-89c7-467f-9817-798ab271af4d",{"pageContent":"224–226\nStructure of overall system, establishing\ngreenfield development for mature do-\nmains case study, 81–89\ngreenfield development for novel do-\nmains case study, 112–120\nStructures\nallocation, 59\narchitectural and design patterns, 59\ncategories of, 58–59\nC&C (component and connector), 59\ndefinition, 273\ndeployment patterns, 60\ndesign concept types, 59–60\nelement properties, 60\nelement relationships, 61\nelement responsibilities, 60\nexternally developed components, 60\ngreenfield development for mature do-\nmains case study, 89–99\nidentifying to support primary function-\nality, 51–52\ninstantiating elements, 59–60\nmodule, 59\nreference architectures, 59\nrefining for greenfield development for \nmature domains, 52\ntactics, 60\nSurveys. See Tactics-based questionnaires.\nSwing framework, design concepts  \ncatalog, 243\nSystem requirements, case study, 77–80\nT\nTactic, definition, 273\nTactics\ndefinition, 33–34\ndesigning structures, 60\noverview, 33–34\nvs. patterns, 34\nfor performance, example, 34–35\nTactics, design concepts catalog","metadata":{"id":832}}],["ad465ea1-b251-4ba1-92b2-73247276eedd",{"pageContent":"T\nTactic, definition, 273\nTactics\ndefinition, 33–34\ndesigning structures, 60\noverview, 33–34\nvs. patterns, 34\nfor performance, example, 34–35\nTactics, design concepts catalog\navailability, 230–232\ninteroperability, 232–233\nmodifiability, 233–235\nperformance, 235–236\nsecurity, 236–238\ntestability, 238–240\nusability, 240–241\nTactics-based analysis, 180–185\nTactics-based questionnaires\navailability, 248–252\navailability, example, 180–185\nDevOps, 263–266\ninteroperability, 252\nmodifiability, 253–254\noverview, 247–248\nperformance, 255–256\nsecurity, 257–259\ntestability, 260–261\nusability, 261–262\nTeam Software Process (TSP), 200–201\nTeams, vs. individual efforts, 202–203\nTechnical debt, 16, 274\nTechnical skills, among architects, 7, \n209–210\nTechnologies, selecting in a greenfield de-\nvelopment for novel domains case \nstudy, 120–131\nwww.EBooksWorld.ir\nIndex 289\nTechnology families, 35–36, 37, 274\nTEST (testing) phase of TSP, 200–201\nTestability\nof scenarios, 21\ntactics, design concepts catalog, 238–240","metadata":{"id":833}}],["7f9429d7-72af-49eb-8cce-2a838725c42a",{"pageContent":"study, 120–131\nwww.EBooksWorld.ir\nIndex 289\nTechnology families, 35–36, 37, 274\nTEST (testing) phase of TSP, 200–201\nTestability\nof scenarios, 21\ntactics, design concepts catalog, 238–240\ntactics-based questionnaire, 260–261\nThought experiments, 177\nTracking design progress\narchitectural backlogs, 69–70\nKanban boards, 70–71\noverview, 69\nTransition phase of RUP, 165, 199\nTSP (Team Software Process), 200–201\nU\nUML (Unified Modeling Language), 191\nUsability\ntactics, design concepts catalog, 240–241\ntactics-based questionnaire, 261–262\nUse case model, case studies\nbrownfield development, 147\ngreenfield development for mature do-\nmains, 77–80\ngreenfield development for novel do-\nmains, 108–109\nUtility, selecting design concepts, 56\nUtility Tree\ndefinition, 19\nprioritizing quality attributes, 23–24\nvs. QAW, 24\nV\nViewpoints, definition, 171\nViewpoints and perspectives method\nflowchart of steps, 173\noverview, 171–173\nperspectives, definition, 171–172\nsteps involved, 172–173\nviewpoints, definition, 171\nViews, definition, 65, 274","metadata":{"id":834}}],["cecd71c8-d45b-45c5-978a-1aa216835c5a",{"pageContent":"Viewpoints and perspectives method\nflowchart of steps, 173\noverview, 171–173\nperspectives, definition, 171–172\nsteps involved, 172–173\nviewpoints, definition, 171\nViews, definition, 65, 274\nViews, sketching\ncreating preliminary documentation, 65–68\nbrownfield development case study, \n154–156 \ngreenfield development for mature do-\nmains case study, 84–87, 92–99, \n102–103\ngreenfield development for mature do-\nmains case study, 84–87, 92–99, \n102–103\noverview, 48\nW\nWaterfall model, 197–198\nWeb applications, design concepts catalog, \n212–214\nWeb pages, as resources for architectural \ndesign decisions, 39\nWoods, Eoin, 171\nwww.EBooksWorld.ir\nThis page intentionally left blank \nwww.EBooksWorld.ir\nSATURN Conference\nThe Software Engineering \nInstitute (SEI) Architecture \nTechnology User Network \n(SATURN) Conference is \ndesigned for practitioners who \nare responsible for producing \nrobust software architectures \nand those who view software \narchitecture as a critical element \nof achieving their business goals.","metadata":{"id":835}}],["14ad3894-499a-4a79-8e42-aba7e430f971",{"pageContent":"designed for practitioners who \nare responsible for producing \nrobust software architectures \nand those who view software \narchitecture as a critical element \nof achieving their business goals. \nAs the premier architecture \nconference for senior engineers, \nSATURN offers keynotes and \nsessions on both essential \nskills and cutting-edge methods \nfor software architects.\nTo learn more about SATURN, \nsee www.sei.cmu.edu/saturn.\nLearn More About Software \nArchitecture from the SEI\nSATURN and the SEI Architecture Curriculum\nSEI Architecture Curriculum\nBased on decades of experience \narchitecting software-reliant \nsystems and supported by four \nwidely acclaimed books, this \ncurriculum equips software \nprofessionals with state-of-\nthe-art practices, so they can \nefficiently design, evolve, and \nmaintain software-reliant \nsystems that meet their \nintended business goals.\nTo learn more about this \ncurriculum, see www.sei.cmu.\nedu/training/find/courses.\nwww.EBooksWorld.ir\nAddison-Wesley \n•\n Cisco Press \n•\n IBM  Press \n•","metadata":{"id":836}}],["5fb35c74-27e3-49be-988c-fe7e4cd48866",{"pageContent":"systems that meet their \nintended business goals.\nTo learn more about this \ncurriculum, see www.sei.cmu.\nedu/training/find/courses.\nwww.EBooksWorld.ir\nAddison-Wesley \n•\n Cisco Press \n•\n IBM  Press \n•\n Microsoft Press \n•\n Pearson IT Certification \n•\n Prentice Hall \n•\n Que \n•\n Sams \n•\n VMware Press\nREGISTER YOUR PRODUCT at informit.com/register \nAccess Additional Benefits and SAVE 35% on Your Next Purchase\n•Download available product updates.\n•Access bonus material when applicable.\n• Receive exclusive offers on new editions and related products.\n(Just check the box to hear from us when setting up your account.)\n• Get a coupon for 35% for your next purchase, valid for 30 days. Your code will\nbe available in your InformIT cart. (You will also find it in the Manage Codes\nsection of your account page.)\nRegistration benefits vary by product. Benefits will be listed on your account page \nunder Registered Products.\nInformIT.com–The Trusted Technology Learning Source","metadata":{"id":837}}],["fc2abc45-7626-4d22-9b1a-a23ecfcc107a",{"pageContent":"section of your account page.)\nRegistration benefits vary by product. Benefits will be listed on your account page \nunder Registered Products.\nInformIT.com–The Trusted Technology Learning Source\nInformIT is the online home of information technology brands at Pearson, the world’s foremost \neducation company. At InformIT.com you can \n•Shop our books, eBooks, software, and video training.\n•Take advantage of our special offers and promotions (informit.com/promotions).\n•Sign up for special offers and content newsletters (informit.com/newsletters).\n•Read free articles and blogs by information technology experts.\n•Access thousands of free chapters and video lessons.\nConnect with InformIT–Visit informit.com/community\nLearn about InformIT community events and programs.\nwww.EBooksWorld.ir","metadata":{"id":838}}]],{"0":"692f0dd0-551e-4b43-9f1e-b356d74d00fc","1":"e3df8653-746b-4b68-87e3-22d1fab79324","2":"a33920a7-f2c5-43e8-805f-8c1fd185f6e5","3":"e61ee38b-6d05-49d7-b23b-9fb20bffab70","4":"2c3aa873-9d11-4b5a-977a-8645a3389bdb","5":"9f062083-51af-49d0-87c6-5b53ce15abb1","6":"bbbe386b-d153-446d-8f33-8af65b2460eb","7":"64e2e615-c220-4379-9f51-4a2e20c9af46","8":"4d915f5d-ae74-4722-affe-e041be69bfc9","9":"6f26b873-d7c9-433a-8e7d-80801f5b29a6","10":"34565ea1-d795-4db9-bc9a-8011572d7d75","11":"2869793c-578d-470f-a328-a7139575cd0f","12":"c12d1b14-f92b-441d-9fa0-0cf7e7ea275b","13":"237ce3c1-efef-4ecd-9229-3a3f2021d3af","14":"5b336d5e-04f5-4536-b908-fcde23c498ad","15":"98f13a76-f3b6-4e8d-be43-b9b32579bea8","16":"6ae7b77d-df91-4f32-a0c2-9d05dbbe325a","17":"fc564047-7f65-4f11-9366-775870a5c430","18":"6b147493-fac1-42dc-a616-81b45393afbb","19":"0ea086eb-e7d4-4982-853f-ec97ef18515e","20":"ede8af41-3586-4f67-a4c3-a7dcae128778","21":"29f5c2b1-440a-41ce-871f-828a49b3df09","22":"7a533b8d-194d-4eda-a1b9-5f9e68090daf","23":"43038b36-0a5d-4741-9426-62c5fe5bfb4b","24":"4074be2a-d23c-4438-8168-a00fb599089e","25":"c0de01bd-c88f-4bb7-8ffd-42dabbd373a2","26":"857c7974-34af-42e7-8c75-2a13ece031fe","27":"b96f903b-d685-4db2-9d81-198d6cb1039d","28":"f83046aa-efbd-4c0e-a32b-ac11e7e933c4","29":"26703139-850b-43ff-aa4d-2c400f000b22","30":"ae1d9c2f-d0fc-42ef-970f-f56320f03a8f","31":"d238cb07-3c9f-48af-9eae-c5cc9809b38a","32":"5e7230f6-cf37-4567-821a-c9c9cf97ba93","33":"8c4ed03a-7c5a-4f65-8cb9-15981e289577","34":"8d926955-f73c-4ec8-b8e5-eb0edaaeb4ec","35":"4447d494-c220-4f84-903f-1dacab8e468e","36":"4e71d92f-a499-464c-934f-f1dfa44558e9","37":"fb890a3d-3206-466a-b5af-6b2d7c280227","38":"4596a647-181c-402d-9747-eeae3344dddd","39":"8c07f564-fe5a-4c10-a566-7ed8be1d5967","40":"c8095d34-ddab-48b1-a497-b08e9331823e","41":"41585ed1-49cc-45fa-9fe7-f0a88aaa016f","42":"ad9ca02d-b47b-4556-89ea-ef5d459b9273","43":"47e4f2b4-9476-4281-bf5f-d052cc6f2748","44":"bd089f4b-c18a-44c9-96e1-b5abd66cb381","45":"63354228-7a42-4d9a-99ea-85ae02749e67","46":"fa06804a-200e-4eab-a9d2-214e26ae7c2e","47":"4bc8e927-12c2-49a6-acf7-667a9703b3a5","48":"49e008c0-0d36-4f6f-873f-6f0b3441f1bd","49":"22b67d91-0b9c-4c0b-9d58-dfbb6a1536f3","50":"18c78234-8f46-4abd-9ab8-0fb6fd8cd33d","51":"cc505cb0-e765-477b-aca3-2a625828e4ef","52":"5af106c9-6163-4afa-8360-3dc40fe9ce4e","53":"64aa6433-e248-4109-9d9c-f42f50ca57f5","54":"b209cf50-f147-4822-804c-af922a293753","55":"b3fa5f31-4ec1-4a95-bfc3-bdd544cb805a","56":"e5cd416d-f4fd-49d8-9fc5-419fc16e9dc2","57":"9a0c2fd7-527f-4c9e-9567-fb10e5d37d86","58":"ffd96b0a-dcaf-45e4-9b4d-932235155110","59":"2937661f-a079-4769-bc01-d4e5c8f71edf","60":"ab645c42-f159-4a76-a0a7-a34eafccbbf5","61":"a8b313a2-3a74-4e73-9d93-3829d5f10049","62":"2af3d62f-9b09-4d7f-8b0d-f28529670a55","63":"1ec721ad-dd9a-4bea-be43-963fa1a870d1","64":"3250eec0-60fa-46bb-96f7-4beaee1470b0","65":"b00fe016-f6df-470a-950f-078784a127d4","66":"33db9642-019f-462d-9c50-60ad8e33ecf4","67":"c0378633-fe8e-46e0-8fd3-b665078fb489","68":"97295f3f-0444-43b6-ae9f-c597a5fbbb21","69":"f3ceba31-0d83-490d-a57e-2d47f2573aca","70":"f16054e4-e503-44b6-9f64-293ef92df737","71":"c2e5ce2e-6c03-410e-b34a-45800ae62400","72":"606c57d5-9195-485b-a84a-929cf54fcda5","73":"8045d5b4-2f83-4596-aa7a-a2288d457c05","74":"3f7ae069-1f15-440a-b218-2b4efa3bb93f","75":"35039c96-d182-45ea-91a0-9ed4736aa70f","76":"3f7712d9-d5e4-42b9-a078-0a43f937716c","77":"1304fe81-19f3-4bc6-8bd1-4e07f154a275","78":"8c7f3337-d581-482d-b0a6-a9d6f7a73a23","79":"9fc91db9-675b-46e0-af1a-75d473572298","80":"8fda20ba-455d-47ce-a115-8f759a127f45","81":"f7f181d6-3119-41f6-9993-b147c7423b1f","82":"eaacd808-eb30-4a95-8236-479825be07b8","83":"d6e8ecb6-3410-4e31-9045-cb5ef39c46da","84":"261f9cd4-25f7-41d8-a817-08dd8b975faa","85":"d8ba1a60-07d4-42fd-a8a0-8371a88a98cf","86":"960f0e2d-a9ab-4d48-a528-35fa0aa75d93","87":"e40d569f-220f-424d-865a-04a604514f06","88":"48e9267d-22c2-4bf3-ae1e-2a2bea26b63d","89":"075c2f40-ac2a-46dc-ac36-e5824e9d80b4","90":"58b19e53-d32b-439e-83b6-2311aae895c5","91":"bb2bf229-bcf4-420a-8cd2-3d6ed4e9c398","92":"9771bbbf-5e33-4f1f-a6e8-6ca342e0b61a","93":"fa01dc5c-e398-4fe7-bd6f-1bf5c0c058cc","94":"287fd64b-3706-4e7d-a381-ad36460a639d","95":"f98e2fef-e608-4df6-9fbf-9550e4c949d4","96":"1fed16c7-c860-4dc6-81e5-6c4a75008d2b","97":"f6828c84-939d-4910-9042-d4b8f456432d","98":"9ffb156d-d0d5-46ab-bb00-0e3402f19419","99":"3622884c-69e8-4cf9-9c70-5a6cc5bc8632","100":"d5a4f4f6-8541-4b51-8bde-6e0c1f6ef6a2","101":"8044e192-5748-43d1-bdf8-422ab282ecdc","102":"3feb83d0-2cf5-43c4-a54e-878dd2cb2db3","103":"fab66ed2-9e01-48e0-9e12-afd2863b4508","104":"8860cfb7-c10e-493c-92a1-b4d6ecd54c26","105":"d78dadb1-1975-4660-95f1-ce30c6d55bcd","106":"b975645b-9d92-46eb-a097-73a6ffdcd2a4","107":"31b6a676-66e4-462e-9a5b-c7b60e482081","108":"e4efaaa7-68b4-499c-8e77-9ac0a48ee420","109":"18e82d7a-ab94-44a1-bdf3-d793f1e509b5","110":"6b430309-6612-4674-8ea8-ca494d5e6858","111":"80af3016-6884-462b-a1bf-603d1ec8c196","112":"e5da73cc-1344-468c-8045-a138d87efede","113":"098e0dd0-56d3-402d-bdb1-e5dd6f358554","114":"51f24f8b-6e74-4d13-b226-cc96d9025931","115":"e3fe157f-af46-48be-b538-6626762d0ac8","116":"b1a8d1b3-cce1-43cc-886a-59f7b315f9a1","117":"ea6695b7-8f4b-499b-bd0c-44de655213df","118":"8ed87ad0-230f-4590-af27-079f48634883","119":"bf8a6621-15bb-45ed-bc59-2fbfa5e5850f","120":"f6508e8f-a946-4494-a693-a52329a7338e","121":"fdfcf90d-cab2-475e-8c11-1f5b7a6a13c0","122":"87056d57-06e4-4aa5-b2f9-8a4b88c35b90","123":"78a9cf55-5306-43d0-a479-d52c03d38d5f","124":"36254722-e96d-4f7f-aaba-4da63dd5d4a4","125":"e393e06a-a86f-4aef-a707-148927063592","126":"53238bd3-4da3-4746-bb30-5f91af3c11b7","127":"534c5060-3750-4ddb-8f0c-53bb492b642e","128":"322d5b00-6dff-4410-8d4e-59ca648aa210","129":"3f93b802-5655-4cbb-bf0e-45ab290c4f92","130":"dea552bf-9dda-406e-a879-ab16a3b52f0f","131":"5ea6a9fe-3cf0-4a9a-bb8d-e8b2203bd7a0","132":"6e88f9ab-62c0-4c70-b747-6ddfea503ea8","133":"06a61680-e268-46a9-be6d-584e759c9e01","134":"fa57ae23-ec3a-4c84-9fce-be4d53e7ab32","135":"6491d086-fd51-4580-a4b7-f17229b82961","136":"14934090-31fa-4547-a20c-08ea139c44f4","137":"3d3b4fe1-49f3-4ebf-b9d2-1f3227e9f4bf","138":"f35e3f34-eb31-4945-8fee-3f52f499544a","139":"69230eac-0f47-45ca-b275-2b5633896740","140":"e71d680c-8b00-431e-b582-ba2824f22a92","141":"e12a77c5-fc7e-47bc-bc63-5b1b9d7d8cdb","142":"602a6c4e-29e2-483b-aaef-8a9a68d6e219","143":"ad75807e-e154-4a44-91c2-84a4a5b3faec","144":"2e3874af-7ee3-4656-8691-58f24ba75374","145":"c59ee64a-edcc-49ab-9913-29d6b717ebe4","146":"27c7bdc9-aae5-4535-bf23-f37bb4f7e4ef","147":"3f523c26-137f-4ed8-9806-31cd926b1c86","148":"101c1fbd-5787-4bfa-a084-5592520567fe","149":"fa4f5bb5-ac4c-4dc8-ab49-edfd57a7a182","150":"185f7510-82ae-4079-9d29-e9a7f90d7693","151":"3a477ffe-67f2-4f37-9f12-961841b752f6","152":"d964677c-a9b7-47c0-9699-3b39983db072","153":"7e0fd078-e768-4999-99d4-e23acdcf2f01","154":"34c7f6b2-0b18-470c-aa6a-1a6231b55a53","155":"7a6888f7-7e74-413b-8666-bd237a4811f3","156":"7630d2ec-d47a-44f4-b7dd-8cae79dd4c37","157":"96fd8986-6fd4-4fc0-9f0b-1975b38a3dcc","158":"a77bc144-d64b-4951-99f7-0f36a468a8f8","159":"35d66c0e-0425-469b-828a-49aa72bdfcbb","160":"e963bc13-9db7-4f0e-83c7-a2be226c4ff3","161":"bde30332-a089-4705-b8ff-5078419bd7ff","162":"d9372c29-3d8b-41a5-99ee-052e401463f1","163":"f1319614-8514-4d89-9b3f-4a542e5edafb","164":"965a2f78-7b14-4d10-b3ab-d5d7516efc73","165":"b6757ab7-d2fa-45a3-9f2e-349e064f6e68","166":"67e460fd-eb47-47dc-9fe5-7c90a64cb81a","167":"838d916d-f73f-43bd-bc01-953930221c0f","168":"04f99076-3c93-454a-8856-11bb14806094","169":"72e995f3-cbeb-4eb1-88b0-8c35904f5eb4","170":"c06fac39-a533-4ae3-a05c-40f925393dfc","171":"e8f4fdbb-c2ef-4f46-8215-2cb2835cfa90","172":"c1042579-e4e4-425e-a1ff-30b6254435ac","173":"8c2aec4f-77f0-4dfe-9064-976210acce44","174":"e3e33fcb-7424-4b6b-b447-c53c4c399a9c","175":"11b09435-c9d4-4470-8896-11ec6104f3e0","176":"efb56615-f2e4-4dec-8469-a7085bbbeb69","177":"737e9e2e-bacd-41af-8c9c-2d0138e54517","178":"91f31e50-8d14-423d-9a14-a3a383c3afb4","179":"abced3e1-4d1c-407d-a58f-760c32279e7e","180":"50724853-2a5c-4225-b686-f1a3798deafb","181":"8a1f18fe-3f36-4179-95bc-432a496c4aa9","182":"ad629950-77e6-4d8a-b514-61e5434aac7b","183":"bef32716-bd37-4cec-9bb2-2dae00639705","184":"7c19e84e-af9c-446e-a29f-8199a15a0df5","185":"e1fbfe3d-d1ce-4ad6-b6f2-fb66f3b0e0ae","186":"60bd4386-238d-4fc7-9239-fa3587a9702e","187":"caac74fb-b65f-44f4-ab31-bf319029d877","188":"1842230f-582d-4bc3-9439-ae4e425ab272","189":"89198ea7-b0f6-4330-8c3d-00fc12c001b8","190":"39676776-d2de-4036-ae5a-ba37e21c1bca","191":"2ca08be2-fb17-4944-9807-a69253f23d9a","192":"eaa129b8-b889-40f2-a333-6f157ce5a7c1","193":"df2f05af-1430-4d02-a602-74d65b266154","194":"b24e7948-ae72-48ba-aa2b-f27e78c7be3e","195":"52f86927-9c19-45e1-93e8-539d96f8e86a","196":"33f39e14-b528-49e5-809d-757dc910aa13","197":"ef1f23ae-64f1-46f2-9ff2-58038eced81a","198":"80d4f559-97f0-4cf9-84d0-3218ee2a4651","199":"2620c516-471d-44dc-8f71-bed4457ba195","200":"0a9ed15e-3e2d-48fb-9112-9686be6df37e","201":"6c7087f4-65ee-4210-b0a5-5f0b7f0ec25b","202":"b07c5a37-d377-4782-91cb-a81cc684de4b","203":"8a5559de-bfd3-4bae-ad98-aac2f53e87ca","204":"bd2dc307-0ff9-44b4-82a4-c167383b70c6","205":"03a83aa0-5670-4016-aab6-2f3e855b7f58","206":"0ed4cb01-8625-45a3-8813-5362b16b01cd","207":"304c928b-d2f4-4ba5-8730-8ae9ba08d6e8","208":"47fccecf-12d9-4cc5-ba8b-0c21d0bbde0e","209":"33863db9-7898-4d62-a512-96adde252b73","210":"ebdece9c-d2bb-4e79-aa0b-f33531d49776","211":"2dada2ad-e3cf-4b5a-a83c-b92e6620fb9f","212":"8f37c5b2-66d4-4c9c-be5d-1cc3da24d455","213":"e63d5d82-627c-4bec-be01-dbed9633bf99","214":"94a3bf90-ba0f-4b5a-a09e-5c4615cf0f6c","215":"f415d550-77d4-4e76-9420-494bf494842b","216":"906b58e4-865e-463f-9ec5-64538343b700","217":"619bed69-3863-4bc7-8a41-b7cea87eb890","218":"4c217705-da03-4d16-b8a9-d7a1fb688899","219":"e90bcab4-4099-4556-bcda-1228d7764302","220":"91a809de-734d-40b2-aff2-3d3c6f30958f","221":"d744ffa9-5bd6-4513-87a2-658c98a56dfd","222":"46615f78-6472-479b-a94b-a43660d82cde","223":"a37f195e-c48d-4f85-9403-133d0f8568e6","224":"f0df9bcd-7a2a-4acf-877d-eb055d9916ac","225":"2083fbcc-315a-4d9e-8731-299f980b2b0d","226":"75eda82e-0192-4d67-a90b-5c4f1b06e911","227":"b6fec3e6-13ea-411f-9892-7c71917b8638","228":"c22dbb61-252e-48eb-bb17-d4ae3c3e585e","229":"9dd7fbdd-dbc1-4725-8915-ef915b5acb11","230":"40c2cbc4-11db-4465-a120-874df31738eb","231":"2202e7d2-5503-4785-abff-5f03c3807511","232":"85cc797a-05a0-494a-9914-7b86d518da9e","233":"d35ca24f-405c-47a1-84f2-ce8ee745e277","234":"2826d443-69e8-43ae-b6d6-2ba28bad0e5b","235":"75df1105-f6f7-4801-89c0-882dc919c90c","236":"2516c45d-6a11-40ca-b6c5-fa18f632e756","237":"c0ecffa9-6733-47d7-bc59-a28faa9082c7","238":"a5a0d89c-96f5-4129-8a57-22e1f4192ba1","239":"8bc7fb3c-6499-48b7-b1b4-926a71db657a","240":"1b6eacc4-f23b-4191-b78c-db529845dbfe","241":"d03f60ae-1fbc-47a6-a2c0-4d48ccc585f0","242":"8f55a075-7fe9-4a85-8c79-37e0881d501d","243":"921eb4bf-8767-41ba-aafc-c8a471e2def7","244":"edbbbfd5-337c-4144-9ea5-d776acd0005e","245":"97f55da1-2aa3-44ce-ba61-b4c8f10dbbe4","246":"c6437200-820c-424a-8e44-05464ba0e7f6","247":"cf141de9-e7bd-4ef0-a3d8-b022246e3de7","248":"c911ca70-e17a-43c9-abc2-14b8c46bf1ce","249":"76ab1524-d5d2-4956-b9ca-f25038bf4b01","250":"418df842-2e07-455f-b867-8ca2867e64fc","251":"ddbfc286-6eb0-4e15-af52-6f5c242be6c6","252":"78572a90-6b51-48b0-ab3e-2c3a2cd68163","253":"a3fcfae6-4a45-489f-95b5-68902a79d51d","254":"e8111173-d032-4ddf-b569-889844b8ec8d","255":"52b2d6cf-a49b-4806-8acf-519aeab55cbd","256":"2bf2a25e-6cae-4e43-9871-6ebac0644881","257":"8e40ee31-fcea-4e36-845b-2e0a30512e1b","258":"bcaf3667-1934-4d9e-bd72-c1de479de55e","259":"26da12a4-2c68-4d4c-a2ad-5797ef655f74","260":"4be4aaa3-b55c-4999-a3d1-4194bc3172e0","261":"b36114be-a3be-4377-b501-70d29a2b4bb2","262":"1ded56ac-541c-4c9c-b122-4231dd38c27a","263":"e3800aa3-d1ce-4d0d-8694-3682468552f5","264":"c5cd7992-282a-4fa4-b0d5-228d89cf3b63","265":"e5c59b44-4b50-4d57-9595-b893dc1dc9a4","266":"0f600a97-e02a-41ff-8a8b-b9459881c42f","267":"c105f513-b857-4e9f-9fff-dcabb0a63bf1","268":"3d308067-dc07-4a4d-a388-fcdd6ff413c1","269":"a440762b-7bcd-42ef-bfc0-41a0f0ba90a3","270":"69154dd3-0e28-4b95-93f4-dd062ee60107","271":"e47e5b3a-14f9-4e07-92c4-498328725b17","272":"c4a53bd3-a42a-451d-91c4-28c3a3d2bf40","273":"1b637b66-ac7d-4271-ac85-daaf04929a71","274":"5529d5c4-fdf1-41d8-a621-4d40cbdbbe3f","275":"03e5c761-520e-486a-9e9f-21ae41b4809d","276":"ff7966be-bfb2-4f8a-8e6f-d33b01f3c8d8","277":"2e188181-1cc0-498a-a77a-776f86178420","278":"eb2b52c3-0b2c-4d07-bf34-19d93dc3653d","279":"8ecfb66e-bfd0-4bd6-85a0-ba1b22f61c55","280":"c1bfa47e-2687-4c12-9afe-7b0287176c4a","281":"f455040a-8601-4f37-8ad3-f578abcfbaa0","282":"6f33c2da-1193-413b-bb64-96a32e0863de","283":"d0ee7ede-f87a-46f7-88ed-707421569260","284":"0e68821b-511e-47a0-99c3-5a24b15cfc50","285":"5dc63c36-8f62-4e5a-92ea-7ebb13f7c2c7","286":"86c22122-4c7d-4f32-98bf-ffce9f2874af","287":"d8f6df6b-5a3b-4a62-8ac4-8f9a4681449e","288":"c7865ea7-8920-41b1-873c-1f0bb585fbda","289":"c544e971-a809-4311-8a00-c0770371860d","290":"33eeffe0-348f-4266-952a-4815bbd28898","291":"c4e90e8c-2902-46fd-b831-74fe6a494278","292":"0495fec6-da52-4e6f-8e12-490301f0df63","293":"86771dc5-d341-42eb-acc3-2058ffaae144","294":"58812188-fd9a-4879-89aa-3a2058450c11","295":"a0e16013-2ea9-4468-ad6b-d1ac9abc1e23","296":"5a84d705-8653-4a2c-bad6-126e79eba5d4","297":"955178a1-f8e2-48c7-b05e-d16645dbafb2","298":"5ee4cd74-b2b8-4a7d-8008-df07846a37d1","299":"895b9f15-813f-4933-948f-0478d5ee9c83","300":"14a6783c-599e-410b-82f7-d7c4d30ff2f1","301":"c8f879ec-46af-4af1-9619-58b2db566703","302":"a27754a4-d9dc-4016-b829-9774178d95db","303":"0a09c549-ebfd-4723-ade8-8a373add1b09","304":"888ec3b0-8363-4432-abf0-a6fde0841aa5","305":"1d7bbd27-e05d-4e4f-ba1a-b93e8d5247b2","306":"ee319ed2-ec65-46c9-8c01-f4d0479b2505","307":"dbdd448c-d43c-4b39-ac7a-a949688fda08","308":"0cc00c89-8f4b-4d49-ac1b-f63d00ebd32b","309":"cfc18867-ccda-4329-8ac8-cc61402a9fff","310":"ce4481ec-d9d3-4341-b626-41a01d49f17c","311":"538194d8-c35c-4bb7-b10e-5a09bfb8469d","312":"fc4bff26-e620-4a13-9ef8-4d34716f4b10","313":"dc81d05c-bc89-4049-ae58-c7b67de2ce04","314":"3ecdf993-1fd9-403f-8d43-d854f92c515e","315":"b402574f-8619-4b19-90e0-e280a9e36732","316":"aeca68bb-b935-469a-982b-093f43da040b","317":"5ec1012a-c53b-41e2-abd0-14120c3b0185","318":"4ce4149f-9c09-400d-8e7e-cf6f13c1bc89","319":"0cb62757-73c1-4a78-b085-33f2c1f9c935","320":"dffb6859-eac8-42dc-b352-7cf753c65d92","321":"9a22b3ec-6347-45d6-8387-22c6ddc6767d","322":"b15c7697-d7b8-46e4-84ad-7a4dc3b64363","323":"134d8ace-516f-43f1-9f12-2bc4254333d3","324":"41cc5190-3ac9-44c3-bee5-931f9ad468e7","325":"12e14e91-b7ed-40cc-b4a0-6cecc3c9d3bf","326":"997f65e5-7819-4b31-bc4c-783982414acf","327":"2ea73b55-5559-4007-b0d4-6d0176d1e883","328":"5b51795f-a79b-4fb8-bb59-782b0e456326","329":"d961d732-ccf9-405a-8e4f-b3197a6bb05c","330":"3096c62f-fb2e-4ad1-abcf-b472250f0559","331":"875dd2e4-de54-4609-93b4-b2c95c7e3129","332":"e4e52e95-8449-4d27-95ee-60512cedd604","333":"e78c209b-feda-4567-a7d0-46a113e2f241","334":"5eb29b59-a31c-4a9e-9851-a8cc3ec3efcb","335":"6a94ba15-533c-4cf6-af1a-902a37dd6b02","336":"0947ba52-aec8-4990-8c13-0a7e33931892","337":"3d3dd3fe-0679-4295-8919-96dccc55b520","338":"c05870b3-a4fd-4a3e-9641-61830644d5f3","339":"64013eb2-928f-4dab-bf98-c5b137eed7ff","340":"e758585c-ddca-4a52-8a3b-2ccf47533548","341":"71d4cc4c-3878-429e-952e-3d436bb6119d","342":"03a98132-0f8c-4fca-ae03-ad6130fdb27b","343":"436875f6-a1a7-4d30-9584-3dc5b655de6d","344":"51979f93-f133-47e9-824a-4e5da696f303","345":"e457f912-6cf8-4714-87d8-6fd1708eeab4","346":"81bd07ee-4b61-4468-854c-326d453fdd32","347":"d93e8667-873c-4e37-bfa2-6b78b643898c","348":"a7f34b9d-00a9-42c5-8f7b-156f5e59ca8e","349":"ccdab1a3-b2a3-4dd3-892e-5b472049c6de","350":"77f068d2-79de-47a6-9c7f-d94be5920490","351":"3cdd2a92-9c5b-4006-a438-2bbc7ab9a1ce","352":"9f22a095-2fa8-47e4-bc64-ea2df0422f43","353":"cb47c4ac-793a-4d66-ab2b-791d598f472c","354":"60940a34-e4ad-400e-ac3b-56507a52d6d5","355":"f1a4c99f-97e7-454b-af63-5097efc64b0f","356":"808c5783-f9ab-4c13-9f14-3740db9a72f8","357":"52210afa-1bca-4f55-9d03-b1473a9f8e89","358":"c503077b-4633-4b85-99df-c460b554dafc","359":"4c7526fd-5743-4ad7-aea2-a3ebcbdb0784","360":"531a3f6d-1b88-470b-8b94-174a08cfaf1e","361":"22d76678-398e-488f-9cf4-662d0dc50d7c","362":"6a78a90b-1341-4b1e-886d-08485daa5b19","363":"7c8046a6-abce-49ec-a777-9a7a0df54131","364":"00182622-55ef-431a-a797-01c763e8c689","365":"6eea6fa9-f7cc-4ea3-a64d-616d4e1a4b38","366":"77109908-a66e-44f9-9c08-fcb2d383c40f","367":"dde0bbd2-c408-45f6-a18c-571084319059","368":"5162125e-9fb3-4806-9d1f-c4af5bf0c228","369":"965bbe4a-eb4d-4dbf-bd4c-fa45fb9fc811","370":"ce00a1da-ba97-4080-ba73-5772fe613155","371":"ae84cc16-9cf4-4963-904f-e3a879451846","372":"0c67ec06-bae0-4c58-abd5-987c86bf929a","373":"ae017e96-a7cf-4a62-bfd3-076fee9d1f64","374":"d79b29cf-3290-49be-aa15-2f6013a22c85","375":"8a805f20-3c8c-4e7e-979b-bf5a30ca71ad","376":"889731ae-1bca-4e2e-9ec2-07cd5f5bfd09","377":"571e52ca-569d-4432-9bf8-3225bcea1903","378":"f0f80029-c278-49be-a60a-0c585a970319","379":"8e18b3ce-f6ae-46b5-838c-35c8408010f0","380":"309d137e-4a59-475a-8a03-0451ceb939db","381":"46309698-c18b-4a40-b362-ffda4c0d8e53","382":"2facd5ed-7351-409a-8a9d-0ee1055d162f","383":"616db2a1-5036-486e-a5fb-97794c96b85e","384":"60c04830-3227-4bc8-aa46-e8c7c95e469d","385":"8b74d2a6-633b-47fc-8ad2-67c1c09a1aee","386":"d0e6f40e-1126-4abc-9ed8-1e618824eeac","387":"b0e2ef98-b9e4-4be5-a2d6-ab51f4c8d1ca","388":"bb9f8604-3fd9-4954-979f-724fa5fa2dbe","389":"102bc43a-8ecb-42b2-b688-32dd0988b285","390":"e5bbe8eb-3fee-46b7-8774-d27eb66581e4","391":"514d93e9-013f-4841-bab8-60668a3680eb","392":"b7b01bd3-f6bc-44ff-be38-c21fe3f34d19","393":"43557074-5679-44dd-a06f-a368b81eb0de","394":"e6700e1a-4c20-4913-bc59-b83d3cb4efc3","395":"ea35897e-41a4-4c79-8235-3add50c5ce13","396":"85c2819a-b539-499d-8a3f-f03dc104184b","397":"c5b002a6-473b-4801-9ea8-ea5409baa9f1","398":"e984f2e5-1c16-450d-b67f-a6b86e348bdd","399":"29d44826-5341-452a-96da-7ff6ebb703b8","400":"155671f6-7751-4e8f-9096-2a2d3433b138","401":"c55a5da9-1ce1-4d4e-8237-26bb717f7ccd","402":"dd281049-4974-4c49-b437-58b420e7df70","403":"81b4bf60-23c5-42d9-ab5c-601299eaeb69","404":"d6e034a7-edda-4bab-8cea-6b3b4a010d30","405":"fb9fd3d3-49ad-4644-82ee-f20df28649fb","406":"27e91803-830c-4e7c-8312-cfac3eb8bf9f","407":"34171c50-1b37-478a-b6d6-2cd9a2d1f7ac","408":"6619980d-9a87-4443-a8c8-aaac9a5770b3","409":"083f0346-25f7-4993-b964-822a0d38774c","410":"9cbecbf1-3fab-414a-80a0-2b05acc92ab7","411":"ab976c43-e2ce-42db-9306-1f5d9c13eb43","412":"b5e1336d-d0aa-4286-9a50-7569113f2ccc","413":"8abc368d-9167-4ff9-98ba-ecba379b7765","414":"d3c42095-21b3-41d7-bb50-55f4c689d5ef","415":"c1124401-dd44-45c5-81bf-378d91655757","416":"f0625b33-c06e-4d88-8fd0-2b648b68760f","417":"1f8da440-5128-4afb-91f4-5f20188e9623","418":"5860e41f-666c-4e6c-9e11-356669b367e6","419":"9952d410-86d3-4cc6-8119-7d4fcb127dbb","420":"de506eca-0858-4f1f-b821-7fda7b3f7f8e","421":"1c0d7e55-2dbb-4912-a724-42ab6d892a06","422":"2932fe51-be85-40a0-8886-4b164148b93b","423":"15016022-b090-4c7c-a69e-891de2c6cb23","424":"a9778093-0366-45be-9c25-3b40111f4c5d","425":"1b0cf79d-aba4-4701-96c7-10139368c8e4","426":"16a53205-4a88-4279-957d-0e05ba5d2c46","427":"4ebd85fd-f93a-41d5-9d16-5c6024bd8717","428":"06294416-d894-4da0-852a-c489209f9026","429":"f7458e52-3f0e-4ee2-ace8-0f75c0e56b15","430":"6b6eb6e1-86b0-4f72-9162-3954281cee14","431":"5328bf5d-eea3-472e-ac6a-2564aa709e80","432":"1352bd58-b7dc-42b1-889f-673e39580797","433":"27c6774d-8f39-4915-ab68-1512800ebdad","434":"c557e2a3-1f7a-4542-898c-8bbdc2cb5542","435":"4e4370ad-5ffb-452b-b426-18d7b83ff44a","436":"918025d7-22de-4942-acf9-67a683a7aaa6","437":"13c97e7f-f02e-47c3-b05f-4a71624ea8b0","438":"221450f8-bf73-4285-818a-c88e435858b7","439":"7c5101a8-4a7d-4d80-927b-a9c78b247abb","440":"4af0745b-656a-4d56-9485-10f8c312a081","441":"8172ebe3-355a-4a3b-b8fa-2dbb6c645f57","442":"6393574e-53b1-404f-bc06-cbf40e6362c3","443":"77279dc4-48d2-4968-9358-90e4fd010a3f","444":"dc5b2e4a-b840-4b40-a37b-a42ead060aca","445":"73f45042-26c2-4d30-b833-9dae1165d928","446":"27699b1a-40c2-4eb3-9f87-5ae92780e0e0","447":"873885cc-718e-443a-b9c0-a8a0ceba1120","448":"0742e2ea-b271-45f9-aea1-96e9aa74f2a2","449":"4414f632-4fce-4061-823a-8a3be2659817","450":"06843b8f-2f8f-4174-bfea-b963c90fac70","451":"e06d043d-36ed-4815-ba72-ad8ed487512b","452":"5b56d7b4-33c9-4f2d-b05d-6cdd23d40223","453":"ba44410c-ad9d-4184-a322-e582edc2297d","454":"6d4ed76c-aea9-4f8c-9ef9-c681c49ed2f1","455":"5e1797f7-f81c-4f25-9bb5-4dfd2aefde72","456":"b8756f18-1652-450a-8727-2af02e667607","457":"7ec4dbb9-6081-4924-9f99-cb02cb2515f4","458":"42c0eb53-9953-4af2-be89-aecba589a8bd","459":"a40c5b54-5ef7-4ee8-aa2d-e92912c7bc29","460":"5f053e00-40c4-4aed-8443-832360c95e09","461":"20e5b6e4-8945-4fa9-9425-9b51c585de35","462":"2221d7d3-d347-4567-bfe3-7b9cf9871c98","463":"f1952ba4-443e-414b-be56-822182251b10","464":"926ce26b-1fd4-43f5-9454-a7bb0d948f2a","465":"c126f7fa-9512-4c4c-9be3-9243ae3989c8","466":"efd72152-2919-4b51-b8c0-06b77991ed03","467":"405bf932-73e4-476e-88ea-a72a4ff64fe3","468":"69a2ec87-36a2-4c9f-a02a-92d4bf29a900","469":"3853d25b-79a5-4d0a-a03b-566fbf34554e","470":"5b9ea279-5eb6-41f0-ad22-fa5a30f6ecac","471":"bf126d72-4819-46b3-bc8e-11925e6401fe","472":"385dbe6e-9308-4f4a-9f16-c79f8c3cb1b7","473":"fa9b8f6a-02d0-4bfc-bfeb-c5eafe531b86","474":"b696d03a-e264-4f09-b0a3-eb139ee0be0d","475":"04fc4fc7-bf58-4b0d-acef-f54987ab5d0f","476":"21c84cda-9790-47c2-b5b7-8e6a73beb884","477":"86ac5612-ad47-45fe-b82c-c9d8867dbf01","478":"c3a2a69c-e032-4c4c-b674-5d083fa2442f","479":"84a545ec-0aa6-4201-b968-775fe1a92614","480":"5cf2d1be-4413-44d7-aae7-9b57e002796d","481":"7946624c-deb0-47d3-a22f-975c3a4252ff","482":"3d6f2091-b375-4f25-816e-7fefbf39f8d1","483":"5796eef7-b5bd-4eb9-947b-3ca49f1fbbf0","484":"b996fbc7-07b9-467a-8c01-694b6eabbdfd","485":"0df539e3-b23f-4b5d-b9e3-2b794e2dc70b","486":"4429d525-eba5-415b-90b9-4b3434ed4186","487":"f9138530-22a0-4c41-aaed-e384a24b355f","488":"9f6d661d-b81c-4978-806f-cf7fe05f2732","489":"dc44735b-3e01-49ee-bfd5-3a18f9191812","490":"359f160b-cc95-4bcf-9c90-6ebc30f28bd5","491":"4e02ab6d-17e7-4aa0-9c72-2206c76f9fb1","492":"96f1f656-9381-4395-910d-d8ef4942d871","493":"c67b12f7-d8d1-4af4-9c79-5ecf94b7ba85","494":"261475ec-459a-4f7d-a5dd-51c9752f28fd","495":"4535ff12-ad7f-48ab-966c-74aa3b5af1ad","496":"46ecce4c-6ba3-4c0b-a2ba-b5ca14a12705","497":"a5406bce-9ce6-4ea9-ae64-9e076cddf2cc","498":"36d8c0a1-34b6-449a-b896-373fb81957ed","499":"5199553e-9948-4180-9878-2adb9dade3ea","500":"2df08605-7723-4a13-9bd5-61dd6e11f938","501":"bba8cf49-a371-44f6-9e9a-e3c3848b2a0c","502":"9887ca3e-5f3c-4324-be3b-79f27d789ed0","503":"9d646a7f-4a49-4ef3-a735-f61e56dd1c69","504":"12323882-3209-43d5-a20e-149f28161ea3","505":"3785a051-a195-406d-b479-6448fab648aa","506":"6ab3d5c9-db47-469e-a7d6-20a37456d600","507":"1ddf6cfe-83bd-4f46-8c5d-ad3471f406a4","508":"0874f27c-32f0-4ac0-8dd2-f364482bb79e","509":"e2f20df4-7ef7-4b27-bb6e-ff498ca59442","510":"0b68c46d-ee3d-4aa1-895b-f24a6ea3b557","511":"65cd17fe-8fa9-43a7-9a48-683227ea7c01","512":"586d32d3-8438-4ad8-9466-840597da3050","513":"599a041a-4ec9-4906-a574-0031f65c12dc","514":"16a277b8-15b5-4ea4-bb26-2932cc5fbfde","515":"2dfc6ca5-7ecb-4455-9ee5-36dda8c3f913","516":"7792b925-1be0-4a23-8856-0f8ecd16903b","517":"c49b1af3-5ff4-450d-9d79-d6f33d2dbc70","518":"07916967-e401-45b5-b410-cf613d37acc0","519":"1408315d-a6f3-4960-b635-db0f8d79b186","520":"b5152796-bbb9-4031-9535-9f2ad7617210","521":"1e904af0-f6e6-4e34-875d-43476a257600","522":"8e543f14-fe12-4402-9522-e475cbae09c9","523":"adff413d-93e2-41c8-b500-24407da63823","524":"eb6a2209-84ed-4c68-a69a-4e44860dd2df","525":"c4529566-9549-458d-a082-efbc5a9a2a77","526":"ac924b01-a308-4bf0-bd76-89ce9e62a2a6","527":"aced63ed-10c0-466a-9812-d4332d668244","528":"caeb8e5d-7999-4419-aa2e-577b7525d77a","529":"2bf11697-ac1c-41bd-90a5-b6bcc9bd1c34","530":"6388f655-e251-44dc-abe3-7a7c2d587c97","531":"e85cd9c5-1d33-46af-a96f-352e582ebb0c","532":"cd8c9d1a-374b-43d6-8f49-5a029186e056","533":"100d6442-e386-47c1-ab48-95f7d7831e7c","534":"82598701-5a21-4d6d-9ee3-245ce70da165","535":"e3d186b0-5e2d-476b-8c62-7c0de56ff883","536":"d7d10527-67d4-4346-898a-58e60e1f7ca7","537":"090b1ea8-4b64-41fa-8e17-8c747f2917f8","538":"dd2cd789-7761-41c2-9efa-a9aea8e9c61b","539":"b9d9fd46-26d3-480c-b3e5-08f617e0432c","540":"d7938808-9812-4816-8f54-12e38c917c92","541":"676e0d36-59ae-4eee-a61d-209d1215b6e4","542":"39a01071-1859-4fdc-8d01-71328448e9e2","543":"07b13c7d-4531-4878-8d4a-1c1362cf36a8","544":"e49e883d-699f-47de-a568-32397a380527","545":"40acc388-1723-4d8e-86ef-28e70e2ba063","546":"8ebcf4bc-a683-4226-8d8a-ca3ad1945877","547":"8ef24568-ee32-4c1a-9306-af2fdded3ca1","548":"862eb382-4e6b-41f7-bd35-ec728936bac0","549":"f8e0727d-5d83-4185-9385-a62c9f102558","550":"a6db37a8-d3fc-42ab-82b7-6cb36f360e09","551":"6004ccac-9305-4bc1-81e2-3e789df40d29","552":"acad10fe-bba5-4a30-b893-8f6f6a59c82f","553":"047885bc-666a-40a3-a002-1d99272f0ee9","554":"8c69ec34-4d0a-4bec-8ad8-01322923bf3c","555":"68f0a7f9-96bd-4302-a5b5-6d1b3f013d4b","556":"c21512da-6d0a-416d-b3a5-d8d9201311ba","557":"f7bd1b05-8a08-4242-8cd6-2f7cca951d7b","558":"0b911052-477e-4a0a-9291-ba127a9d1f52","559":"83764dde-6a65-4932-ab48-891e195f6fc7","560":"04735f8c-0fd2-45dd-a75e-a2ecf3f0e55f","561":"198e31a6-e34e-414b-a914-ec95789767da","562":"c4ea985e-f8b0-4277-b106-8726a7fe3caf","563":"d605db9c-435d-4c6a-99c6-7a3545b1e155","564":"3a3787bd-0414-4621-b525-a8c7f0841f9b","565":"edbeba25-72d1-49a2-b027-a4da90bbdf77","566":"ea3f7404-d5a5-491b-acc3-af9a78a6f5a2","567":"86a62a99-12ee-42c9-9938-fdea608fc45c","568":"c3a94020-b9ae-4a5c-99f9-eb1927be5c19","569":"a9d0c236-f5d1-4c14-9fc9-c25e130fd160","570":"e879589d-9e0a-4fff-90b6-14bb451a20d6","571":"499c6deb-9cb2-4245-b69e-a51693209a1c","572":"8415ee65-5cec-47ea-8819-7e438f5d0262","573":"c0c935b1-c2b3-4811-9b82-d6d8e1bc4265","574":"926de036-ec10-4ca3-b29c-60cde32098d7","575":"bf80910d-0cfa-415a-be45-d8c856d7f14d","576":"951cbaf9-acb1-4a43-8a57-cb16ff124de6","577":"fb7a1d0b-3df3-4b35-9d78-f9b2d2d133f0","578":"ba90ef63-2df2-4881-9497-e73b1260c403","579":"f761dcbb-540a-4e17-9ff6-9e8f5311aad9","580":"a2a72dd8-95f7-47ac-9a94-af7a497ff7e2","581":"34dcf05a-43f2-4ca9-b610-3edd405c1a62","582":"33e1f48a-d7c4-4c2a-acf8-4afc9eee3253","583":"757e8df9-c40b-474c-b4e3-ffe2d194c24b","584":"212e51b2-3191-4d25-ab92-f197f518ec33","585":"a5d8e8df-d2d2-4e5b-8353-e6dcb446adcf","586":"252b9112-859e-4ea6-8447-d286232c3d53","587":"29ec7b23-42db-4648-8926-80fe003352c9","588":"e0375d6b-51a3-4910-9561-8f5c95d36a3c","589":"27d7272c-4cc2-44b8-9c45-4e5818d9944a","590":"0c12fd47-1591-44b3-a9a1-ba7b3acc279c","591":"69085e72-d7c4-424f-9896-9727213a3a01","592":"55670c3c-86ad-4a45-aebc-985fc4654b5a","593":"589950c9-bb57-43b3-a986-f1608a69c1f3","594":"17b40794-e3e5-4134-af97-759b10a62360","595":"85d4551f-11bd-40a6-86d9-6432a9107b9a","596":"af3948a3-88e3-402c-8603-caf0a4685ddb","597":"f7b448cd-ddf8-46cd-af60-ac0660bcc5cd","598":"6f2b2011-8904-4d72-ab72-3fe1be9cc917","599":"54f8c622-331a-4b45-a77a-d65d4255fe9c","600":"fd32600a-b668-4137-a866-a5dd5accc6c3","601":"b606b1fc-8177-4bcd-b67b-629382d9ccef","602":"2f32d8a3-ade5-4e8e-aecf-68d8ce782efa","603":"463a8437-c37c-4bf7-ae81-8d949963ba63","604":"7af13589-8900-4579-a67d-bcaddb385d10","605":"5a175cae-5253-492b-89e0-e5bc1f58fef2","606":"b22d2c88-1d1c-4695-9007-5790d0dd216e","607":"39c53d76-4fac-494b-b779-425d7d69a14d","608":"526b0218-237d-48e4-aaf2-e200184c62b9","609":"18b34bf1-9b64-44ed-8c60-d2eb76d0e1ad","610":"8f8556eb-1aab-4963-b4f0-e86f5e07e457","611":"8f0a8730-c1d8-4237-9cbd-2b4819259183","612":"2fd43cc8-487e-4fc6-9095-c5792914d7c6","613":"83c7ae05-7b58-48a0-860e-8c4df6b44bb4","614":"caab5c58-d8af-460d-9610-fd9526d42427","615":"224fe9d1-c930-484b-9302-06a27d9e4c35","616":"ce1b167e-7209-40ed-9acf-c610d6f1476b","617":"ff440e3f-536b-43ba-a654-d7863de93580","618":"79031f14-b5dc-4618-9501-d1c3ea53b351","619":"73b0f762-0b5c-43d1-8670-1d2af36fdf96","620":"8cb97a41-4717-4482-b737-1a23923696ac","621":"4110871b-54ba-4209-b0ee-ed300c4d1e65","622":"9abc2b32-5895-4e05-96e0-dc80ec1e3d20","623":"13d12236-15c6-4ecc-a761-18976bb186ea","624":"da7ddec9-23c0-4402-acdd-a66099c462bb","625":"202ee8b3-bd55-4c4d-9005-d1fc8389dd4c","626":"a2ba0e1c-a0ee-4077-a1ef-6b22b2f85b06","627":"cf8960fb-78dd-4b17-a439-01770db9b3f1","628":"2da0a8a6-d42f-4eee-818e-849a511a60ee","629":"8e156e58-0b85-41d3-8915-6cf4408c812c","630":"8ee46845-47ba-4388-a494-8e018a18ef05","631":"f44566f6-486d-4153-88b8-1e7f456a5a1b","632":"707c2e5b-8c90-4791-9d96-d1f55abc70db","633":"f31df904-ea18-4940-9311-e674e0b70979","634":"82e82058-f639-44aa-a261-2b61f3069351","635":"872d49c7-3971-48da-ad70-4856805e18fd","636":"246f65f7-003c-4308-8af4-39e51e750c49","637":"b3f37d19-69cf-4d90-9670-e28b72a5731e","638":"9001b450-50c9-48d6-8f91-f5546ca7cee4","639":"cfba0f42-851e-4ad2-bbcd-3cfa6406bbee","640":"71e7a4bc-7740-4514-9b27-4bbd8585466f","641":"0d6ce167-e3d5-428e-983f-905f3fc1d205","642":"a216ad45-14db-4bb2-8bc1-f42b95ead032","643":"5e5bce74-d274-484b-ab30-1773b10ee84a","644":"aa35b03a-a81e-49cf-bd8e-0c1d4c602855","645":"778e6938-87f1-4e2a-ae21-151996055864","646":"d35f472a-a014-4fd3-9385-5101d958d26b","647":"31c81576-930a-4d40-8eac-dae2090fe1d6","648":"9a8f19cd-3f09-41a5-9070-5131f13b898a","649":"176520e8-4eec-4de6-a27d-e6267a623844","650":"f86ca79d-082d-4c5d-ad6a-a326ad5f2383","651":"c656cda2-ed62-4717-8197-4bc3d75455de","652":"9dfd6756-7868-49d3-a5f8-cf7cc3b40bd1","653":"30fd440a-2241-4a88-9c18-512fb9677b48","654":"33078e78-dcc1-40ca-aceb-6f285d4afb02","655":"9c0af075-cf3a-4676-9639-f12b6e4b3c86","656":"f4ac7b75-e648-434a-b911-5b23936425dc","657":"04788715-8f01-47df-997f-ed12691bb08a","658":"ebd4fef2-a29f-4774-aa62-91315bb7f178","659":"149ca3d4-b16c-4715-af88-07027e3023ca","660":"9a9a4162-7b9c-46a2-a4af-0e23769b174a","661":"8e7dacc6-1aae-4564-94c3-75e5cda66361","662":"03498e70-10c5-4f83-8f64-182a523fa814","663":"abae19bb-c7a0-438b-9029-48235e6f6a10","664":"7b011b4c-527c-41fc-a6b4-7a6508850611","665":"51e30c8e-d7bc-404b-b140-963d690c16e7","666":"7ac1155c-9550-4ab4-9cc1-6d849afd2504","667":"b8c69941-f8c3-4097-926d-f549a1fdc11b","668":"aeddf4be-b886-47b2-a4cb-6c584f5cfda0","669":"88d7a84a-3c69-4e72-ade9-a14d10457559","670":"e560bf65-ac47-4ec1-a148-bccfdea53133","671":"64b84813-3948-4cfe-9efe-e55e23b707aa","672":"8d595273-3dff-4d8f-ab10-60d7b4b455da","673":"f2f85de5-b206-4a02-8ba8-5dd04bea151f","674":"18529eb8-19b6-421c-bee3-fbfba4b84a37","675":"e0d07f6d-774c-45f8-92d3-39aa1cdd05a3","676":"3c78a55a-ecf3-40c9-af19-58162c66424b","677":"19fb0654-ff55-4dcc-9148-d29fdc598158","678":"a643a5e3-8d00-4f9d-bc0f-8499754d713c","679":"26b49068-0bb2-4e78-b89c-bab0d44f2922","680":"de57e667-c1dc-461c-b445-60f9545384d0","681":"0e1a301a-2d7f-4b52-8382-6d1cbcf74a9e","682":"4e4c4a32-bc4a-48b8-9b4d-9b35108140e3","683":"d1350c39-83e1-43f8-a865-065c2dee0f10","684":"1f03f958-abd2-438f-a92c-bfd21db7a653","685":"d29ccee4-519c-4aba-9cac-bdc59a4796d1","686":"580bd82a-9452-4156-9f34-2917d514f136","687":"9b8e95a7-ff75-4bef-926a-22f847a4d631","688":"e8c410d2-b8d9-42d1-ada5-7a1d15507988","689":"e5cee66f-05ae-477f-8303-8683fbc324f1","690":"fe0c0437-9bc1-4687-8671-4fe5a9dd6744","691":"c8f6fff0-7cb8-448b-bab9-2381342d11d0","692":"4ba268bd-8bc2-426f-a75b-87f9cd2727d3","693":"fe356d10-2ad8-4697-b0a1-1c55769ca468","694":"7755f7c4-a5a6-4525-9f6e-27311c31500a","695":"48bc79d7-43aa-4f9f-a0f5-032d1cc2241e","696":"36a04adb-8c81-47c7-952d-c161876ce9f5","697":"bb6f0269-160c-45a2-8333-7755daf17faf","698":"df354433-4d64-4b96-a927-054027b349cf","699":"3c6bd5ef-5471-4297-8dd4-4442ccc5a2f4","700":"04de6e6e-fba0-4662-bb3a-7f5cd67c1d8b","701":"a61df673-e327-4d42-9106-ee5da26e3804","702":"9886e5ac-82a8-45fa-a902-618907edf712","703":"1a78f060-d15b-4590-b091-9cb1f4498a30","704":"fa8f537b-21cb-46c8-b108-de4767c48770","705":"bfbf7249-64e8-4617-941c-bc0f079029b3","706":"ca441750-daf3-4592-819f-880005b74a94","707":"e64d3ef3-00fb-46a5-820d-98d8881f5451","708":"3e744782-3c41-49e8-8c49-507bc5ebfe0d","709":"b3289d48-17f7-4a8c-8c5b-2ab97282c23e","710":"e2831579-87ce-4da3-a2bb-408b0d3d46a0","711":"5acf36a5-b200-4c84-ad47-6f84352a1676","712":"335441d4-4d86-46f0-849d-55749e3bd012","713":"5c26fbc0-d522-470a-b185-3e7cca72abb1","714":"139c74e8-7f8f-4c7c-b1f6-bd805c6a9602","715":"30fe2f4e-c2b4-4d16-b586-82503e86db40","716":"7f0f3d76-7b12-4227-804c-488cdfb82c8c","717":"3731c67b-d7c7-4a92-ac49-e0ee04a15212","718":"b641fd1b-2acc-4934-893e-3c804f3e29c1","719":"39a3f0d6-61ab-470f-b4e2-af220fbe5566","720":"7b4a9fdc-04ad-44ab-bff2-b05bbc1d96c4","721":"6ac42576-8e6e-47b7-8a5f-3bf8eb378045","722":"1cec2f7d-fc11-4ec2-867e-c6b204ce56e2","723":"8739698e-882f-4339-9d29-b948b914cd6a","724":"ecc99a39-ff5b-4b24-bbbf-f983cfe13a55","725":"58e4cd54-718a-4fa5-a857-22106e1fba8e","726":"06b3eb3d-0025-45c0-8a01-5b8147722f96","727":"a23dc478-9493-49a6-8823-e3fc1931fa28","728":"68517374-2a18-4cda-b03d-2c757dc5ea2f","729":"34123d00-0379-4abd-9f0a-230c32df2fba","730":"7d90afbb-203a-417b-8bd8-a3634244693a","731":"1c4a4252-81c1-4191-bfdb-3fbe1d9e8ea7","732":"b616c4fc-f5dd-4031-9405-7e2b85977639","733":"786bd546-b421-4c47-b794-60f493b014e3","734":"8dd72d30-cfee-4d0d-9127-e4a15814053d","735":"3c865863-816d-461a-8223-87ff02b1a318","736":"0c31cd46-0cf3-436c-a037-4963ac8a0480","737":"3c4280d8-bc10-4152-a3bf-7c8a47a30180","738":"9735d392-a21b-4832-bbc3-9c43bd4dd85f","739":"84b88c07-20c2-45e3-9ab4-0b6de330d809","740":"9c4ed19c-100e-4ef0-94f2-6f5524594f11","741":"9f5161e8-3ba6-4772-89f0-1edbeb1dd7de","742":"2d18352e-4239-4c98-8a20-d15fa979da46","743":"4d0521f7-2bd5-4f35-b990-731216bf2f44","744":"740ddef6-a0d2-4261-aca4-d73028b0361c","745":"8f0ebd60-2d7e-4ca1-b341-009022fcf782","746":"b687089a-2813-4054-b43c-f641abf60e14","747":"5cbc5be6-f7a0-4fec-9f65-e3774abf54f0","748":"e8734597-ed0c-430c-846e-5a3649ad5d7e","749":"aca6474e-222d-41c0-8b20-8da2e81ea072","750":"5d7ff462-815c-4adb-994e-5ddb8217a94e","751":"16b83cd0-9a58-4e37-91df-42825a3c150e","752":"ce363a71-8dd1-4199-841a-021651590e61","753":"ffcad2ec-3d6f-4a1d-8e2f-798273c89246","754":"e84ed565-fc5a-4fce-b23d-62cb9097c075","755":"c0d4d29f-e64c-4553-801f-2ebcd3a6e024","756":"6a14f90b-4f9c-4311-b06e-6eac9abb5c3e","757":"ab928191-78b1-46c8-99b4-1b213739c741","758":"b6c7d547-3e5f-4613-9cb2-afc737ea35b8","759":"72713bb7-76d1-42fd-9ea5-1146339e277e","760":"697c9321-ee7d-4fd5-8b1f-c5fdf21cb290","761":"d09d7597-6402-4d10-918b-4c3d0b995fe0","762":"a41e2a1f-ddbd-4957-963a-f7f4a56cd465","763":"2852bd1f-a790-49cb-ac46-0a77b21b39c1","764":"55bfa298-124c-406a-bf21-bf624259d97d","765":"df7b5d4e-b034-4c62-b8d0-346237018fc4","766":"6f572522-ad49-4434-84fd-0435f54f3432","767":"3d0e68df-9b43-4c9a-bfe7-36bf92b54d2e","768":"2256b904-a211-4522-9d1d-429eb3330586","769":"204cc75e-2fd7-411c-b7a2-e264ef804a3a","770":"e90192ed-f788-47ac-86fe-fbec7a446b7b","771":"d10a8504-1b58-4196-ace4-594907d9a256","772":"b5e7cc43-3bb2-488e-9c0b-5633f576b231","773":"d6b0453a-4931-4e41-9759-71886b32d811","774":"10d97444-c0d1-40fc-80fc-1fdf10ba437e","775":"7d83b8db-07af-43ee-abaf-6263344b91be","776":"3d118a21-9fd5-47cf-95ae-b879ecd6050e","777":"269ecc78-9c52-4514-ba30-97822a931e7c","778":"947908fa-df0e-41cd-81ea-5348c4194bfc","779":"6b6f88d1-f918-4fe5-824b-7fa8b4113938","780":"65a66fb3-9480-427f-be67-226d1e7bd628","781":"78f88f8b-0b78-4389-9983-f84c9f8541d4","782":"79cd75c7-5438-4d51-ae96-deb25880d0c2","783":"f7b38e5f-b843-40ea-b6d9-05d307d9e1c7","784":"28b6b65e-d50d-4f59-b92d-3a18fe40f7a8","785":"3d283faa-fd83-46f0-ab80-d681e4f01e86","786":"6e0ffa4d-0018-4597-9edf-ff55dfdc63e2","787":"8d859716-4e21-452d-aeaf-f036855cd07b","788":"06cc1d9e-4fea-4660-95df-9d859bf304a6","789":"9d9bbd6c-6651-4fc8-9b06-72526627f0f8","790":"9a43d3b3-99fc-406f-95e1-860671c1b80d","791":"0ea99679-f059-459a-83dd-2023343eb854","792":"299cfaa1-e4c6-4abe-a491-44f149c1b06d","793":"56f11d8b-f2ac-4ec2-8f01-341446397f7a","794":"1ebddcf9-3bc9-426f-9559-3047f5584b48","795":"55eb5950-d8f6-48b9-ba43-0f5d63465043","796":"6a142765-e139-4df4-88fb-e96f66904ca7","797":"4af3077c-6a95-4abf-8218-361c70fb95c1","798":"d2c49d7d-16b0-41f8-89ef-150f8236f30f","799":"fd29fff1-3b62-47c7-a1b7-c7eb8e98b392","800":"b7432b4c-0b47-4283-8e83-042efec55991","801":"dab81219-f450-453e-becb-4144f060c444","802":"e8674242-bb52-43a5-91e7-258212a81778","803":"8416ab8c-a490-456c-aa60-b84a924bd26d","804":"109c71bb-d490-4dbd-93bf-f2b0cb2be054","805":"46bbee84-7218-4104-9bf5-a8490774b47a","806":"59eff01c-7b92-4273-b032-6a1cae58b0d7","807":"208db682-46f5-4841-8f93-b4c52b63e1a8","808":"63b44a1d-11fb-41cb-b251-3745f175c49c","809":"161cb4b1-7f0d-4933-9549-15b951fb600d","810":"c3829df3-ec3c-48bc-8afd-3eac827b0707","811":"d8f2f2d0-29d9-4923-88f6-e8038025f2bb","812":"5782302f-4ab9-4ec6-ac75-76ba999eb6a6","813":"4b0459e2-441e-4ca8-9ef3-dcf426c0cfd7","814":"9dac4a68-ec64-41a6-832a-52e02843f85d","815":"f22f8d66-ebd3-4bfd-8a60-537ad31c6f18","816":"b33f8985-2d99-4ee4-ac22-489d4c503c7f","817":"a3b458bc-5c9e-4d43-a2ac-81d6ed3f2b21","818":"890677e1-35ca-4252-8ce2-832120eb2b58","819":"70f17d49-c033-4f03-a364-56f77a0a4afc","820":"596e1215-cbf8-450f-9bc2-96166f0ace52","821":"ed936f47-91be-4cbd-b828-7ecd46f5a2e6","822":"a8546905-a2a6-4f15-9fb9-0a5e57fc9fd8","823":"4a27cf28-5f4c-4fc3-863a-77519965bb42","824":"41fbab7c-eb74-4cf4-a43a-db62008965d5","825":"e1622a72-0a0e-487f-8365-ff97b8c448c2","826":"2393da21-507a-456f-b623-c3314f4e690b","827":"b929dd56-c4d2-49d6-b1f9-d1e7f5172d79","828":"ad862fb8-999e-4614-b3a6-a164ba1aacef","829":"f92d5684-e52f-46d7-b43c-9e53c6c60514","830":"b2378e3d-1fb6-4df0-bed7-6d0fe642bfd1","831":"f1a6c954-6bbc-44ba-a638-2d1e52250ab9","832":"93faf110-89c7-467f-9817-798ab271af4d","833":"ad465ea1-b251-4ba1-92b2-73247276eedd","834":"7f9429d7-72af-49eb-8cce-2a838725c42a","835":"cecd71c8-d45b-45c5-978a-1aa216835c5a","836":"14ad3894-499a-4a79-8e42-aba7e430f971","837":"5fb35c74-27e3-49be-988c-fe7e4cd48866","838":"fc2abc45-7626-4d22-9b1a-a23ecfcc107a"}]